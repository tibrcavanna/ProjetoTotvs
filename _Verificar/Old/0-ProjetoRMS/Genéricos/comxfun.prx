#INCLUDE "PROTHEUS.CH"  
#INCLUDE "COMXFUN.CH" 
#INCLUDE "AP5MAIL.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"
#DEFINE CAB_ARQTMP  01
#DEFINE CAB_POSATU  02
#DEFINE CAB_SAYGET  03
#DEFINE CAB_HFLD1   04
#DEFINE CAB_HFLD2   05
#DEFINE CAB_HFLD3   06
#DEFINE CAB_MARK	07
#DEFINE CAB_GETDAD  08
#DEFINE CAB_COTACAO 09
#DEFINE CAB_MSMGET  10
#DEFINE CAB_ULTFORN 11
#DEFINE CAB_HISTORI 12

Static lRestComp
Static cChaveDes	:= ""
Static cChaveOri	:= ""

/*/
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³COMXFUN   ³ Autor ³ Eduardo Riera         ³ Data ³ 08.12.97  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Biblioteca de funcoes das rotinas de compras.                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Materiais                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaAvalSC  ³ Autor ³ Eduardo Riera         ³ Data ³27.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de avaliacao dos eventos de uma solicitacao de compra ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaAvalSC(ExpC1,ExpN1,ExpC2,ExpC3,ExpL1,ExpL2,ExpL3)		   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela de solicitacao de compra              ³±±
±±³          ³ExpN1: Codigo do Evento                                      ³±±
±±³          ³       [1] Implantacao de uma solicitacao de compra          ³±±
±±³          ³       [2] Estorno de uma solicitacao de compra              ³±±
±±³          ³       [3] Exclusao de uma solicitacao de compra             ³±±
±±³          ³       [4] Implantacao de uma cotacao para a SC              ³±±
±±³          ³       [5] Cancelamento de uma cotacao para a SC             ³±±
±±³          ³       [6] Implantacao de um pedido de compra para a SC      ³±±
±±³          ³       [7] Cancelamento de um pedido de compra da SC         ³±±
±±³          ³       [8] Aprovacao/rejeicao de solicitacao de compra       ³±±
±±³          ³       [9] Cancelamento da solicitacao de compra             ³±±
±±³          ³ExpC2: Alias da tabela de cotacao de compra                  ³±±
±±³          ³ExpC3: Alias da tabela de pedido de compra                   ³±±
±±³          ³ExpL1: Indica se o SC1 deve ser atualizado                   ³±±
±±³          ³ExpL2: Indica se o SB2 deve ser atualizado.                  ³±±
±±³          ³               ( DEFAULT .T. )                          (OPC)³±±
±±³          ³ExpL3: Indica se o Parametro MV_PCEXCOT esta ativo para      ³±±
±±³          ³       restaurar a cotacao na exclusao PC ( DEFAULT .F.)(OPC)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. 		                                                   ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo atualizar os eventos vinculados³±±
±±³          ³a uma solicitacao de compra:                                 ³±±
±±³          ³A) Atualizacao das tabelas complementares.                   ³±±
±±³          ³B) Atualizacao das informacoes complementares a SC           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalSC(cAliasSC1,nEvento,cAliasSC8,cAliasSC7,lAcumulados,lAtuSB2,lRestCot,cAprovBkp)

Local aArea 	:= GetArea()
Local aAreaSC8  := SC8->(GetArea())
Local aAreaSC1	:= SC1->(GetArea())
Local aAreaSM0  := SM0->(GetArea())
Local cAlias    := ""
Local cUser 	:= ""
Local cFilBkp   := cFilAnt
Local lQuery    := .F.
Local nQtdEmSC  := 0
Local nQtdEmSC2 := 0
Local lSb1TES  := SuperGetMv("MV_SB1TES",.F.,.F.)
Local lSCSldBl	:= SuperGetMv("MV_SCSLDBL",.F.,.F.)
//-- Variavel usada para verificar se o disparo da funcao IntegDef() pode ser feita manualmente
Local lIntegDef  	:=  FWHasEAI("MATA110",.T.,,.T.)
Local cEntrega  := If(SuperGetMv("MV_PCFILEN"),If(Empty((cAliasSC1)->C1_FILENT),xFilial("SB2"),SB2->(xFilEnt((cAliasSC1)->C1_FILENT))),xFilial("SB2"))
Local cQuery	:= ""
Local lPrjCni := ValidaCNI()
Local lItAlguGCP := SuperGetMV("MV_GCPAGL",.F.,.F.)
DEFAULT cAliasSC1   := "SC1"
DEFAULT cAliasSC8   := "SC8"
DEFAULT cAliasSC7   := "SC7"
DEFAULT lAcumulados := .F.
DEFAULT lAtuSB2     := .T.
DEFAULT lRestCot    := .F.

DEFAULT cAprovBkp	:= ""

Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de uma solicitacao de compra                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza dados complementares da solicitacao de compra                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( !lAcumulados )
		RecLock(cAliasSC1,.F.)
		
		If (Empty((cAliasSC1)->C1_PEDIDO) .And. Empty((cAliasSC1)->C1_COTACAO))
		
			If Empty((cAliasSC1)->C1_USER)
				cUser := RetCodUsr()
				(cAliasSC1)->C1_USER    := cUser
				(cAliasSC1)->C1_GRUPCOM := MaRetComSC((cAliasSC1)->C1_PRODUTO,UsrRetGrp(),cUser)
			Else
				(cAliasSC1)->C1_GRUPCOM := MaRetComSC((cAliasSC1)->C1_PRODUTO,UsrRetGrp(),(cAliasSC1)->C1_USER)
			EndIf
		
		EndIf	
		
		
		If (cAliasSC1)->C1_IMPORT == "S"
			If (cAliasSC1)->C1_COTACAO<>"IMPORX"
				(cAliasSC1)->C1_COTACAO := "IMPORT"
			EndIf
			(cAliasSC1)->C1_CLASS   :=  IIf(Empty((cAliasSC1)->C1_CLASS),"1",(cAliasSC1)->C1_CLASS)
		ElseIf (cAliasSC1)->C1_IMPORT == "N" .And. (cAliasSC1)->C1_COTACAO == "IMPORT"
			(cAliasSC1)->C1_COTACAO := ""
		Else
			(cAliasSC1)->C1_COTACAO := If((cAliasSC1)->C1_QUJE==0.And.(cAliasSC1)->C1_COTACAO=="XXXXXX","",(cAliasSC1)->C1_COTACAO)	
		EndIf
		If (cAliasSC1)->C1_IMPORT != "S"
			If !lPrjCni .And. Empty((cAliasSC1)->C1_SCORI)
				If SuperGetMv("MV_APROVSC") .AND. !( SuperGetMv("MV_APRSCEC",.F.,.F.) ) .And. !(cAliasSC1)->C1_QUJE > 0 .And. !Empty((cAliasSC1)->C1_COTACAO)
					(cAliasSC1)->C1_APROV := "L"
		   		ElseIf SuperGetMv("MV_APROVSC") .AND. !( SuperGetMv("MV_APRSCEC",.F.,.F.) ) .And. !(cAliasSC1)->C1_QUJE > 0 // Verifica se a SC foi atendida total ou parcialmente
			  		(cAliasSC1)->C1_APROV := IIf(MaVldSolic((cAliasSC1)->C1_PRODUTO,/*aGrupo*/,/*cUser*/,.F.),"L","B")
	   			ElseIf SuperGetMv("MV_APROVSC") .AND. SuperGetMv("MV_APRSCEC",.F.,.F.) .And. (!FwIsInCallStack("MATA126") .Or. (FwIsInCallStack("MATA126") .And. Iif(ValType(lConsEntCtb)<>"U",lConsEntCtb,.F.))) .and. (Empty((cAliasSC1)->C1_COTACAO) .OR.  !Altera) //-- Se compra centralizada, apenas atualiza flag da descentralização 
	 				(cAliasSC1)->C1_APROV := "B"
					(cAliasSC1)->C1_COMPRAC := '2'
		  		EndIf
			EndIf
		Else
			If SuperGetMv("MV_APROVSI") .And. !(cAliasSC1)->C1_QUJE > 0 .And. (cAliasSC1)->C1_COTACAO == "IMPORT"
				(cAliasSC1)->C1_APROV := "B"
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza as tabelas auxiliares                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(cEntrega+(cAliasSC1)->C1_PRODUTO+(cAliasSC1)->C1_LOCAL) )
		CriaSB2((cAliasSC1)->C1_PRODUTO,(cAliasSC1)->C1_LOCAL,cEntrega)
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se deve atualizar o Campo B2_SALPEDI            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lSCSldBl .Or. (lSCSldBl .And. (cAliasSC1)->C1_APROV <> 'B')
		If lSb1TES
		   	If (cAliasSC1)->C1_ESTOQUE=="S" .Or.  Empty((cAliasSC1)->C1_ESTOQUE)
				GravaB2Pre("+",(cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE,(cAliasSC1)->C1_TPOP,(cAliasSC1)->C1_QTSEGUM-(cAliasSC1)->C1_QUJE2)
			EndIf
		Else 
			GravaB2Pre("+",(cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE,(cAliasSC1)->C1_TPOP,(cAliasSC1)->C1_QTSEGUM-(cAliasSC1)->C1_QUJE2)
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza os arquivos do SIGAPMS                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If GetMV("MV_INTPMS",,"N") == "S"
		PMSWriteSC(1,cAliasSC1)
	EndIf
	If ! lAcumulados
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LancaPCO("SC1","000051","01","MATA110")
	EndIf	

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cancelamento de uma solicitacao de compra                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SC1->(RestArea(aAreaSC1))
Case nEvento == 2
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza as tabelas auxiliares                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(cEntrega+(cAliasSC1)->C1_PRODUTO+(cAliasSC1)->C1_LOCAL) )
		CriaSB2((cAliasSC1)->C1_PRODUTO,(cAliasSC1)->C1_LOCAL,cEntrega)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se deve atualizar o Campo B2_SALPEDI            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
	If !lSCSldBl .Or. (lSCSldBl .And. (cAliasSC1)->C1_APROV <> 'B')
		If lSb1TES
		   	If (cAliasSC1)->C1_ESTOQUE=="S" .Or.  Empty((cAliasSC1)->C1_ESTOQUE)  
				GravaB2Pre("-",(cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE,(cAliasSC1)->C1_TPOP,(cAliasSC1)->C1_QTSEGUM-(cAliasSC1)->C1_QUJE2)
			EndIF
		Else 
			GravaB2Pre("-",(cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE,(cAliasSC1)->C1_TPOP,(cAliasSC1)->C1_QTSEGUM-(cAliasSC1)->C1_QUJE2)
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza os arquivos do SIGAPMS - Estorno da SC                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If GetMV("MV_INTPMS",,"N") == "S"
		PMSWriteSC(2,cAliasSC1)
	EndIf
	
	//-- Se gerada por compra centralizada, libera SC origem
	If !Empty((cAliasSC1)->C1_SCORI)
		SC1->(dbSetOrder(2))
		If SC1->(dbSeek((cAliasSC1)->(C1_FISCORI+C1_PRODUTO+C1_SCORI+C1_ITSCORI))) .And. RecLock("SC1",.F.)
			SC1->C1_COMPRAC := "2"
			SC1->(MsUnLock())
		EndIf
		SC1->(RestArea(aAreaSC1))
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Exclusao de uma solicitacao de compra                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 3
	If !lAcumulados
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Alltrim((cAliasSC1)->C1_APROV) == "L"
			LancaPCO("SC1","000051","02","MATA110",.T.)		
		Endif     
		
		LancaPCO("SC1","000051","01","MATA110",.T.)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza os arquivos do SIGAPMS                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If GetMV("MV_INTPMS",,"N") == "S"
			PMSWriteSC(3,cAliasSC1)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retira a amarracao da SC com o Pedido de Compra.                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lQuery := .T.
		cAlias := "MAAVALSC"
		cQuery := "SELECT SC7.*,R_E_C_N_O_ SC7RECNO "
		cQuery += "FROM "+RetSqlName("SC7")+" SC7 "
		cQuery += "WHERE SC7.C7_FILIAL='"+xFilial("SC7")+"' AND "
		cQuery += "SC7.C7_PRODUTO='"+(cAliasSC1)->C1_PRODUTO+"' AND "
		cQuery += "SC7.C7_NUMSC='"+(cAliasSC1)->C1_NUM+"' AND "
		cQuery += "SC7.C7_ITEMSC='"+(cAliasSC1)->C1_ITEM+"' AND "
		cQuery += "SC7.D_E_L_E_T_<>'*'"
		cQuery := ChangeQuery(cQuery)
		SC7->(dbCommit())
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)
				
		While ( !Eof() .And. xFilial("SC7") == (cAliasSC7)->C7_FILIAL .And.;
				(cAliasSC1)->C1_PRODUTO == (cAlias)->C7_PRODUTO )
			If ( (cAliasSC1)->C1_NUM == (cAliasSC7)->C7_NUMSC .And.;
					(cAliasSC1)->C1_ITEM == (cAliasSC7)->C7_ITEMSC )
				If ( lQuery )
					SC7->(MsGoto((cAlias)->SC7RECNO))
				EndIf
				RecLock("SC7",.F.)
				SC7->C7_NUMSC  := ""
				SC7->C7_ITEMSC := ""
				SC7->(MsUnLock())
			EndIf
			dbSelectArea(cAlias)
			dbSkip()
		EndDo
		If ( lQuery )
			dbSelectArea(cAlias)
			dbCloseArea()
			dbSelectArea(cAliasSC1)
		EndIf
		
		//-- Se gerada por compra centralizada, volta SC origem
		If !Empty((cAliasSC1)->C1_SCORI)
			SC1->(dbSetOrder(2))
			If SC1->(dbSeek((cAliasSC1)->(C1_FISCORI+C1_PRODUTO+C1_SCORI+C1_ITSCORI))) .And. RecLock("SC1",.F.)
				SC1->C1_QUANT   := SC1->C1_QTDORIG
				SC1->C1_RESIDUO := ""
				SC1->C1_COMPRAC := "2"
				SC1->(MsUnLock())
				
				//-- Troca filial para processar acumulados
				SM0->(dbSetOrder(1))
				SM0->(dbSeek(cEmpAnt+AllTrim(SC1->C1_FILENT)))
				cFilAnt := FWCodFil()
				MaAvalSC("SC1",1,.F.)				
				SM0->(RestArea(aAreaSM0))
				cFilAnt := cFilBkp
			EndIf
				SC1->(RestArea(aAreaSC1))
			Else
				SC1->(dbSetOrder(11))
				//-- Se centralizou, exclui a SC centralizada
				If SC1->(dbSeek((cAliasSC1)->(C1_FILIAL+C1_NUM+C1_ITEM+C1_PRODUTO)))
					If MACanDelSC("SC1",1,.F.) //-- Se puder deletar, deleta
						//-- Troca filial para processar acumulados
						SM0->(dbSetOrder(1))
						SM0->(dbSeek(cEmpAnt+AllTrim(SC1->C1_FILENT)))
						cFilAnt := FWCodFil()
						MaAvalSC("SC1",2)
						SM0->(RestArea(aAreaSM0))
						cFilAnt := cFilBkp
						
						//-- Deleta
						RecLock("SC1",.F.)
						SC1->(dbDelete())
						SC1->(MsUnLock())
					Else						//-- Se nao puder deletar, remove vinculo
						RecLock("SC1",.F.)
						SC1->C1_FISCORI	:= ""
						SC1->C1_SCORI 	:= ""
						SC1->C1_ITSCORI	:= ""
						SC1->(MsUnLock())
					EndIf
				EndIf
				SC1->(RestArea(aAreaSC1))
			EndIf
				
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Exclui o documento se gerado na CPM                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
			A181EXCCPM('1',SC1->C1_NUM)
		
		EndIf
		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de uma cotacao para a solicitacao de compra                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nEvento == 4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cancelamento de uma cotacao para a solicitacao de compra                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nEvento == 5
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de um pedido de compra para a solicitacao de compra         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nEvento == 6
	If !lAcumulados
		RecLock(cAliasSC1,.F.)
		(cAliasSC1)->C1_PEDIDO  := 	(cAliasSC7)->C7_NUM
		(cAliasSC1)->C1_ITEMPED := (cAliasSC7)->C7_ITEM
		
		//Atualização da legenda da solicitacao
		If SuperGetMV("MV_MKPLACE",.F.,.F.)
			(cAliasSC1)->C1_ACCPROC := ""
		Endif		
		//Se o fornecedor estiver vazio, grava o fornecedor do pedido, caso contrário, preserva o da solicitacao
		If Empty((cAliasSC1)->C1_FORNECE)
			(cAliasSC1)->C1_FORNECE := (cAliasSC7)->C7_FORNECE
			(cAliasSC1)->C1_LOJA    := (cAliasSC7)->C7_LOJA
		EndIf
		
		(cAliasSC1)->C1_COTACAO := COMXCOT((cAliasSC7)->C7_NUMSC,(cAliasSC7)->C7_ITEMSC)
		
		If !Empty((cAliasSC7)->C7_MEDICAO)
			nQtdEmSc := ((cAliasSC1)->C1_QUANT / CNB->CNB_QUANT) * (cAliasSC7)->C7_QUANT 
			nQtdEmSc2:= (nQtdEmSc / (cAliasSC1)->C1_QUANT) * (cAliasSC1)->C1_QTSEGUM 
		ElseIf ( Empty((cAliasSC7)->C7_NUMCOT) .Or. (cAliasSC7)->C7_QTDSOL<>0 )
			nQtdEmSc := (cAliasSC7)->C7_QTDSOL
			nQtdEmSc2:= (cAliasSC1)->C1_QTSEGUM*(cAliasSC7)->C7_QTDSOL/(cAliasSC1)->C1_QUANT
		Else
			nQtdEmSc := (cAliasSC1)->C1_QUANT
			nQtdEmSc2:= (cAliasSC1)->C1_QTSEGUM
		EndIf
		
		RecLock("SC7",.F.)
		If (cAliasSC1)->C1_QUJE+nQtdEmSc > (cAliasSC1)->C1_QUANT
			nQtdEmSc  := (cAliasSC1)->C1_QUANT - (cAliasSC1)->C1_QUJE
			nQtdEmSc2 := (cAliasSC1)->C1_QTSEGUM*(((cAliasSC1)->C1_QUANT - (cAliasSC1)->C1_QUJE)/(cAliasSC1)->C1_QUANT)
			
			If !lItAlguGCP
				SC7->C7_QTDSOL := nQtdEmSc
			EndIf			
		Endif
		
		If (Empty(SC7->C7_COMPRA))
			SC7->C7_COMPRA := (cAliasSC1)->C1_CODCOMP
		EndIf
		SC7->(Msunlock())		
		
		(cAliasSC1)->C1_QUJE    += nQtdEmSC
		(cAliasSC1)->C1_QUJE2   += nQtdEmSC2
		
		(cAliasSC1)->(MsUnLock())
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza as tabelas auxiliares                                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lAtuSB2
			dbSelectArea("SB2")
			dbSetOrder(1)
			If ( !MsSeek(cEntrega+(cAliasSC1)->C1_PRODUTO+(cAliasSC1)->C1_LOCAL) )
				CriaSB2((cAliasSC1)->C1_PRODUTO,(cAliasSC1)->C1_LOCAL,cEntrega)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se deve atualizar o Campo B2_SALPEDI            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
			If lSb1TES
				If (cAliasSC7)->C7_ESTOQUE=="S" .Or. Empty((cAliasSC7)->C7_ESTOQUE)
					GravaB2Pre("-",nQtdEmSC,(cAliasSC1)->C1_TPOP,nQtdEmSC2)
				EndIf	
			Else 
				GravaB2Pre("-",nQtdEmSC,(cAliasSC1)->C1_TPOP,nQtdEmSC2)
			EndIf
		EndIf
		
		//-- Se encerrou SC e for compra centralizada, atualiza status da SC origem
		If (cAliasSC1)->(C1_QUANT - C1_QUJE) <= 0 .And. !Empty((cAliasSC1)->C1_SCORI)
			SC1->(dbSetOrder(2))
			If SC1->(dbSeek((cAliasSC1)->(C1_FISCORI+C1_PRODUTO+C1_SCORI+C1_ITSCORI)))
				RecLock("SC1",.F.)
				SC1->C1_RESIDUO := ""
				SC1->(MsUnLock())
			EndIf
			SC1->(RestArea(aAreaSC1))
		EndIf
	EndIf

	If ( !lAcumulados )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LancaPCO("SC1","000052","05","MATA121")
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cancelamento de um pedido de compra para a solicitacao de compra        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 7
	If !lAcumulados
		RecLock(cAliasSC1,.F.)
		If !Empty((cAliasSC7)->C7_MEDICAO)
			nQtdEmSc := ((cAliasSC1)->C1_QUANT / CNB->CNB_QUANT) * (cAliasSC7)->C7_QUANT 
			nQtdEmSc2:= (nQtdEmSc / (cAliasSC1)->C1_QUANT) * (cAliasSC1)->C1_QTSEGUM 
		ElseIf ( Empty((cAliasSC7)->C7_NUMCOT) )
			nQtdEmSc := (cAliasSC7)->C7_QTDSOL
			nQtdEmSC2:= (cAliasSC1)->C1_QTSEGUM*(cAliasSC7)->C7_QTDSOL/(cAliasSC1)->C1_QUANT
		Else
			nQtdEmSc := Min((cAliasSC1)->C1_QUJE,(cAliasSC7)->C7_QTDSOL)
			nQtdEmSC2:= Min((cAliasSC1)->C1_QUJE2,(cAliasSC1)->C1_QTSEGUM*(cAliasSC7)->C7_QTDSOL/(cAliasSC1)->C1_QUANT)
		EndIf
		If EMPTY((cAliasSC7)->C7_NUMCOT) // ANALISANDO SE O PEDIDO FOI GERADO POR COTAÇÃO
			(cAliasSC1)->C1_QUJE    -= nQtdEmSc
			(cAliasSC1)->C1_QUJE2   -= nQtdEmSc2
		EndIf
		If (cAliasSC1)->C1_QUJE == 0
			If !lRestCot .And. Empty((cAliasSC7)->C7_MEDICAO)
				If (cAliasSC1)->C1_IMPORT == "S" .And. (cAliasSC7)->C7_ORIGEM == "EICPO400"
					If (cAliasSC1)->C1_COTACAO<>"IMPORX"
						(cAliasSC1)->C1_COTACAO := "IMPORT"
					EndIf
				Else
					(cAliasSC1)->C1_COTACAO :=	If( (cAliasSC7)->C7_TIPO == 3 , "IMPORT" ,"" )
				EndIf
			EndIf
		Endif
		If EMPTY((cAliasSC7)->C7_NUMCOT) // ANALISANDO SE O PEDIDO FOI GERADO POR COTAÇÃO
			If (cAliasSC1)->C1_COTACAO == "XXXXXX" .And. (cAliasSC1)->C1_NUM <> SC8->C8_NUMSC
				(cAliasSC1)->C1_COTACAO := "" 
			EndIf
			If (AllTrim(FunName()) $ "MATA097" .OR. IsIncallStack("a120grava")) .And. (cAliasSC1)->C1_PEDIDO == (cAliasSC7)->C7_NUM .AND. ;
				((ValType(Altera) == "L" .And. !Altera) .OR. (cAliasSC1)->C1_QUJE == 0 .AND. EMPTY((cAliasSC1)->C1_COTACAO))
	
				(cAliasSC1)->C1_PEDIDO  := ""
				(cAliasSC1)->C1_ITEMPED := ""
				(cAliasSC1)->C1_FORNECE := ""
				(cAliasSC1)->C1_LOJA    := "" 	
			EndIf
		EndIf
		(cAliasSC1)->(MsUnLock())

		//Caio.Santos - 11/01/13 - Req.72
		If lPrjCni
			If !Empty((cAliasSC7)->C7_NUMCOT) //Proveniente de cotação
				RSTSCLOG("PED",4,/*cUser*/,(cAliasSC7)->(C7_NUM+C7_ITEM))
			EndIf
		EndIf
		
		If ( !Empty((cAliasSC7)->C7_NUMCOT) )
			RecLock(cAliasSC7,.F.)
			(cAliasSC7)->C7_QTDSOL -= nQtdEmSC
			(cAliasSC7)->(MsUnLock())	
		EndIf	
		
		//-- Se reabriu SC e for compra centralizada, atualiza status da SC origem
		If (cAliasSC1)->(C1_QUANT - C1_QUJE) > 0 .And. !Empty((cAliasSC1)->C1_SCORI)
			SC1->(dbSetOrder(2))
			If SC1->(dbSeek((cAliasSC1)->(C1_FISCORI+C1_PRODUTO+C1_SCORI+C1_ITSCORI)))
				RecLock("SC1",.F.)
				SC1->C1_RESIDUO := "S"
				SC1->(MsUnLock())
			EndIf
			SC1->(RestArea(aAreaSC1))
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza as tabelas auxiliares                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(cEntrega+(cAliasSC1)->C1_PRODUTO+(cAliasSC1)->C1_LOCAL) )
		CriaSB2((cAliasSC1)->C1_PRODUTO,(cAliasSC1)->C1_LOCAL,cEntrega)
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se deve atualizar o Campo B2_SALPEDI            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
	If lSb1TES
		If (cAliasSC7)->C7_ESTOQUE=="S" .Or. Empty((cAliasSC7)->C7_ESTOQUE)     
			GravaB2Pre("+",nQtdEmSc,(cAliasSC1)->C1_TPOP,nQtdEmSc2)
		EndIf
	Else
		GravaB2Pre("+",nQtdEmSc,(cAliasSC1)->C1_TPOP,nQtdEmSc2)
	EndIf						
	
	If ( !lAcumulados )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LancaPCO("SC1","000052","06","MATA121")
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Aprovaçao/Rejeicao de uma solicitacao de compra                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 8
	If ( !lAcumulados ) .And. Alltrim(SC1->C1_APROV) == "L"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LancaPCO("SC1","000051","02","MATA110")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Envia a Solicitacao de Compra para o PORTAL    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lIntegDef .And. SuperGetMV("MV_MKPLACE",.F.,.F.)
			SB5->(DbSetOrder(1))
			If SB5->(DbSeek( xFilial("SB5") + (cAliasSC1)->C1_PRODUTO ) )
				If SB5->B5_ENVMKT == "1"
					Inclui:=.T.             
					SetRotInteg('MATA110' )
					FwIntegDef( 'MATA110' )
				EndIf
			EndIf
		EndIf
				
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se deve atualizar o Campo B2_SALPEDI            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lSCSldBl .And. cAprovBkp $ "B*R"
			dbSelectArea("SB2")
			dbSetOrder(1)
			If !msSeek(cEntrega+(cAliasSC1)->C1_PRODUTO+(cAliasSC1)->C1_LOCAL) 
				CriaSB2((cAliasSC1)->C1_PRODUTO,(cAliasSC1)->C1_LOCAL,cEntrega)
			EndIf
			If (cAliasSC1)->(FieldPos("C1_ESTOQUE")) > 0 .And. lSb1TES
				If (cAliasSC1)->C1_ESTOQUE=="S" .Or.  Empty((cAliasSC1)->C1_ESTOQUE)
					GravaB2Pre("+",(cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE,(cAliasSC1)->C1_TPOP,(cAliasSC1)->C1_QTSEGUM-(cAliasSC1)->C1_QUJE2)
				EndIf
			Else 
				GravaB2Pre("+",(cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE,(cAliasSC1)->C1_TPOP,(cAliasSC1)->C1_QTSEGUM-(cAliasSC1)->C1_QUJE2)
			EndIf
		EndIf
		
	Elseif ( !lAcumulados ) .and. Alltrim(SC1->C1_APROV) == "R"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LancaPCO("SC1","000051","02","MATA110",.T.)
		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza as tabelas auxiliares                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(cEntrega+(cAliasSC1)->C1_PRODUTO+(cAliasSC1)->C1_LOCAL) )
		CriaSB2((cAliasSC1)->C1_PRODUTO,(cAliasSC1)->C1_LOCAL,cEntrega)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se deve atualizar o Campo B2_SALPEDI            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
	If lSCSldBl .And. cAprovBkp $ "L* "
		If (cAliasSC1)->(FieldPos("C1_ESTOQUE")) > 0 .And. lSb1TES
		   	If (cAliasSC1)->C1_ESTOQUE=="S" .Or.  Empty((cAliasSC1)->C1_ESTOQUE)  
				GravaB2Pre("-",(cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE,(cAliasSC1)->C1_TPOP,(cAliasSC1)->C1_QTSEGUM-(cAliasSC1)->C1_QUJE2)
			EndIF
		Else 
			GravaB2Pre("-",(cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE,(cAliasSC1)->C1_TPOP,(cAliasSC1)->C1_QTSEGUM-(cAliasSC1)->C1_QUJE2)
		EndIf
	EndIf
		
		
	EndIf	
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cancelamento de uma solicitacao de compra                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 9

	If ! lAcumulados
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LancaPCO("SC1","000051","02","MATA110",.T.)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza as tabelas auxiliares                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(cEntrega+(cAliasSC1)->C1_PRODUTO+(cAliasSC1)->C1_LOCAL) )
		CriaSB2((cAliasSC1)->C1_PRODUTO,(cAliasSC1)->C1_LOCAL,cEntrega)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se deve atualizar o Campo B2_SALPEDI            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
	If lSCSldBl .And. cAprovBkp $ "L* "
		If (cAliasSC1)->(FieldPos("C1_ESTOQUE")) > 0 .And. lSb1TES
		   	If (cAliasSC1)->C1_ESTOQUE=="S" .Or.  Empty((cAliasSC1)->C1_ESTOQUE)  
				GravaB2Pre("-",(cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE,(cAliasSC1)->C1_TPOP,(cAliasSC1)->C1_QTSEGUM-(cAliasSC1)->C1_QUJE2)
			EndIF
		Else 
			GravaB2Pre("-",(cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE,(cAliasSC1)->C1_TPOP,(cAliasSC1)->C1_QTSEGUM-(cAliasSC1)->C1_QUJE2)
		EndIf
	EndIf
EndCase
RestArea(aAreaSC8)
RestArea(aArea)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaCanDelSC³ Autor ³ Eduardo Riera         ³ Data ³28.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se um item da solicitacao de compra pode ser exclui-³±±
±±³          ³do                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := MaCanDelSC(ExpC1,ExpN1,ExpL2,ExpC2)				   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela da solicitacao de compra              ³±±
±±³          ³ExpN1: Codigo do evento                                      ³±±
±±³          ³       [1] Exclusao manual de solicitacao de compra          ³±±
±±³          ³       [2] Exclusao de solicitacao de compra prevista        ³±±
±±³          ³ExpL2: Indica se o help deve ser disparado                   ³±±
±±³          ³ExpC2: Codigo do help que foi gerado se o mesmo nao foi dispa³±±
±±³          ³       rado                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. - Se a solicitacao pode ser excluida              ³±±
±±³          ³       .F. - Se a solicitacao NAO pode ser excluida          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo verificar se a solicitacao de  ³±±
±±³          ³compra pode ser excluida sem maiores problemas para a integri³±±
±±³          ³dade do sistema                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaCanDelSC(cAliasSC1,nEvento,lHelp,cHelp)
Local aAreaSC1 := SC1->(GetArea())
Local lRetorno := .T.
Local lVldLoja := AllTrim(Str(SuperGetMv("MV_LJGERSC",,1))) $ "2|3"
Local cCodUser := RetCodUsr()

DEFAULT lHelp  := .T.
DEFAULT cHelp  := ""
DEFAULT nEvento:= 1

Do Case
Case SubStr((cAliasSC1)->C1_TX,1,1)=="R" .And. SubStr((cAliasSC1)->C1_TX,2,1)<>" "
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"PORTRANS")
	Else
		cHelp := "PORTRANS"
	EndIf
Case (cAliasSC1)->C1_COMPRAC # '1' .And. ((cAliasSC1)->C1_QUJE >= (cAliasSC1)->C1_QUANT .Or. (cAliasSC1)->C1_QUJE > 0)
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A110ALT")
	Else
		cHelp := "A110ALT"
	EndIf
Case (!Empty((cAliasSC1)->C1_COTACAO) .And. !SubStr((cAliasSC1)->C1_COTACAO,1,6)$"IMPORT#XXXXXX") .And. !IsInCallStack("EICSI400") //LGS-25/09/2015
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A11006")
	Else
		cHelp := "A11006"
	EndIf
Case nEvento <> 2 .And. ((cAliasSC1)->C1_TPOP == "P" .And. !Empty((cAliasSC1)->C1_OP))
	lRetorno :=.F.
	If ( lHelp )
		Help("  ",1,"NOPPREVIST")
	Else
		cHelp := "NOPPREVIST"
	EndIf
Case (cAliasSC1)->C1_FLAGGCT == "1"
	lRetorno := .F.
	If ( lHelp )
		Aviso("SIGAGCT",STR0105,{STR0118}) //-- Esta solicitação está sendo atendida por contrato e não poderá ser excluída. ##"Ok"
	Else
		cHelp := "SIGAGCT"
	EndIf
Case (cAliasSC1)->C1_TIPO == 2 .And. !IsInCallStack("MATA113")
	lRetorno := .F.
	If ( lHelp )
		Help(" ",1,"A113TIPO")
	Else
		cHelp := "A113TIPO"
	EndIf
Case lVldLoja .And. !Empty((cAliasSC1)->C1_ORCAM)
	lRetorno := .F.
	If ( lHelp )
		Aviso("SIGALOJA",STR0106,{STR0118}) //-- Solicitação de compra gerada pelo módulo SIGALOJA não pode ser alterada, excluida ou cancelada por esta rotina. ##"Ok"
	Else
		cHelp := "SIGALOJA"
	EndIf
Case !Empty((cAliasSC1)->C1_NUM_SI) .And. !IsInCallStack("EICSI400") //LGS-25/09/2015
	If ( lHelp )	
		Help(" ",1,"ITEMIMPORT")
	Else
		cHelp := "ITEMIMPORT"
	EndIf
EndCase

If lRetorno .And. SuperGetMv("MV_RESTSOL")=="S"
	SB1->(dbSetOrder(1))
	If SB1->(MsSeek(xFilial("SB1")+(cAliasSC1)->C1_PRODUTO)) .And. SB1->B1_SOLICIT == "S".And.;
			!A110Restr((cAliasSC1)->C1_PRODUTO,UsrRetGrp(,cCodUser),cCodUser,lHelp)
		lRetorno := .F.
	EndIf
EndIf

If lRetorno .And. (cAliasSC1)->C1_COMPRAC == '1'
	SC1->(dbSetOrder(11))
	If SC1->(dbSeek((cAliasSC1)->(C1_FILIAL+C1_NUM+C1_ITEM+C1_PRODUTO)))
		lRetorno := MACanDelSC("SC1",nEvento,lHelp,@cHelp)
	EndIf
EndIf

SC1->(RestArea(aAreaSC1))
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaCanAltSC³ Autor ³ Eduardo Riera         ³ Data ³28.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se um item da solicitacao de compra pode ser altera-³±±
±±³          ³do                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := MaCanAltSC(ExpC1,ExpN1,ExpL2,ExpC2)				   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela da solicitacao de compra              ³±±
±±³          ³ExpN1: Codigo do evento                                      ³±±
±±³          ³       [1] Alteracao manual de solicitacao de compra         ³±±
±±³          ³       [2] Alteracao de solicitacao de compra prevista       ³±±
±±³          ³ExpL2: Indica se o help deve ser disparado                   ³±±
±±³          ³ExpC2: Codigo do help que foi gerado se o mesmo nao foi dispa³±±
±±³          ³       rado                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. - Se a solicitacao pode ser alterada              ³±±
±±³          ³       .F. - Se a solicitacao NAO pode ser alterada          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo verificar se a solicitacao de  ³±±
±±³          ³compra pode ser alterada sem maiores problemas para a integri³±±
±±³          ³dade do sistema                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaCanAltSC(cAliasSC1,nEvento,lHelp,cHelp)
Local lVldLoja  := AllTrim(Str(SuperGetMv("MV_LJGERSC",,1))) $ "2|3"
Local lAltSolic := IIF(GetNewPar("MV_ALTSOLI","S")=="S",.T.,.F.)
Local cCodUser := RetCodUsr()
Local lRetorno := .T.
DEFAULT lHelp  := .T.
DEFAULT cHelp  := ""
DEFAULT nEvento:= 1

Do Case
Case SubStr((cAliasSC1)->C1_TX,1,1)=="R" .And. SubStr((cAliasSC1)->C1_TX,2,1)<>" "
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"PORTRANS")
	Else
		cHelp := "PORTRANS"
	EndIf
Case (cAliasSC1)->C1_QUJE >= (cAliasSC1)->C1_QUANT
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A110ALT")
	Else
		cHelp := "A110ALT"
	EndIf
Case (cAliasSC1)->C1_QUJE > 0 .And. !lAltSolic // Se .F. nao permite que as SC parcialmente entregue sejam alteradas MV_ALTSOLI = N   
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A110ALT")
	Else
		cHelp := "A110ALT"             
	EndIf
Case (!Empty((cAliasSC1)->C1_COTACAO) .And. !SubStr((cAliasSC1)->C1_COTACAO,1,6)$"IMPORT#XXXXXX") .And. !IsInCallStack("EICSI400") //LGS-25/09/2015
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A11006")
	Else
		cHelp := "A11006"
	EndIf
Case nEvento <> 2 .And. ((cAliasSC1)->C1_TPOP == "P" .And. !Empty((cAliasSC1)->C1_OP))
	lRetorno :=.F.
	If ( lHelp )
		Help("  ",1,"NOPPREVIST")
	Else
		cHelp := "NOPPREVIST"
	EndIf
Case (cAliasSC1)->C1_FLAGGCT == "1"
	lRetorno := .F.
	If ( lHelp )
		Aviso("SIGAGCT",STR0105,{STR0118}) //-- Esta solicitação está sendo atendida por contrato e não poderá ser excluída.##"Ok"
	Else
		cHelp := "SIGAGCT"
	EndIf
Case (cAliasSC1)->C1_TIPO == 2 .And. !IsInCallStack("MATA113") 
	lRetorno := .F.
	If ( lHelp )
		Help(" ",1,"A113TIPO")
	Else
		cHelp := "A113TIPO"
	EndIf
Case lVldLoja .And. !Empty((cAliasSC1)->C1_ORCAM)
	lRetorno := .F.
	If ( lHelp )
		Aviso("SIGALOJA",STR0106,{STR0118}) //-- Solicitação de compra gerada pelo módulo SIGALOJA não pode ser alterada, excluida ou cancelada por esta rotina. ##"Ok"
	Else
		cHelp := "SIGALOJA"
	EndIf
Case !Empty((cAliasSC1)->C1_SCORI)
	lRetorno := .F.
	If ( lHelp )
		Aviso("SIGACOM",STR0115,{STR0118}) //-- Esta solicitação não poderá ser alterada pois atende a uma solicitação de outra filial. ## "Ok"
	Else
		cHelp := "COMCEN"
	EndIf
Case !Empty((cAliasSC1)->C1_NUM_SI) .And. !IsInCallStack("EICSI400") //LGS-25/09/2015
	If ( lHelp )	
		Help(" ",1,"ITEMIMPORT") 
	Else
		cHelp := "ITEMIMPORT"
	EndIf
EndCase

If lRetorno .And. SuperGetMv("MV_RESTSOL")=="S"
	dbSelectArea("SB1")
	dbSetOrder(1)
	If ( MsSeek(xFilial("SB1")+SC1->C1_PRODUTO).And.SB1->B1_SOLICIT =="S".And.;
			!A110Restr(SC1->C1_PRODUTO,UsrRetGrp(,cCodUser),cCodUser,lHelp))
		lRetorno := .F.
		cHelp := "A110RESTR"
	EndIf
EndIf

If lRetorno .And. Existblock("MT110ALT")
	lRetorno := ExecBlock("MT110ALT",.F.,.F.,{cAliasSC1,nEvento})
	If ValType(lRetorno) <> "L"
		lRetorno := .T.
	Endif	
    If lRetorno == .F.
    	cHelp := "A110RESTR "             
    EndIf    
EndIf

Return(lRetorno)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaAvalCOT ³ Autor ³ Eduardo Riera         ³ Data ³27.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de avaliacao dos eventos do processo de cotacao       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaAvalCOT(ExpC1,ExpN1,ExpA1,ExpA2,ExpA3,ExpL1,ExpL2,ExpB1)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1:*Alias da tabela de cotacao                            ³±±
±±³          ³ExpN1:*Codigo do Evento                                      ³±±
±±³          ³       [01] Geracao de uma cotacao                           ³±±
±±³          ³       [02] Atualizacao dos precos de uma cotacao            ³±±
±±³          ³       [03] Cancelamento de uma cotacao                      ³±±
±±³          ³       [04] Analise de uma cotacao                           ³±±
±±³          ³ExpA1: Array com as cotacoes(SC8)                            ³±±
±±³          ³       [x] Array com os produtos/identificadores da cotacao  ³±±
±±³          ³    [x][y] Array com os dados de uma cotacao                 ³±±
±±³          ³ [x][y][1] Nome do campo                                     ³±±
±±³          ³       [2] Conteudo do campotaacao                           ³±±
±±³          ³ExpA2: Array no formato aHeader das cotacoes vencedoras      ³±±
±±³          ³ExpA3: Array com os produtos/identificadores das cotacoes    ³±±
±±³          ³       vencedoras(SCE)                                       ³±±
±±³          ³       [x] Array no formato acols das cotacoes vencedoras    ³±±
±±³          ³ExpL1: .T. - Mantem a data da necessidade da cotacao(D)      ³±±
±±³          ³       .F. - Ajusta a data da necessidade para a Entrega     ³±±
±±³          ³ExpL2: .T. - Indica que eh o ultimo item da cotacao a ser Av.³±±
±±³          ³ExpB1: Codeblock de contabilizacao  On-Line.                 ³±±
±±³          ³ExpC2: Codigo do comprador responsavel vindo do ACC		   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. 	                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo atualizar os eventos vinculados³±±
±±³          ³a uma cotacao, como:                                         ³±±
±±³          ³A) Atualizacao das tabelas complementares.                   ³±±
±±³          ³B) Atualizacao das informacoes complementares a cotacao      ³±±
±±³          ³C) Executar o B2B                                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalCOT(cAliasSC8,nEvento,aSC8,aHeadSCE,aCOLSSCE,lNecessid,lLast,bCtbOnLine,cCompACC)

Local aArea		:= GetArea()
Local aAreaSC8  := SC8->(GetArea())
Local aRegSC1   := {}
Local aVencedor := {}
Local aPaginas  := {}
Local aRefImp   := {}
Local aSCMail	:= {}
Local aNroItGrd := {}
Local aPedidos  := {}
Local aCTBEnt	:= CTBEntArr()
Local aValItPc  := {}
Local cNumCot   := ""
Local cProduto  := ""
Local cIdent    := ""
Local cQuery    := ""
Local cCursor   := ""
Local cNumPed   := ""
Local cItemPC   := ""
Local cUsers	:= ""
Local cCndCot	:= ""
Local cNumContr := ""
Local cItemContr:= ""
Local cFluxo	:= Criavar("C7_FLUXO")
Local lQuery    := .F.
Local lCotSC    := SuperGetMV("MV_COTSC")=="S"
Local lTrava	:= .T.
Local nA		:= 0
Local nB		:= 0
Local nX        := 0
Local nY        := 0
Local nZ		:= 0
Local nP        := 0
Local nS        := 0
Local nH        := 0
Local lOkS      := .T.
Local nPQtdSCE  := 0
Local nPMotSCE  := 0
Local nPRegSC8  := 0
Local nPForSC8  := 0
Local nPLojSC8  := 0
Local nPCndSC8  := 0
Local nPPrdSC8  := 0
Local nPFilSC8  := 0
Local nScan     := 0
Local nSaveSX8  := GetSX8Len()
Local nSaveSX82 := 0
Local cGrupo	:= SuperGetMv("MV_PCAPROV")
Local lLiberou  := .F.
Local lPEGerPC  := ExistBlock("MT160GRPC")
Local aRatFin	:= {}
Local lPrjCni   := ValidaCNI()
Local cGrComPad := Space(Len(SC7->C7_GRUPCOM))
Local cCotFiAP  := "C"
Local aBkpFilAdm:= Array(5)
Local aRetPE	:= {}
Local lCotSI	:= ExistBlock("MT130SI")
Local aRetPO	:= {}
Local aFilSCH	:= {}
Local aCpoImp	:= {}

Local lCotParc	:= SuperGetMv('MV_COTPARC',, .T.) // Habilita a analise da cotacao parcial.

DEFAULT aSC8      := {}
DEFAULT aHeadSCE  := {}
DEFAULT aCOLSSCE  := {}
DEFAULT lNecessid := .T.
DEFAULT lLast     := .F.
DEFAULT bCtbOnLine:= {|| .T.}
DEFAULT cCompACC  := ""

//Variaveis para controle de Alçadas - 06/01/2015.
If Type("aHeadSC7") == "U"
	aHeadSC7 := {}
EndIf
If Type("aColsSC7") == "U"
	aColsSC7 := {}
EndIf
If Type("aHeadSCH") == "U"
	aHeadSCH := {}
EndIf
If Type("aColsSCH") == "U"
	aColsSCH := {}
EndIf
If Type("lBloqIP") == "U"
	lBloqIP := .F.
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica o grupo de aprovacao do Comprador.                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SY1")
dbSetOrder(3)
If dbSeek(xFilial("SY1")+If(Empty(cCompACC),RetCodUsr(),cCompACC))
	cGrupo	:= If(!Empty(Y1_GRAPROV),SY1->Y1_GRAPROV,cGrupo)
EndIf
If dbSeek(xFilial("SY1")+RetCodUsr())
	cGrComPad	:= If(!Empty(Y1_GRUPCOM),SY1->Y1_GRUPCOM,Space(Len(SC7->C7_GRUPCOM)))
EndIf

If cPaisLoc == "ARG" .And. FindFunction("CPOIMPARG") .And. ( Type("aCpoImp") == "U" .Or. Len(aCpoImp) == 0 )
	aCpoImp := CPOIMPARG("SC7","SC8")
EndIf

Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de uma cotacao                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 1
	cNumCot   := (cAliasSC8)->C8_NUM
	cProduto  := (cAliasSC8)->C8_PRODUTO
	cIdent    := (cAliasSC8)->C8_IDENT
	If ( lLast )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³M-Message - Verifica o Evento 003 - Solicitacao com cotacao pendente.   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If MExistMail("003")
			cCursor := "MAAVALCOT"
			cQuery := "SELECT C1_NUM,C1_ITEM,C1_DESCRI,C1_USER,C1_SOLICIT,C1_OP "
			cQuery += "FROM "+RetSqlName("SC1")+" SC1 "
			cQuery += "WHERE SC1.C1_FILIAL='"+xFilial("SC1")+"' AND "
			cQuery += "SC1.C1_COTACAO='"+cNumCot+"' AND "
			cQuery += "SC1.C1_PRODUTO='"+cProduto+"' AND "
			cQuery += "SC1.C1_IDENT='"+cIdent+"' AND "
			cQuery += "SC1.D_E_L_E_T_<>'*'"
			cQuery := ChangeQuery(cQuery)
			SC1->(dbCommit())					
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor,.T.,.T.)
			While ( !Eof() )
				aadd(aSCMail,C1_NUM+"/"+C1_ITEM+" "+C1_SOLICIT+" "+C1_DESCRI)
				cUsers += C1_USER+"#"							
				dbSelectArea(cCursor)
				dbSkip()					
			EndDo
			dbSelectArea(cCurSor)
			dbCloseArea()
			dbSelectArea("SC1")					
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Envia e-mail do Evento 003                                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			MEnviaMail("003",{cNumCot,"","","L",cUsers})
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualizacao dos precos de uma cotacao                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 2
	cNumCot   := (cAliasSC8)->C8_NUM
	cCndCot   := (cAliasSC8)->C8_COND
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica a existencia do Evento 004 - Cotacao com analise pendente.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lLast .And. !Empty(cCndCot)
		MEnviaMail("004",{cNumCot})
	EndIf		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cancelamento da cotacao                                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 3
	cNumCot   := (cAliasSC8)->C8_NUM
	cProduto  := (cAliasSC8)->C8_PRODUTO
	cIdent    := (cAliasSC8)->C8_IDENT
	
	If lPrjCni
		RSTSCLOG("ATL",2,/*cUser*/) //Se ainda pertence a cotação, apenas exclui log da atualização do fornecedor excluído
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Somente estornar a solicitacao de compra quando esta nao possuir cotacao³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea(cAliasSC8)
	dbSetOrder(4)		
	If ( !MsSeek(xFilial("SC8")+cNumCot+cIdent+cProduto) )
		cCursor := "MAAVALCOT"
		cQuery := "SELECT R_E_C_N_O_ SC1RECNO "
		cQuery += "FROM "+RetSqlName("SC1")+" SC1 "
		cQuery += "WHERE SC1.C1_FILIAL='"+xFilial("SC1")+"' AND "
		cQuery += "SC1.C1_COTACAO='"+cNumCot+"' AND "
		cQuery += "SC1.C1_PRODUTO='"+cProduto+"' AND "
		cQuery += "SC1.C1_IDENT='"+cIdent+"' AND "
		cQuery += "SC1.D_E_L_E_T_<>'*'"
		cQuery := ChangeQuery(cQuery)
		SC1->(dbCommit())					
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor,.T.,.T.)
		While ( !Eof() )
			aadd(aRegSC1,SC1RECNO)
			dbSelectArea(cCursor)
			dbSkip()					
		EndDo
		dbSelectArea(cCurSor)
		dbCloseArea()
		dbSelectArea("SC1")					

		For nX := 1 To Len(aRegSC1)
			dbSelectArea("SC1")
			MsGoto(aRegSC1[nX])
			RecLock("SC1",.F.)
			If ( lCotSC .And. SC1->C1_QUJE < SC1->C1_QUANT )
				SC1->C1_COTACAO := ""
			Else
				SC1->C1_COTACAO := Repl("X",Len(SC1->C1_COTACAO))
			EndIf
			
			//Caio.Santos - 11/01/13 - Req.72
			If lPrjCni
				RSTSCLOG("COT",2,/*cUser*/)
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Ponto de Entrada para tratamento dos registros da solicitacao compras.  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistBlock("MT150EXC")
				ExecBlock("MT150EXC",.f.,.f.)
			Endif
		Next nX
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Analise da cotacao                                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 4
	nPQtdSCE  := aScan(aHeadSCE,{|x| Trim(x[2])=="CE_QUANT"})
	nPMotSCE  := aScan(aHeadSCE,{|x| Trim(x[2])=="CE_MOTIVO"})
	nPEntSCE  := aScan(aHeadSCE,{|x| Trim(x[2])=="CE_ENTREGA"})
	
	// Controle para identificar qual posicao do aSC8 vem preenchida.
	For nS := 1 To Len(aSC8)
		
		For nH := 1 To Len(aSC8[nS])
			
			If Len(aSC8[nS][nH]) > 1
				
				lOkS := .F.
				
				Exit
				
			EndIf
			
		Next nH
		
		If !lOkS
			
			Exit
			
		EndIf
		
	Next nS
	
	nPRegSC8  := aScan(aSC8[nS][nH],{|x| Trim(x[1])=="SC8RECNO"})
	nPForSC8  := aScan(aSC8[nS][nH],{|x| Trim(x[1])=="C8_FORNECE"})
	nPLojSC8  := aScan(aSC8[nS][nH],{|x| Trim(x[1])=="C8_LOJA"})
	nPCndSC8  := aScan(aSC8[nS][nH],{|x| Trim(x[1])=="C8_COND"})
	nPPrdSC8  := aScan(aSC8[nS][nH],{|x| Trim(x[1])=="C8_PRODUTO"})
	nPFilSC8  := aScan(aSC8[nS][nH],{|x| Trim(x[1])=="C8_FILENT"})
	nPObsSC8  := aScan(aSC8[nS][nH],{|x| Trim(x[1])=="C8_OBS"})
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifico quais fornecedores possuem cotacoes vencedoras                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 To Len(aColsSCE)
		For nY := 1 To Len(aColsSCE[nX])
			dbSelectArea("SC8")
			MsGoto(aSC8[nX][nY][nPRegSC8][2])
			If ( aColsSCE[nX][nY][nPQtdSCE] > 0 )
				If ( RecLock("SC8") )
					nZ := aScan(aVencedor,{|x| x[1]==aSC8[nX][nY][nPForSC8][2].And.;
						x[2]==aSC8[nX][nY][nPLojSC8][2].And.;
						x[3]==aSC8[nX][nY][nPCndSC8][2].And.;
						x[4]==aSC8[nX][nY][nPFilSC8][2]})
					If ( nZ == 0 )
						aadd(aVencedor,{aSC8[nX][nY][nPForSC8][2],;
							aSC8[nX][nY][nPLojSC8][2],;
							aSC8[nX][nY][nPCndSC8][2],;
							aSC8[nX][nY][nPFilSC8][2]})
					EndIf
				EndIf
			EndIf
		Next nY
	Next nX
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica a quais impostos devem ser gravados.                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRefImp := MaFisRelImp('MT100',{"SC7"})
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Efetua a gravacao dos pedidos para cada Vencedor                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nZ := 1 To Len(aVencedor)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Travo todos os registros antes de iniciar a gravacao                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lTrava := .T.
		For nX := 1 To Len(aColsSCE)
			For nY := 1 To Len(aColsSCE[nX])
				If ( aVencedor[nZ][1]==aSC8[nX][nY][nPForSC8][2].And.;
						aVencedor[nZ][2]==aSC8[nX][nY][nPLojSC8][2].And.;
						aVencedor[nZ][3]==aSC8[nX][nY][nPCndSC8][2].And.;
						aVencedor[nZ][4]==aSC8[nX][nY][nPFilSC8][2] )
					
					dbSelectArea("SC8")
					MsGoto(aSC8[nX][nY][nPRegSC8][2])
					
					if lPrjCNI
						if SC8->(!Eof())
							if (!Empty(SC8->C8_XGCT))                                         
								lTrava := .F.
								Exit
							EndIf
						EndIf
					EndIf
					
					If (!RecLock("SC8") )
						lTrava := .F.
						Exit
					EndIf
				EndIf
			Next nY
		Next nX
		
		aBkpFilAdm[1] := cFilAnt
				
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Inicio o processo de gravacao do Pedido de Compra                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( lTrava )
			cCotFiAP  := "C"
			cNumPed   := CriaVar("C7_NUM",.T.)
			While ( GetSX8Len() > nSaveSX8 )
				ConfirmSx8()
			EndDo
			cItemPC   := StrZero(1,Len(SC7->C7_ITEM))
			If ( Empty(cNumPed) )
				cNumPed := GetNumSC7(.F.)
			EndIf
			
			aBkpFilAdm[2] := cNumPed
			aBkpFilAdm[4] := cGrupo
			aBkpFilAdm[5] := cGrComPad
			
			If lPrjCni
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Esvazia vetor rateio financeiro                                         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aRatFin := {}
			EndIf

			For nX := 1 To Len(aColsSCE)
				For nY := 1 To Len(aColsSCE[nX])
					If ( aVencedor[nZ][1]==aSC8[nX][nY][nPForSC8][2].And.;
							aVencedor[nZ][2]==aSC8[nX][nY][nPLojSC8][2].And.;
							aVencedor[nZ][3]==aSC8[nX][nY][nPCndSC8][2].And.;
							aVencedor[nZ][4]==aSC8[nX][nY][nPFilSC8][2].And.;
							aColsSCE[nX][nY][nPQtdSCE]<>0)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Guarda as paginas que houveram vencedores                               ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If ( aScan(aPaginas,nX)==0 )
							aadd(aPaginas,nX)
						EndIf
						dbSelectArea("SB1")
						dbSetOrder(1)
						MsSeek(xFilial("SB1")+aSC8[nX][nY][nPPrdSC8][2])
						dbSelectArea("SC8")
						MsGoto(aSC8[nX][nY][nPRegSC8][2])
						dbSelectArea("SC1")
						dbSetOrder(5)
						MsSeek(xFilial("SC1",aBkpFilAdm[1])+SC8->C8_NUM+SC8->C8_PRODUTO+SC8->C8_IDENT)
						dbSelectArea("SA2")
						dbSetOrder(1)
						MsSeek(xFilial("SA2")+aVencedor[nZ][1]+aVencedor[nZ][2])

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Incluo o item do Pedido de Compra                                       ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						RecLock("SC7",.T.)
						dbSelectArea("SC7")
						For nA := 1 to SC7->(FCount())
							nB := SC8->(FieldPos("C8"+SubStr(SC7->(FieldName(nA)),3)))
							If ( nB <> 0 )
								FieldPut(nA,SC8->(FieldGet(nB)))
							EndIf
						Next nA

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Controla a numeracao do Item no PC quando for Item de Grade vindo do SC8³
						//³Observar que o Numero do Item no PC C7_ITEM sera trocado toda vez que na³
						//³mesma grade o C8_PRECO for diferente, ou seja, somente sera aglutinado  ³
						//³na mesma grade (mesmo C7_ITEM) os itens do Grid que possuirem o mesmo   ³
						//³preco para preservar os valores,calculos de impostos e afins.           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If SC8->C8_GRADE == "S"

							cProdRef := SC8->C8_PRODUTO
							lReferencia := MatGrdPrrf(@cProdRef, .T.)
							
							If (nScan := aScan(aNroItGrd, {|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] == ;
								SC8->C8_ITEM + cProdRef + SC8->C8_NUMPRO + SC8->C8_FORNECE + SC8->C8_LOJA + SC8->C8_NUMSC + SC8->C8_ITEMSC + TransForm(SC8->C8_PRECO,PesqPict("SC8","C8_PRECO")) })) == 0

								Aadd(aNroItGrd, { SC8->C8_ITEM , cProdRef , SC8->C8_NUMPRO , SC8->C8_FORNECE , SC8->C8_LOJA ,SC8->C8_NUMSC ,SC8->C8_ITEMSC ,TransForm(SC8->C8_PRECO,PesqPict("SC8","C8_PRECO")) , cItemPc } )
								nScan := Len(aNroItGrd)
								cItemPc	:= Soma1(cItemPc)

							Endif
						Else
							nScan := Nil
						EndIf
						
						//-- Verifica filial que ira administrar o pedido de compra
						If (cCotFiAP := SuperGetMV("MV_COTFIAP",.F.,"C")) == "E"
							//-- Valida se o produto existe na filial de entrega
							SB1->(dbSetOrder(1))
							cCotFiAP := If(cCotFiAP == "E" .And. SB1->(dbSeek(xFilial("SB1",SC8->C8_FILENT)+SC8->C8_PRODUTO)),"E","C")
							
							//-- Valida se o fornecedor existe na filial de entrega
							SA2->(dbSetOrder(1))
							cCotFiAP := If(cCotFiAP == "E" .And. SA2->(dbSeek(xFilial("SA2",SC8->C8_FILENT)+aVencedor[nZ,1]+aVencedor[nZ,2])),"E","C")
							
							//-- Valida se a condicao de pagamento existe na filial de entrega
							SE4->(dbSetOrder(1))
							cCotFiAP := If(cCotFiAP == "E" .And. SE4->(dbSeek(xFilial("SE4",SC8->C8_FILENT)+aVencedor[nZ,3])),"E","C")
						EndIf
							
						//-- Se administradora do PC for a filial de entrega
						If cCotFiAP == "E" .And. PadR(cFilAnt,Len(AllTrim(SC8->C8_FILENT))) # AllTrim(SC8->C8_FILENT)
							aBkpFilAdm[3] := cItemPC
						
							//-- Troca filial
							SM0->(dbSetOrder(1))
							SM0->(dbSeek(cEmpAnt+AllTrim(SC8->C8_FILENT)))
							cFilAnt := FWCodFil()
							
							//-- Troca numero do pedido
							nSaveSX82 := GetSX8Len()
							cNumPed := CriaVar("C7_NUM",.T.)
							While (GetSX8Len() > nSaveSX82)
								ConfirmSx8()
							End
							cItemPC := StrZero(1,Len(SC7->C7_ITEM))
							If (Empty(cNumPed))
								cNumPed := GetNumSC7(.F.)
							EndIf
							
							//-- Troca grupo de compra e aprovacao
							SY1->(dbSetOrder(3))
							If SY1->(dbSeek(xFilial("SY1")+If(Empty(cCompACC),RetCodUsr(),cCompACC)))
								cGrupo := If(!Empty(SY1->Y1_GRAPROV),SY1->Y1_GRAPROV,SuperGetMv("MV_PCAPROV",.F.,""))
								cGrComPad := If(!Empty(SY1->Y1_GRUPCOM),SY1->Y1_GRUPCOM,CriaVar("C7_GRUPCOM",.F.))
							EndIf
						EndIf
												
						SC7->C7_FILIAL := xFilial("SC7")
						SC7->C7_TIPO   := 1
						SC7->C7_NUM    := cNumPed
						SC7->C7_ITEM   := If(nScan == Nil, cItemPc , aNroItGrd[nScan, 9 ])
						SC7->C7_GRADE  := IIF(Empty(SC8->C8_GRADE),"N",SC8->C8_GRADE)
						SC7->C7_ITEMGRD:= SC8->C8_ITEMGRD
						SC7->C7_FORNECE:= aVencedor[nZ][1]
						SC7->C7_LOJA   := aVencedor[nZ][2]
						SC7->C7_COND   := aVencedor[nZ][3]
						SC7->C7_OP     := SC1->C1_OP
						SC7->C7_LOCAL  := SC1->C1_LOCAL
						SC7->C7_DESCRI := SC1->C1_DESCRI
						SC7->C7_UM     := SC1->C1_UM
						SC7->C7_SEGUM  := SC1->C1_SEGUM
						SC7->C7_QUANT  := aColsSCE[nX][nY][nPQtdSCE]
						SC7->C7_QTDSOL := 0
						SC7->C7_QTSEGUM := IIf(SB1->B1_CONV==0,SC1->C1_QTSEGUM,ConvUm(aSC8[nX][nY][nPPrdSC8][2],aColsSCE[nX][nY][nPQtdSCE],0,2))
						SC7->C7_PRECO   := SC8->C8_PRECO
						SC7->C7_TOTAL   := SC7->C7_QUANT*SC7->C7_PRECO
						SC7->C7_CONTATO := SC8->C8_CONTATO
						SC7->C7_OBS     := SC8->C8_OBS
						SC7->C7_OBSM    := SC8->C8_OBS
						SC7->C7_EMISSAO := dDataBase
						SC7->C7_DATPRF  := IIf(lNecessid,aColsSCE[nX][nY][nPentSCE],dDataBase+SC8->C8_PRAZO)
						SC7->C7_CC      := SC1->C1_CC
						SC7->C7_CLVL    := SC1->C1_CLVL
						SC7->C7_CONTA   := SC1->C1_CONTA
						SC7->C7_ITEMCTA := SC1->C1_ITEMCTA
						SC7->C7_DESC1   := SC8->C8_DESC1
						SC7->C7_DESC2   := SC8->C8_DESC2
						SC7->C7_DESC3   := SC8->C8_DESC3
						SC7->C7_REAJUST := SC8->C8_REAJUST
						SC7->C7_IPI     := SC8->C8_ALIIPI
						SC7->C7_FISCORI := SC8->C8_FILIAL
						SC7->C7_NUMSC   := SC8->C8_NUMSC
						SC7->C7_ITEMSC  := SC8->C8_ITEMSC
						SC7->C7_NUMCOT  := SC8->C8_NUM
						SC7->C7_FILENT  := SC8->C8_FILENT
						SC7->C7_TPFRETE := SC8->C8_TPFRETE
						SC7->C7_VLDESC  := ((SC7->C7_TOTAL*SC8->C8_VLDESC)/SC8->C8_TOTAL)
						SC7->C7_IPIBRUT := "B"
						SC7->C7_VALEMB  := SC8->C8_VALEMB
						SC7->C7_FRETE   := SC8->C8_TOTFRE
						SC7->C7_FLUXO   := cFluxo
						SC7->C7_GRUPCOM := If(Empty(C7_GRUPCOM),cGrComPad,C7_GRUPCOM)
						If cPaisLoc == "ARG" .And. FindFunction("GrvSC7Loc") .And. Len(aCpoImp) > 0
							GrvSC7Loc(aCpoImp,.T.,.F.)
						Endif						
						
						If cPaisLoc == "BRA"
							SC7->C7_ICMSRET := SC8->C8_VALSOL
						EndIf
						
						If AllTrim(SC1->C1_ORIGEM) == "MSGEAI"
							SC7->C7_ORIGEM  := Space(TamSX3("C7_ORIGEM")[1])
						Else
							SC7->C7_ORIGEM  := SC1->C1_ORIGEM						
						EndIf	
						
						If lCotSI
							aRetPO := ExecBlock("MT130SI",.F.,.F.,{2})//parametro 2 indica que o PE esta sendo executado para gerar uma P.O
							If ValType(aRetPO) <> "A"
								lCotSI := .F.
							EndIf
						EndIf
						// Criado ponto de entrada para cotação de produto importado
						// As alterações abaixo vão fazer com que o PC vire uma P.O
						If lCotSI 
							SC7->C7_TIPO   	:= 3
							SC7->C7_FREPPCC := aRetPO[1] // default = CC
							SC7->C7_DT_IMP	:= aRetPO[2] // Data de importação
							SC7->C7_AGENTE	:= aRetPO[3] //Ag embarcador
							SC7->C7_TIPO_EM	:= aRetPO[4] //via de transporte
							SC7->C7_ORIGIMP	:= aRetPO[5] //Origem
							SC7->C7_DEST	:= aRetPO[6] //Destino
							SC7->C7_COMPRA	:= aRetPO[7] //Comprador
							SC7->C7_INCOTER	:= aRetPO[8] //Incorterm
							SC7->C7_IMPORT	:= aRetPO[9] //Importador
							SC7->C7_CONF_PE	:= aRetPO[10]// Data da confirmação do Pedido //default = data base
							SC7->C7_CONTAIN	:= aRetPO[11] // Desova de Container //default = 1
						EndIf
						
						For nA := 1 To Len(aCTBEnt)
							SC7->&("C7_EC"+aCTBEnt[nA]+"CR") := SC1->&("C1_EC"+aCTBEnt[nA]+"CR")
							SC7->&("C7_EC"+aCTBEnt[nA]+"DB") := SC1->&("C1_EC"+aCTBEnt[nA]+"DB")
						Next nA
						
						SC7->C7_RATEIO  := CriaVar('C7_RATEIO',.T.)			
						
						If (SuperGetMv("MV_MKPLACE",.F.,.F.)) .And. !Empty( SC8->C8_ACCNUM )
							SC7->C7_ACCNUM  := aColsSCE[nX][nY][Len(aColsSCE[nX][nY])-1]
							SC7->C7_ACCITEM := aColsSCE[nX][nY][Len(aColsSCE[nX][nY])]
							SC7->C7_USER    := cCompACC
						EndIf  
						
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³PE para atualizacao de campos especificos do SC7      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ						
						If lPEGerPC
							ExecBlock("MT160GRPC",.F.,.F.,{aVencedor,aSC8})
						EndIf
						
						MaFisIni(aVencedor[nZ][1],aVencedor[nZ][2],"F","N","R",aRefImp)						
						
						If cItemPC == StrZero(1,Len(SC7->C7_ITEM)) .And. ExistBlock("MT120APV")
							cGrupo := ExecBlock("MT120APV",.F.,.F.,{aVencedor,aSC8})
						EndIf
						SC7->C7_APROV   := cGrupo
						
						//-- Executa avaliação do tipo de Compra
						SC7->C7_TIPCOM := MRetTipCom(,.T.,"PC")
						
						MaFisIniLoad(1)
						For nA := 1 To Len(aRefImp)
							MaFisLoad(aRefImp[nA][3],FieldGet(FieldPos(aRefImp[nA][2])),1)
						Next nA
						MaFisRecal("",1)
						MaFisEndLoad(1)
						MaFisAlt("IT_ALIQIPI",SC7->C7_IPI,1)
						MaFisAlt("IT_ALIQICM",SC7->C7_PICM,1)
						If cPaisLoc == "BRA"
							MaFisAlt("IT_VALSOL", SC7->C7_ICMSRET,1)							
						EndIf							
						MaFisWrite(1,"SC7",1)
						MaFisWrite(2,"SC7",1,.F.)
						
						// alimenta o vl do IPI quando informado apenas o valor
                		If SC8->C8_ALIIPI == 0 .And. SC8->C8_VALIPI <> 0    
							SC7->C7_VALIPI  := SC8->C8_VALIPI  
						EndIf
						If cPaisLoc == "ARG" .And. FindFunction("GrvSC7Loc") .And. Len(aCpoImp) > 0
							GrvSC7Loc(aCpoImp,.F.,.T.,1)
						Endif
						
						//-- Adiciona pedido gerado no array de controle para chamada
						//-- de funções de atualização
						nP := aScan(aPedidos,{|x| xFilial("SC7",x[1])+x[2] == SC7->(C7_FILIAL+C7_NUM)})
						If  nP == 0
							aAdd(aPedidos,{cFilAnt,SC7->C7_NUM,aRatFin,MaFisRet(1,"IT_TOTAL")})
							// Array aValItPc utilizado para passar o valor do item do pedido considerando impostos para a funcao MaEntCtb
							aAdd(aValItPc,{SC7->C7_NUM,{}})
							aAdd(aValItPc[Len(aValItPc)][2],{SC7->C7_ITEM,MaFisRet(1,"IT_TOTAL")})
						Else
							aPedidos[nP,4] += MaFisRet(1,"IT_TOTAL")
							aAdd(aValItPc[nP][2],{SC7->C7_ITEM,MaFisRet(1,"IT_TOTAL")})
						EndIf

						MaFisEnd()

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Encerro a cotacao vencedora                                             ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						dbSelectArea("SC8")
						MsGoto(aSC8[nX][nY][nPRegSC8][2])
						SC8->C8_NUMPED := cNumPed
						SC8->C8_ITEMPED:= If(nScan == Nil, cItemPc , aNroItGrd[nScan, 9 ])
						SC8->C8_MOTIVO := aColsSCE[nX][nY][nPMotSCE]
						
						If nPObsSC8 > 0
							
							SC8->C8_OBS := aSC8[nX][nY][nPObsSC8][2]
							
						EndIf
						
						SC8->C8_DATPRF := IIf(lNecessid,aColsSCE[nX][nY][nPentSCE],dDataBase+SC8->C8_PRAZO)
						SC8->C8_PRAZO  := SC8->C8_DATPRF - dDataBase
						
						//Caio.Santos - 11/01/13 - Req.72
						If lPrjCni
							RSTSCLOG("PED",3,/*cUser*/,SC7->(C7_NUM+C7_ITEM))
						EndIf						
						
						RecLock("SCE",.T.)
						SCE->CE_FILIAL := xFilial("SCE",SC8->C8_FILIAL)
						SCE->CE_NUMCOT := SC8->C8_NUM
						SCE->CE_ITEMCOT:= SC8->C8_ITEM
						SCE->CE_NUMPRO := SC8->C8_NUMPRO
						SCE->CE_PRODUTO:= SC8->C8_PRODUTO
						SCE->CE_FORNECE:= SC8->C8_FORNECE
						SCE->CE_LOJA   := SC8->C8_LOJA
						SCE->CE_ITEMGRD:= SC8->C8_ITEMGRD
						For nA := 1 To Len(aHeadSCE)
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Nao grava campos virutais e de controle (walkthru)   ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If !(IsHeadRec(Trim(aHeadSCE[nA][2])) .OR. IsHeadAlias(Trim(aHeadSCE[nA][2])) .OR. aHeadSCE[nA][10] == "V")
								IF aCOLSSCE[nX][nY][nA] <> NIL
									FieldPut(FieldPos(aHeadSCE[nA][2]),aCOLSSCE[nX][nY][nA])
								ENDIF
							EndIf
						Next nA
						SCE->CE_MOTIVO := aColsSCE[nX][nY][nPMotSCE]
						SCE->CE_ENTREGA:= IIf(lNecessid,aColsSCE[nX][nY][nPentSCE],dDataBase+SC8->C8_PRAZO)							
						If SC8->C8_QTDCTR > 0
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Gravacao do Contrato de Parceria                     ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If Empty(cNumContr)
								cNumContr := CriaVar("C3_NUM",.T.)
								cItemContr:= Strzero(1,Len(SC3->C3_ITEM))
								While ( GetSX8Len() > nSaveSX8 )
									ConfirmSx8()
								EndDo				
							EndIf
							RecLock("SC3",.T.)
							dbSelectArea("SC3")
							SC3->C3_FILIAL  := xFilial("SC3")
							SC3->C3_NUM     := cNumContr
							SC3->C3_FORNECE := aVencedor[nZ][1]
							SC3->C3_LOJA    := aVencedor[nZ][2]
							SC3->C3_GRADE   := SC8->C8_GRADE
							SC3->C3_ITEMGRD := SC8->C8_ITEMGRD
							SC3->C3_ITEM    := cItemContr
							SC3->C3_PRODUTO := SC8->C8_PRODUTO
							SC3->C3_QUANT   := SC8->C8_QTDCTR
							SC3->C3_PRECO   := SC8->C8_PRECO
							SC3->C3_TOTAL   := SC3->C3_PRECO*SC3->C3_QUANT
							SC3->C3_DATPRI  := dDataBase
							SC3->C3_DATPRF  := IIf(lNecessid,aColsSCE[nX][nY][nPentSCE],dDataBase+SC8->C8_PRAZO)
							SC3->C3_LOCAL   := SC1->C1_LOCAL
							SC3->C3_COND    := aVencedor[nZ][3]
							SC3->C3_CONTATO := SC8->C8_CONTATO
							SC3->C3_FILENT  := SC8->C8_FILENT
							SC3->C3_EMISSAO := dDatabase
							SC3->C3_REAJUST := SC8->C8_REAJUST
							SC3->C3_TPFRETE := SC8->C8_TPFRETE
							SC3->C3_FRETE   := SC8->C8_TOTFRE
							SC3->C3_OBS     := SC8->C8_OBS
							SC3->C3_AVISTA := SC8->C8_AVISTA
							SC3->C3_TAXAFOR := SC8->C8_TAXAFOR
							MsUnLock()
							SB1->(DBSetOrder(1))
							If SB1->(MsSeek(xFilial("SB1")+SC8->C8_PRODUTO))
								RecLock("SB1",.F.)
								Replace SB1->B1_CONTRAT With "S"
								Replace SB1->B1_PROC    With aVencedor[nZ][1]
								Replace SB1->B1_LOJPROC With aVencedor[nZ][2]
								MsUnLock()
							EndIf
							cItemContr  :=  Soma1(cItemContr,Len(SC3->C3_ITEM))
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualizo os acumulados do Pedido de Compra           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ							
						MaAvalPC("SC7",1,nZ==Len(aVencedor),Nil,Nil,Nil,bCtbOnLine,.F.)
						
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Grava o rateio do centro de custo da solicitacao no pedido de compra ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						CotGeraSCH(aBkpFilAdm[1])
												
						If nScan == Nil 
  							cItemPc	:= Soma1(cItemPc)
         				EndIf

						//Grava tipo de Compra no item do Pedido
						MTAtuTpCom("SC7",.T.)
						
						If (Existblock("AVALCOT"))
							ExecBlock("AVALCOT",.F.,.F.,{nEvento})
						EndIf
					EndIf
				Next nY
			Next nX
		EndIf
	
		//-- Retorna filial
		If cFilAnt # aBkpFilAdm[1]
			SM0->(dbSetOrder(1))
			SM0->(dbSeek(cEmpAnt+aBkpFilAdm[1]))
			cFilAnt := FWCodFil()
			
			//-- Volta backup de variaveis
			cNumPed   := aBkpFilAdm[2]
			cItemPC   := aBkpFilAdm[3]
			cGrupo    := aBkpFilAdm[4]
			cGrComPad := aBkpFilAdm[5]
		EndIf
	Next nZ

	For nZ := 1 To Len(aPedidos)
		SM0->(dbSetOrder(1))
		SM0->(dbSeek(cEmpAnt+aPedidos[nZ,1]))
		cFilAnt := aPedidos[nZ,1]
		
		SC7->(dbSetOrder(1))
		SC7->(dbSeek(xFilial("SC7")+aPedidos[nZ,2]))
		cNumPed := SC7->C7_NUM	
		nMoedaPed:= SC7->C7_MOEDA
		nTxMoeda:= SC7->C7_TXMOEDA

		//- Controle de alçadas.
		If SuperGetMv("MV_APRPCEC",.F.,.F.)
			aAreaBlq := GetArea()
			
			//Gera aHeader e aCols das tabelas SC7 e SCH para utilização no bloqueio por Entidade Contabil.
			If Len(aHeadSC7) > 0 .Or. Len(aColsSC7) > 0 .Or. Len(aHeadSCH) > 0 .Or. Len(aColsSCH) > 0
				aHeadSC7:={}
				aColsSC7:={}
				aHeadSCH:={}
				aColsSCH:={}

				COMGerC7Ch(cNumPed,@aFilSCH)
			Else
				COMGerC7Ch(cNumPed,@aFilSCH)
			EndIf
			
			//Bloqueia pedido
			lBloqIP := MaEntCtb("SC7","SCH",cNumPed,"IP",aHeadSC7,aColsSC7,aHeadSCH,aFilSCH,1,SC7->C7_EMISSAO,aValItPc[nZ])
			RestArea(aAreaBlq)
		EndIf
		If !lBloqIP
			lLiberou := MaAlcDoc({SC7->C7_NUM,"PC",aPedidos[nZ,4],,,SC7->C7_APROV,,SC7->C7_MOEDA,SC7->C7_TXMOEDA,SC7->C7_EMISSAO},dDataBase,1)
		EndIf

		SC7->(dbCommit())
		cQuery := "UPDATE "
		cQuery += RetSqlName("SC7")+" "	
		cQuery += "SET C7_CONAPRO = '"+ IIf( !lLiberou .Or. lBloqIP .Or. GetNewPar("MV_SIGAGSP","0") == "1" , "B" , "L" ) + "' "
		cQuery += "WHERE C7_FILIAL='"+xFilial("SC7")+"' AND "
		cQuery += "C7_NUM='"+cNumPed+"' AND "
		cQuery += "D_E_L_E_T_=' ' "					
		TcSqlExec(cQuery)
		SC7->(MsGoto(RecNo()))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Envia e-mail na inclusao do Pedido de Compras.                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SC7->(MsSeek(xFilial("SC7")+cNumPed))
		
		If SuperGetMv("MV_MKPLACE",.F.,.F.)
			If ExistBlock("MT120GOK") 
				Execblock("MT120GOK",.F.,.F.,{cNumPed,.T.,.F.,.F.})
			Endif
		EndIf
		
		MEnviaMail("037",{SC7->C7_NUM,SC7->C7_NUMCOT,SC7->C7_APROV,SC7->C7_CONAPRO,Subs(cUsuario,7,15)})

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PE para manipular cada PC gravado pela analise da cotacao.       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (Existblock("AVALCOPC")) .And. ValType(aRetPE := ExecBlock("AVALCOPC",.F.,.F.,aPedidos)) == "A" 
			aPedidos := aClone(aRetPE)
		EndIf

	Next nZ
	
		//-- Retorna filial
	If ValType(aBkpFilAdm[1]) # "U" .And. cFilAnt # aBkpFilAdm[1]
		SM0->(dbSetOrder(1))
		SM0->(dbSeek(cEmpAnt+aBkpFilAdm[1]))
		cFilAnt := FWCodFil()		
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Tratamento das cotacoes perdedoras que foram analisadas                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lCotParc // Se a rotina estiver configurada para trabalhar com analise parcial de produtos.
		
		For nZ := 1 To Len(aPaginas)
			
			nX := aPaginas[nZ]
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Inicio o processo de gravacao do Pedido de Compra                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nY := 1 To Len(aColsSCE[nX])
				
				DbSelectArea("SC8")
				MsGoTo(aSC8[nX][nY][nPRegSC8][2])
				
				If Empty(SC8->C8_NUMPED)
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Encerro as cotacoes perdedoras                                          ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					RecLock("SC8")
						
						SC8->C8_NUMPED  := Repl("X", Len(SC8->C8_NUMPED))
						SC8->C8_ITEMPED := Repl("X", Len(SC8->C8_ITEMPED))
						SC8->C8_MOTIVO  := aColsSCE[nX][nY][nPMotSCE]
						
					SC8->(MsUnlock())
					
				EndIf
				
			Next nY
			
		Next nZ
		
	Else
		
		For nZ := 1 To Len(aColsSCE)
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Inicio o processo de gravacao do Pedido de Compra                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nY := 1 To Len(aColsSCE[nZ])
				
				DbSelectArea("SC8")
				MsGoTo(aSC8[nZ][nY][nPRegSC8][2])
				
				SC1->(DbSetOrder(1)) // Indice 1 - C1_FILIAL+C1_NUM+C1_ITEM+C1_ITEMGRD
				If SC1->(DbSeek(xFilial('SC1')+SC8->C8_NUMSC+SC8->C8_ITEMSC))
					
					If Empty(SC8->C8_NUMPED) 
						
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Encerro as cotacoes perdedoras                                          ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						RecLock("SC8")
							
							SC8->C8_NUMPED  := Repl("X",Len(SC8->C8_NUMPED))
							SC8->C8_ITEMPED := Repl("X",Len(SC8->C8_ITEMPED))
							SC8->C8_MOTIVO  := aColsSCE[nZ][nY][nPMotSCE]
							
						SC8->(MsUnlock())
						
						// Se o item da solicitacao de compras foi encerrado na cotacao (SC8), mas nao gerou pedido, reabre o item na solicitacao (SC1).
						If Empty(SC1->C1_PEDIDO)
							
							RecLock('SC1', .F.)
								
								SC1->C1_COTACAO := CriaVar('C1_COTACAO', .F.)
								
							SC1->(MsUnlock())
							
						EndIf
						
					EndIf
					
				EndIf
				
			Next nY
			
		Next nZ
		
	EndIf

If FwIsInCallStack("MATA161") .And. Len(aPedidos) > 0
	ComAvCot(aPedidos) 
EndIf 
	
EndCase

RestArea(aAreaSC8)
RestArea(aArea)

Return(.T.)
    

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaCanDelCo³ Autor ³ Eduardo Riera         ³ Data ³27.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se um item da cotacao pode ser excluido.            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := MaCanDelCot(ExpC1,ExpL2,ExpC2,ExpC3)				   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela de cotacao                            ³±±
±±³          ³ExpL2: Indica se o help deve ser disparado                   ³±±
±±³          ³ExpC2: msg de aviso (nao utilizada)                          ³±±
±±³          ³ExpC3: Codigo do help que foi gerado se o mesmo nao foi dispa³±±
±±³          ³       rado                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. - Se a cotacao pode ser excluida                  ³±±
±±³          ³       .F. - Se a cotacao nao pode ser excluida              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo verificar se a cotacao pode ser³±±
±±³          ³excluida sem maiores problemas para a integridade do sistema ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaCanDelCot(cAliasSC8,lHelp,cAviso,cHelp)

Local aArea 		:= GetArea()
Local lRetorno  	:= .T.
DEFAULT lRestComp	:= SuperGetMv("MV_RESTCOM")=="S"
DEFAULT lHelp       := .T.
DEFAULT cHelp       := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Valida o comprador.                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Do Case
Case ( lRestComp .And. !VldGrComp(RetCodUsr(),(cAliasSC8)->C8_GRUPCOM) )
	If ( lHelp )
		Aviso(STR0069,STR0070+(cAliasSC8)->C8_GRUPCOM+ STR0071,{STR0016},2) //"Acesso Restrito"###"O  acesso  e  a utilizacao desta rotina e destinada apenas aos usuarios pertencentes ao grupo de compras : "###". Usuario sem permissao para utilizar esta rotina.  "###"Voltar"
	Else
		cAviso := STR0070+(cAliasSC8)->C8_GRUPCOM+ STR0071 //"O  acesso  e  a utilizacao desta rotina e destinada apenas aos usuarios pertencentes ao grupo de compras : "###". Usuario sem permissao para utilizar esta rotina.  "
	EndIf
	lRetorno := .F.
Case ( !Empty((cAliasSC8)->C8_NUMPED) )
	If ( lHelp )
		Help(" ",1,"A150PED")
	Else
		cHelp := "A150PED"
	EndIf
	lRetorno := .F.
EndCase

If lRetorno
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada para validar a exclusao                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock( "MCANDCOT" )
		lRetorno := ExecBlock( "MCANDCOT", .F., .F., { ( cAliasSC8 )->C8_NUM,;
			( cAliasSC8 )->C8_FORNECE,( cAliasSC8 )->C8_LOJA,( cAliasSC8 )->C8_ITEM,;
			( cAliasSC8 )->C8_NUMPRO } )
	EndIf 	
EndIf

RestArea(aArea)
Return(lRetorno)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaCanAltCo³ Autor ³ Eduardo Riera         ³ Data ³27.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se um item da cotacao pode ser alterado.            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := MaCanAltCot(ExpC1,ExpL2,ExpC2,ExpN1)				   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela de cotacao                            ³±±
±±³          ³ExpL2: .T. - Exibe o help,  .F. - nao exibe			       ³±±
±±³          ³ExpC2: msg de aviso (nao utilizada)                          ³±±
±±³          ³ExpN1: numero da opcao  			                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. - Se a cotacao pode ser alterada                  ³±±
±±³          ³       .F. - Se a cotacao nao pode ser alterada              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo verificar se a cotacao pode ser³±±
±±³          ³alterada sem maiores problemas para a integridade do sistema ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaCanAltCot(cAliasSC8,lHelp,cAviso,nOpc)

Local aArea 		:= GetArea()
Local lRetorno  	:= .T.
Local aRet          := {}
Local lPortFor	:= IsInCallStack("PUTQUOTE") //Proposta veio do portal do fornecedor

DEFAULT lRestComp	:= SuperGetMv("MV_RESTCOM")=="S" .And. If(Type("lIsACC")#"L",.T.,!lIsACC)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Valida o comprador.                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Do Case
Case ( lRestComp .And. !VldGrComp(RetCodUsr(),(cAliasSC8)->C8_GRUPCOM) .And. !lPortFor)
	If lHelp
		Aviso(STR0069,STR0070+(cAliasSC8)->C8_GRUPCOM+ STR0071,{STR0016},2) //"Acesso Restrito"###"O  acesso  e  a utilizacao desta rotina e destinada apenas aos usuarios pertencentes ao grupo de compras : "###". Usuario sem permissao para utilizar esta rotina.  "###"Voltar"
	Else
		cAviso := STR0070+(cAliasSC8)->C8_GRUPCOM+ STR0071 //"O  acesso  e  a utilizacao desta rotina e destinada apenas aos usuarios pertencentes ao grupo de compras : "###". Usuario sem permissao para utilizar esta rotina.  "
	EndIf
	lRetorno := .F.
Case ( !Empty((cAliasSC8)->C8_NUMPED) )
	If lHelp
		Help(" ",1,"A150PED")
	Else
		cHelp := "A150PED"
	EndIf
	lRetorno := .F.
EndCase

If lRetorno .And. Existblock("MTALTCOT")
	aRet := ExecBlock("MTALTCOT",.F.,.F.,{cAliasSC8,nOpc})
	If ValType(aRet) == "A"
		lRetorno := IIF(Valtype(aRet[1]) == "L",aRet[1],.T.)
		cAviso   := IIF(Valtype(aRet[2]) == "C" .And. !lRetorno,aRet[2],"")
	Endif	
EndIf

RestArea(aArea)
Return(lRetorno)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaMontaCot³ Autor ³ Eduardo Riera          ³ Data ³10.08.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de montagem dos dados para analise da cotacao         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := MaMontaCot(ExpA1,ExpA2,ExpA3,ExpA4,ExpA5,ExpA6,     ³±±
±±³          ³      			  ExpL2,ExpL3) 							   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com os dados do cabecalho da analise de cotacao ³±±
±±³          ³       [1] Nome do arquivo temporario                        ³±±
±±³          ³       [2] Numero da pagina selecionada                      ³±±
±±³          ³       [3] Array com os objetos do cabecalho da cotacao      ³±±
±±³          ³       [4] Header da Planilha de Cotacao (MarkBrowse)        ³±±
±±³          ³       [5] Header da Planilha de auditoria (GetDados)        ³±±
±±³          ³       [6] Header do Listbox da cotacao                      ³±±
±±³          ³       [7] Objeto da markbrowse                              ³±±
±±³          ³       [8] Objeto da GetDados                                ³±±
±±³          ³       [9] Objeto do ListBox da Cotacao                      ³±±
±±³          ³       [A] Objeto da MSMGET                                  ³±±
±±³          ³       [B] Objeto do ListBox dos ultimos fornecimentos       ³±±
±±³          ³ExpA2:*Array com os os dados da Planilha de Analise          ³±±
±±³          ³       [x] Array com a pagina atual a ser demonstrada        ³±±
±±³          ³       [x,y] Array com o conteudo dos campos a serem exibidos³±±
±±³          ³ExpA3:*Array com os os dados da Planilha de Auditoria        ³±±
±±³          ³       [x] Array com a pagina atual a ser demonstrada        ³±±
±±³          ³       [x,y] Array com o conteudo do acols da getdados       ³±±
±±³          ³ExpA4:*Array com os os dados dos registros da cotacao        ³±±
±±³          ³       [x] Array com a pagina atual a ser demonstrada        ³±±
±±³          ³       [x,1] Nome do campo                                   ³±±
±±³          ³       [x,2] Conteudo do campo                               ³±±
±±³          ³ExpA5:*Array com os os dados da Planilha de Fornecimento     ³±±
±±³          ³                                                             ³±±
±±³          ³ExpA6:*Impostos tratados pela rotina                         ³±±
±±³          ³       [x,1] Codigo de referencia do imposto                 ³±±
±±³          ³       [x,2] Nome do campo                                   ³±±
±±³          ³ExpL2: Inicializa com TES Padrao                             ³±±
±±³          ³ExpL3: Indica se eh uma visualizacao                         ³±±
±±³          ³ExpL4: Indica se a analise sera por cotacao ou por produto   ³±±
±±³          ³ExpC1: Codigo do produto se a analise for por produto        ³±±
±±³          ³ExpC2: C8_IDENT do produto se a analise for por produto      ³±±
±±³          ³ExpL5: Indica se eh e a primeira chamada da analise por prod.³±±
±±³          ³ExpA7:*Array com os dados do SC8 para restauracao da Grade.  ³±±
±±³          ³       [x] Array com a pagina atual a ser demonstrada        ³±±
±±³          ³       [x,1] Nome do campo                                   ³±±
±±³          ³       [x,2] Conteudo do campo                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. se Len(aPlanilha)>0                               ³±±
±±³          ³		 .F. se vazia                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina efetua a montagem dos dados para a analise de uma³±±
±±³          ³cotacao. Apesar de possuir uma estrutura vinculada a interfa-³±±
±±³          ³ce da analise da cotacao, ela pode ser utilizada genericamen-³±±
±±³          ³te para customizacoes da analise da cotacao (Ex. Listening ) ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaMontaCot(aCabec,aPlanilha,aAuditoria,aCotacao,aListBox,aRefImpos,lTes,lVisual,lProceCot,cProdCot,cItemCotID,lFirsT,aSC8,aCpoSC8, aHeadSC8, aColsSC8,lCotacao)

Local aArea 	  := GetArea()
Local aAreaSX3    := SX3->(GetArea())
Local aStruQry	  := SC8->(dbStruct())
Local aStruTmp    := {}
Local aCampoSC8   := {}
Local aRetM160PL  := {}
Local aRetStru    := {}
Local aScanGrd    := {}

Local cNumSC8     := SC8->C8_NUM
Local cAliasSC8   := "SC8"
Local cQuery	  := ""
Local cOrdAud	  := "C8_FILIAL,C8_NUM,C8_IDENT,C8_PRODUTO,C8_FORNECE"
Local cIdentSC8   := ""
Local cGrupCom    := ""
Local cProdRef    := ""
Local cFiltro     := ".T."
Local cTmp		  := ""

Local lVerifica   := GetMV("MV_QBLQFOR",,"N") == "S"
Local lMtxFisCo   := GetNewPar('MV_PERFORM',.T.) //Indica se ira utilizar as funcoes fiscais para calcular o valor presente
Local lSolic      := SuperGetMv("MV_RESTCOM")=="S"
Local lQuery	  := .F.
Local lGrupCom    := .T.
Local lPedido     := .T.
Local lRetorno    := .F.
Local lReferencia := .F. 
Local lGrade      := MaGrade()
Local lCotParc	  := SuperGetMv('MV_COTPARC',, .T.) // Habilita a analise da cotacao parcial.

Local nP		  := 0
Local nX		  := 0
Local nY		  := 0
Local nZ		  := 0
Local nPosRef1    := 0
Local nPosRef2    := 0
Local nCusto      := 0
Local nUsadoSC8   := 0
Local nUsadoSCE   := 0
Local nScan       := 0
Local nSC8Fornec  := 0
Local nSC8Loja    := 0
Local nSC8NumPro  := 0
Local nSC8Item    := 0
Local nSC8Quant   := 0
Local nSC8Preco   := 0
Local nSC8Total   := 0
Local nSC8Scan    := 0
Local nPlanScan   := 0
Local nPlanFornec := 0
Local nPlanLoja   := 0
Local nPlanNumPro := 0
Local nPlanItem   := 0
Local nPlanPreco  := 0
Local nPlanTotal  := 0
Local nC8PrecDec  := TamSX3("C8_PRECO")[2]
Local cTipoX3 := ""
Local lExistSCE	  := .F.

DEFAULT aPlanilha  := {}
DEFAULT aAuditoria := {}
DEFAULT aCotacao   := {}
DEFAULT aListBox   := {}
DEFAULT aSC8       := {}
DEFAULT aCabec     := Array(12)
DEFAULT aCabec[CAB_HFLD1] := {}
DEFAULT aCabec[CAB_HFLD2] := {}
DEFAULT aCabec[CAB_HFLD3] := {}
DEFAULT aRefImpos  := {}
DEFAULT lTES	   := .F.
DEFAULT lVisual	   := .F.
DEFAULT lProceCot  := .T. 
DEFAULT lFirsT     := .T.
DEFAULT cProdCot   := " "
DEFAULT cItemCotID := " "
DEFAULT aCpoSC8    := {}
DEFAULT aHeadSC8	:= {}
DEFAULT aColsSC8	:= {}
DEFAULT lCotacao := .F.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Efetua a montagem da planilha de fornecimento                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SX3")
dbSetOrder(1)
MsSeek("SC8")
While ( !Eof() .And. SX3->X3_ARQUIVO == "SC8" )
	If ( X3Uso(SX3->X3_USADO) .And. cNivel >= SX3->X3_NIVEL .And.;
			SX3->X3_CONTEXT<>"V" .And. !Trim(SX3->X3_CAMPO)$"C8_ITEM" )
		
		cTipoX3:= SX3->X3_TIPO
		
		IF SX3->X3_TIPO == 'M' .AND. Trim(SX3->X3_CAMPO)$"C8_OBS"
			cTipoX3 := 'C'
		ENDIF
		
		
		If lMtxFisCo
			nUsadoSC8++
			If lFirsT
				AADD(aCabec[CAB_HFLD3],TRIM(X3Titulo()))
				AADD(aHeadSC8,{ TRIM(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,;
							SX3->X3_VALID,SX3->X3_USADO,cTipoX3,SX3->X3_F3,SX3->X3_CONTEXT })
			Endif	
			AADD(aCampoSC8,{SX3->X3_CAMPO,SX3->X3_PICTURE,cTipoX3})
		Else
			If Trim(SX3->X3_CAMPO)$ "C8_NUMPRO#C8_NUMSC#C8_ITEMSC#C8_PRODUTO#C8_PRECO#C8_QUANT#C8_TOTAL#C8_AVISTA"
				nUsadoSC8++
				If lFirsT
					AADD(aCabec[CAB_HFLD3],TRIM(X3Titulo()))
					AADD(aHeadSC8,{ TRIM(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,;
							SX3->X3_VALID,SX3->X3_USADO,cTipoX3,SX3->X3_F3,SX3->X3_CONTEXT })
				Endif	
				AADD(aCampoSC8,{SX3->X3_CAMPO,SX3->X3_PICTURE,cTipoX3})
			Endif	
		Endif	
	EndIf
	If lFirsT
		nPosRef1	:= At("MAFISREF(",Upper(SX3->X3_VALID))
		If ( nPosRef1 > 0 )
			nPosRef1    += 10
			nPosRef2    := At(",",SubStr(SX3->X3_VALID,nPosRef1))-2
			aadd(aRefImpos,{"SC8",SX3->X3_CAMPO,SubStr(SX3->X3_VALID,nPosRef1,nPosRef2)})
		EndIf
	Endif	
	dbSelectArea("SX3")
	dbSkip()
EndDo
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Efetua a montagem da planilha de auditoria                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SX3")
dbSetOrder(1)
MsSeek("SCE")
While ( !Eof() .And. SX3->X3_ARQUIVO == "SCE" )
	If ( X3Uso(SX3->X3_USADO) .And. cNivel >= SX3->X3_NIVEL ) .Or. AllTrim(SX3->X3_CAMPO) == "CE_NUMPRO"
		If ! AllTrim(SX3->X3_CAMPO) $ "CE_NUMCOT; CE_ITEMCOT"
			nUsadoSCE++
			If lFirsT
				AADD(aCabec[CAB_HFLD2],{ TRIM(X3Titulo()),;
					Trim(SX3->X3_CAMPO),;
					SX3->X3_PICTURE,;
					SX3->X3_TAMANHO,;
					SX3->X3_DECIMAL,;
					SX3->X3_VALID,;
					SX3->X3_USADO,;
					SX3->X3_TIPO,;
					SX3->X3_F3,;
					SX3->X3_CONTEXT,;
					SX3->X3_PROPRI } )
			Endif	
		Endif
	EndIf
	dbSelectArea("SX3")
	dbSkip()
EndDo

If aScan(aCabec[CAB_HFLD2], {|z| AllTrim(z[2]) == "CE_ITEMCOT"}) == 0
	dbSetOrder(2)
	dbSeek(Pad("CE_ITEMCOT", 10))
	nUsadoSCE++
	AADD(aCabec[CAB_HFLD2],{ TRIM(X3Titulo()),;
		Trim(SX3->X3_CAMPO),;
		SX3->X3_PICTURE,;
		SX3->X3_TAMANHO,;
		SX3->X3_DECIMAL,;
		SX3->X3_VALID,;
		SX3->X3_USADO,;
		SX3->X3_TIPO,;
		SX3->X3_F3,;
		SX3->X3_CONTEXT,;
		SX3->X3_PROPRI } )
	dbSetOrder(1)
Endif

If aScan(aCabec[CAB_HFLD2], {|z| AllTrim(z[2]) == "CE_NUMCOT"}) == 0
	dbSetOrder(2)
	dbSeek(Pad("CE_NUMCOT", 10))
	nUsadoSCE++
	AADD(aCabec[CAB_HFLD2],{ TRIM(X3Titulo()),;
		Trim(SX3->X3_CAMPO),;
		SX3->X3_PICTURE,;
		SX3->X3_TAMANHO,;
		SX3->X3_DECIMAL,;
		SX3->X3_VALID,;
		SX3->X3_USADO,;
		SX3->X3_TIPO,;
		SX3->X3_F3,;
		SX3->X3_CONTEXT,;
		SX3->X3_PROPRI } )
	dbSetOrder(1)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Walk Thru                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ADHeadRec("SCE",aCabec[CAB_HFLD2])

If lFirsT
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Efetua a preparacao dos dados que serao mostrados na planilha          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aadd(aCabec[CAB_HFLD1],{"PLN_OK"     ,"","",""})
	aadd(aCabec[CAB_HFLD1],{"PLN_FORNECE","",RetTitle("C8_FORNECE"),PesqPict("SC8","C8_FORNECE")})
	aadd(aCabec[CAB_HFLD1],{"PLN_LOJA"   ,"",RetTitle("C8_LOJA"),PesqPict("SC8","C8_LOJA")})
	aadd(aCabec[CAB_HFLD1],{"PLN_NREDUZ" ,"",RetTitle("A2_NREDUZ"),PesqPict("SA2","A2_NREDUZ")})
	aadd(aCabec[CAB_HFLD1],{"PLN_NUMPRO" ,"",RetTitle("C8_NUMPRO"),PesqPict("SC8","C8_NUMPRO")})
	aadd(aCabec[CAB_HFLD1],{"PLN_TOTAL"  ,"",RetTitle("C8_TOTAL"),PesqPict("SC8","C8_TOTAL")})
	aadd(aCabec[CAB_HFLD1],{"PLN_DATPRF" ,"",RetTitle("C8_DATPRF"),PesqPict("SC8","C8_DATPRF")})
	aadd(aCabec[CAB_HFLD1],{"PLN_DATPRZ" ,"",RetTitle("C8_PRAZO"),PesqPict("SC8","C8_DATPRF")})
	aadd(aCabec[CAB_HFLD1],{"PLN_DESVIO" ,"",RetTitle("A2_DESVIO"),PesqPict("SA2","A2_DESVIO")})
	aadd(aCabec[CAB_HFLD1],{"PLN_NOTA"   ,"",RetTitle("A5_NOTA"),PesqPict("SA5","A5_NOTA")})
	aadd(aCabec[CAB_HFLD1],{"PLN_FLAG"   ,"","",""})
	aadd(aCabec[CAB_HFLD1],{"PLN_ITEM"   ,"",RetTitle("C8_ITEM"),PesqPict("SC8","C8_ITEM")})
	aadd(aCabec[CAB_HFLD1],{"PLN_PRECO"  ,"",RetTitle("C8_PRECO"),PesqPict("SC8","C8_PRECO")})
	aadd(aCabec[CAB_HFLD1],{"PLN_COND"   ,"",RetTitle("C8_COND"),PesqPict("SC8","C8_COND")})
	aadd(aCabec[CAB_HFLD1],{"PLN_DESCRI" ,"",RetTitle("E4_DESCRI"),PesqPict("SE4","E4_DESCRI")})
	aadd(aCabec[CAB_HFLD1],{"PLN_PRAZO"  ,"",RetTitle("C8_PRAZO"),PesqPict("SC8","C8_PRAZO")})
	aadd(aCabec[CAB_HFLD1],{"PLN_VISTO"  ,"","",""})
	aadd(aCabec[CAB_HFLD1],{"PLN_ITEMGRD","",RetTitle("C8_ITEMGRD"),PesqPict("SC8","C8_ITEMGRD")})
	aadd(aCabec[CAB_HFLD1],{"PLN_OBS"    ,"",RetTitle("C8_OBS"),""})

	dbSelectArea("SX3")
	dbSetOrder(2)
	MsSeek("C8_FORNECE")
	aadd(aStruTmp,{"PLN_OK","C",2,0})
	aadd(aStruTmp,{"PLN_FORNEC",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("C8_LOJA")
	aadd(aStruTmp,{"PLN_LOJA",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("A2_NREDUZ")
	aadd(aStruQry,{"A2_NREDUZ",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	aadd(aStruTmp,{"PLN_NREDUZ",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("C8_NUMPRO")
	aadd(aStruTmp,{"PLN_NUMPRO",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("C8_TOTAL")
	aadd(aStruTmp,{"PLN_TOTAL",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("C8_DATPRF")
	aadd(aStruTmp,{"PLN_DATPRF",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	aadd(aStruTmp,{"PLN_DATPRZ",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("A2_DESVIO")
	aadd(aStruQry,{"A2_DESVIO",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	aadd(aStruTmp,{"PLN_DESVIO",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("A5_NOTA")
	aadd(aStruTmp,{"PLN_NOTA",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	aadd(aStruTmp,{"PLN_FLAG","N",1,0})
	MsSeek("C8_ITEM")
	aadd(aStruTmp,{"PLN_ITEM",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("C8_PRECO")
	aadd(aStruTmp,{"PLN_PRECO",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("C8_COND")
	aadd(aStruTmp,{"PLN_COND",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("E4_DESCRI")
	aadd(aStruTmp,{"PLN_DESCRI",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("C8_PRAZO")
	aadd(aStruTmp,{"PLN_PRAZO",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	aadd(aStruTmp,{"PLN_VISTO","C",1,0})
	MsSeek("C8_ITEMGRD")
	aadd(aStruTmp,{"PLN_ITEMGR",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("C8_OBS")
	aadd(aStruTmp,{"PLN_OBS","C",SX3->X3_TAMANHO,SX3->X3_DECIMAL})

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Preenche array aCpoSC8 com os campos do cabecalho para permitir alterar³
	//³ a ordem dos campos                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	aEval( aCabec[CAB_HFLD1] , { |x| aAdd( aCpoSC8 , x[1] ) } )

	If ExistBlock("M160STRU") 
		aRetStru := ExecBlock("M160STRU",.F.,.F.,{aStruTmp,aCabec[CAB_HFLD1],aCpoSC8})
	    If ValType(aRetStru[1]) == "A" .And. Len(aRetStru[1]) > 0
		    aStruTmp := aRetStru[1]
	    Endif
	    If ValType(aRetStru[2]) == "A" .And. Len(aRetStru[2]) > 0
		    aCabec[CAB_HFLD1] := aRetStru[2]
	    Endif	    
	    If ValType(aRetStru[3]) == "A" .And. Len(aRetStru[3]) > 0
		    aCpoSC8 := aRetStru[3]
	    Endif	    
	EndIf

	//Cria o arquivo temporario
	cTmp := GetNextAlias()
	oTmpTable := FWTemporaryTable():New( cTmp, aStruTmp )
	oTmpTable:Create()
	
	aCabec[CAB_ARQTMP] := cTmp
Else
	dbSelectArea("SX3")
	dbSetOrder(2)
	MsSeek("A2_NREDUZ")
	aadd(aStruQry,{"A2_NREDUZ",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})

	MsSeek("A2_DESVIO")
	aadd(aStruQry,{"A2_DESVIO",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
Endif	

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Efetua a montagem das paginas de cotacao                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC8")
dbSetOrder(4)
MsSeek(xFilial("SC8")+cNumSC8)

cAliasSC8:= "MAMONTACOT"
lQuery := .T.
cQuery := ""
For nX := 1 To Len(aStruQry)
	cQuery += ","+aStruQry[nX][1]
Next nX
cQuery := "SELECT SB1.B1_TE,"+SubStr(cQuery,2)+",SC8.R_E_C_N_O_ SC8RECNO "
cQuery += "FROM "+RetSqlName("SC8")+" SC8,"
cQuery += RetSqlName("SA2")+" SA2,"
cQuery += RetSqlName("SB1")+" SB1 "
cQuery += "WHERE SC8.C8_FILIAL='"+xFilial("SC8")+"' AND "
cQuery += "SC8.C8_NUM='"+cNumSC8+"' AND "
   
IF lCotacao 
	cQuery += "SC8.C8_NUMPED='' AND "
EndIf

If !lProceCot .And. !Empty(cProdCot) .And. !Empty(cItemCotID)
	cQuery += "SC8.C8_PRODUTO = '"+cProdCot+"' AND "
	cQuery += "SC8.C8_IDENT   = '"+cItemCotID+"' AND "
Endif
cQuery += "SC8.D_E_L_E_T_=' ' AND "
cQuery += "SA2.A2_FILIAL='"+xFilial("SA2")+"' AND "
cQuery += "SA2.A2_COD=SC8.C8_FORNECE AND "
cQuery += "SA2.A2_LOJA=SC8.C8_LOJA AND "
cQuery += "SA2.D_E_L_E_T_=' ' AND "
cQuery += "SB1.B1_FILIAL='"+xFilial("SB1")+"' AND "
cQuery += "SB1.B1_COD=SC8.C8_PRODUTO AND "
cQuery += "SB1.D_E_L_E_T_=' ' "
cQuery += "ORDER BY "+cOrdAud
cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSC8,.T.,.T.)
For nX := 1 To Len(aStruQry)
	If ( aStruQry[nX][2] == "D" )
		TcSetField(cAliasSC8,aStruQry[nX][1],aStruQry[nX][2],aStruQry[nX][3],aStruQry[nX][4])
	EndIf
Next nX	

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica ponto de entrada de filtragem                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (Type('lIsACC')#'L' .Or. !lIsACC) .And. ExistBlock("MT160FIL")
	cFiltro := ExecBlock("MT160FIL",.F.,.F.,{cAliasSC8})
EndIf

dbSelectArea(cAliasSC8)
While ( !Eof() .And. (cAliasSC8)->C8_FILIAL == xFilial("SC8") .And. (cAliasSC8)->C8_NUM == cNumSC8 )

	If lCotacao
	   If ! IsEmpty((cAliasSC8)->C8_NUMPED) 
			(cAliasSC8)->(dbSkip())
			Loop
	   EndIf
	EndIf
	
	If ( !lQuery )
		If !lProceCot .And. !Empty(cProdCot) .And. !Empty(cItemCotID)
			If RetCodProdFam((cAliasSC8)->C8_PRODUTO) <> RetCodProdFam(cProdCot) .And. (cAliasSC8)->C8_IDENT <> cItemCotID
				dbSelectArea(cAliasSC8)
				dbSkip()
				Loop
			Endif
		Endif
	Endif
    
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o filtro utilizado e valido senao substitui por ".T."      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If Valtype(cFiltro) == "C" .And. Empty(cFiltro)
    	cFiltro:= ".T."
    ElseIf Valtype(cFiltro) != "C"
    	cFiltro:= ".T."
    EndIf
    
	If &(cFiltro)
		
		If !lVisual .And. lSolic .And. !VldAnCot(RetCodUsr(),(cAliasSC8)->C8_GRUPCOM)
			cGrupCom  := (cAliasSC8)->C8_GRUPCOM
		Else

			lGrupCom  := .F.

			If lVisual .Or. lCotParc .Or. Empty((cAliasSC8)->C8_NUMPED)
			
				If Empty((cAliasSC8)->C8_NUMPED)
					lPedido   := .F.
				EndIf
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se o Produto x Fornecedor esta definido para Inspecao no QIE, ³
				//³ se o mesmo possui a Situacao; "Nao-Habilitado, neste caso o mesmo nao  ³
				//³ sera selecionado para analise nas cotacoes. 						   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lVisual .And. lVerifica
					If !QieSitFornec((cAliasSC8)->C8_FORNECE,(cAliasSC8)->C8_LOJA,(cAliasSC8)->C8_PRODUTO,.F.)
						Aviso((STR0127),OemToAnsi(STR0123)+Alltrim((cAliasSC8)->C8_PRODUTO)+OemToAnsi(STR0124)+Alltrim((cAliasSC8)->C8_FORNECE)+OemToAnsi(STR0125)+Alltrim((cAliasSC8)->C8_LOJA)+(STR0126),{STR0118}) // O produto XXX foi bloqueado pela Qualidade para esse Fornecedor  Loja, O mesmo nao participara do processo realizado. " ## "Ok"
						dbSelectArea(cAliasSC8)
						dbSkip()
						Loop
					EndIf
				EndIf
						
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calculo do custo da Cotacao                                            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lMtxFisCo
					nMoedaAval := Max((cAliasSC8)->C8_MOEDA,1)
					MaFisIni((cAliasSC8)->C8_FORNECE,(cAliasSC8)->C8_LOJA,"F","N","R")
					MaFisIniLoad(1)
					For nY := 1 To Len(aRefImpos)
						MaFisLoad(aRefImpos[nY][3],(cAliasSC8)->(FieldGet(FieldPos(aRefImpos[nY][2]))),1)
					Next nY
					If ( lTes .And. Empty((cAliasSC8)->C8_TES) )
						If ( !lQuery )
							dbSelectArea("SB1")
							dbSetOrder(1)
							MsSeek(xFilial("SB1")+(cAliasSC8)->C8_PRODUTO)
							MaFisAlt("IT_TES",RetFldProd(SB1->B1_COD,"B1_TE"),1)
						Else
							MaFisAlt("IT_TES",RetFldProd((cAliasSC8)->C8_PRODUTO,"B1_TE"),1)
						EndIf
					EndIf
					MaFisEndLoad(1)
					nCusto := Ma160Custo(cAliasSC8,1)
					MaFisEnd()
				Else
					nCusto := Ma160Custo(cAliasSC8,1)
				Endif
                
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Quando o C8_IDENT for diferente sera construida uma nova dimensao em   ³
				//³ todo conjunto de Arrays da Analise para paginar um novo produto, isso  ³
				//³ so nao ocorrera se o Produto for um produto com item de Grade, neste   ³
				//³ caso o C8_IDENT e o mesmo para todos os itens com Grade e os arrays    ³
				//³ aPlanilha,aCotacao e aAuditoria sao construido de forma Sintetica.     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cIdentSC8 <> (cAliasSC8)->C8_IDENT 
					cIdentSC8:= (cAliasSC8)->C8_IDENT
					aadd(aPlanilha,{})
					aadd(aCotacao,{})
					aadd(aAuditoria,{})
					aadd(aListBox,{})
					aadd(aColsSC8,{})
					nX 		 := Len(aPlanilha)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Array usado para Gravacao do PC pela Analise da Cotacao na MaAvalCot   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aadd(aSC8,{})
					nP 		:= Len(aSC8)
				Endif

				aadd(aSC8[nP],{})
				nY := Len(aSC8[nP])
				dbSelectArea(cAliasSC8)
				For nZ := 1 To FCount()
					If FieldName(nZ) $ "C8_NUMPRO#C8_FORNECE#C8_LOJA#C8_COND#C8_PRODUTO#C8_ITEM#C8_NUM#C8_ITEMGRD#SC8RECNO#C8_FILENT"
						aadd(aSC8[nP][nY],{FieldName(nZ),FieldGet(nZ)})
					Endif
				Next nZ
				If !lQuery 
					aadd(aSC8[nP][nY],{"SC8RECNO",(cAliasSC8)->(RecNo())})
				EndIf
			
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Planilha de cotacao                                                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ				
				If !lGrade .Or. Empty((cAliasSC8)->C8_ITEMGRD) .Or. aScan(aScanGrd, {|z| z[1] + z[2] + z[3] + z[4] == (cAliasSC8)->(C8_FORNECE+C8_LOJA+C8_NUMPRO+C8_ITEM)}) == 0

					Aadd(aScanGrd, {(cAliasSC8)->C8_FORNECE, (cAliasSC8)->C8_LOJA, (cAliasSC8)->C8_NUMPRO, (cAliasSC8)->C8_ITEM, (cAliasSC8)->(Recno())})

					cProdRef   := (cAliasSC8)->C8_PRODUTO
					lReferencia:= MatGrdPrrf(@cProdRef,.T.)
					dbSelectArea("SA5")
					dbSetOrder(1)
					If ! MsSeek(xFilial("SA5")+(cAliasSC8)->C8_FORNECE+(cAliasSC8)->C8_LOJA+(cAliasSC8)->C8_PRODUTO).And.lReferencia
						dbSelectArea("SA5")
						dbSetOrder(9)
						MsSeek(xFilial("SA5")+(cAliasSC8)->C8_FORNECE+(cAliasSC8)->C8_LOJA+cProdRef )
					Endif

					SE4->(dbSetOrder(1))
					SE4->(MsSeek(xFilial("SE4")+(cAliasSC8)->C8_COND))
										
					If !( lQuery )
						dbSelectArea("SA2")
						dbSetOrder(1)
						MsSeek(xFilial("SA2")+(cAliasSC8)->C8_FORNECE+(cAliasSC8)->C8_LOJA)
					EndIf
					
					aAdd(aPlanilha[nx],Array(len(aCpoSC8)))
					
					For ny:=1 to len(aCpoSC8)
						Do Case
							Case aCpoSC8[ny] == "PLN_DESCRI"
								aPlanilha[nx,len(aPlanilha[nx]),ny] := SE4->E4_DESCRI
							Case aCpoSC8[ny] == "PLN_NOTA"
								aPlanilha[nx,len(aPlanilha[nx]),ny] := SA5->A5_NOTA
							Case aCpoSC8[ny] == "PLN_DESVIO"
								aPlanilha[nx,len(aPlanilha[nx]),ny] := If(lQuery,(cAliasSC8)->A2_DESVIO,SA2->A2_DESVIO)
							Case aCpoSC8[ny] == "PLN_NREDUZ"
								aPlanilha[nx,len(aPlanilha[nx]),ny] := If(lQuery,(cAliasSC8)->A2_NREDUZ,SA2->A2_NREDUZ)
							Case aCpoSC8[ny] == "PLN_OK"
								aPlanilha[nx,len(aPlanilha[nx]),ny] := Space(2)
							Case aCpoSC8[ny] == "PLN_TOTAL"
								aPlanilha[nx,len(aPlanilha[nx]),ny] := nCusto
							Case aCpoSC8[ny] == "PLN_DATPRZ"
								aPlanilha[nx,len(aPlanilha[nx]),ny] := dDataBase+(cAliasSC8)->C8_PRAZO
							Case aCpoSC8[ny] == "PLN_PRECO"
								aPlanilha[nx,len(aPlanilha[nx]),ny] := xMoeda((cAliasSC8)->C8_PRECO,(cAliasSC8)->C8_MOEDA,1,(cAliasSC8)->C8_EMISSAO,nC8PrecDec,(cAliasSC8)->C8_TXMOEDA)
							Case aCpoSC8[ny] == "PLN_FLAG"
								aPlanilha[nx,len(aPlanilha[nx]),ny] := 0
							Case aCpoSC8[ny] == "PLN_VISTO"
								aPlanilha[nx,len(aPlanilha[nx]),ny] := " "
							Case aCpoSC8[ny] == "PLN_OBS"
								//Posiciona a SC8 na linha, referenciando pelo RECNO (Topconn não lê campo Memo)
								SC8->(MsGoTo((cAliasSC8)->SC8RECNO))
								aPlanilha[nx,len(aPlanilha[nx]),ny] := SC8->C8_OBS	
							OtherWise
								aPlanilha[nx,len(aPlanilha[nx]),ny] := (cAliasSC8)->&("C8_"+substr(aCpoSC8[ny],at("_",aCpoSC8[ny])+1))
						EndCase
					Next

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Armazenna posicao dos campos da planilha                               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nPlanFornec := aScan(aCpoSC8,"PLN_FORNEC")
					nPlanLoja   := aScan(aCpoSC8,"PLN_LOJA")
					nPlanNumPro := aScan(aCpoSC8,"PLN_NUMPRO")
					nPlanItem   := aScan(aCpoSC8,"PLN_ITEM")
					nPlanPreco  := aScan(aCpoSC8,"PLN_PRECO")
					nPlanTotal  := aScan(aCpoSC8,"PLN_TOTAL")

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Dados da cotacao                                                       ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aadd(aCotacao[nX],{})
					nY := Len(aCotacao[nX])
					dbSelectArea(cAliasSC8)
					For nZ := 1 To FCount()
						If lMtxFisCo
							aadd(aCotacao[nX][nY],{FieldName(nZ),FieldGet(nZ)})
						Else
							If FieldName(nZ) $ "C8_NUM#C8_ITEM#C8_NUMPRO#C8_FORNECE#C8_LOJA#C8_PRODUTO#C8_QUANT#C8_NUMSC#C8_ITEMSC#C8_TAXAFIN#C8_COND#SC8RECNO#C8_ITEMGRD"
								aadd(aCotacao[nX][nY],{FieldName(nZ),FieldGet(nZ)})
							Endif
						Endif
					Next nZ
					If ( !lQuery )
						aadd(aCotacao[nX][nY],{"SC8RECNO",(cAliasSC8)->(RecNo())})
					EndIf
					
					nSC8Fornec  := aScan(aCotacao[nX, nY], {|z| AllTrim(z[1]) == "C8_FORNECE"})
					nSC8Loja    := aScan(aCotacao[nX, nY], {|z| AllTrim(z[1]) == "C8_LOJA"   })
					nSC8NumPro  := aScan(aCotacao[nX, nY], {|z| AllTrim(z[1]) == "C8_NUMPRO" })
					nSC8Item    := aScan(aCotacao[nX, nY], {|z| AllTrim(z[1]) == "C8_ITEM"   })
					nSC8Quant   := aScan(aCotacao[nX, nY], {|z| AllTrim(z[1]) == "C8_QUANT"  })
					nSC8Preco   := aScan(aCotacao[nX, nY], {|z| AllTrim(z[1]) == "C8_PRECO"  })
					nSC8Total   := aScan(aCotacao[nX, nY], {|z| AllTrim(z[1]) == "C8_TOTAL"  })

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Planilha de Auditoria                                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aadd(aAuditoria[nX],Array(Len(aCabec[CAB_HFLD2])+1))

					lExistSCE := .F.
					DbSelectArea("SCE")
					If MsSeek(xFilial("SCE")+(cAliasSC8)->C8_NUM+(cAliasSC8)->C8_ITEM+(cAliasSC8)->C8_PRODUTO+(cAliasSC8)->C8_FORNECE+(cAliasSC8)->C8_LOJA)
						lExistSCE := .T.
					EndIf

					For nY := 1 To Len(aCabec[CAB_HFLD2])
						Do Case
							Case IsHeadRec(aCabec[CAB_HFLD2][nY][2])
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->(Recno()),  IIf(lQuery , (cAliasSC8)->SC8RECNO , (cAliasSC8)->(Recno()) ) )
							Case IsHeadAlias(aCabec[CAB_HFLD2][nY][2])
								aAuditoria[nX][Len(aAuditoria[nX])][nY] :=  IIF(lExistSCE,"SCE","SC8")
							Case aCabec[CAB_HFLD2][nY][2]=="CE_NUMPRO"
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->CE_NUMPRO,(cAliasSC8)->C8_NUMPRO)
							Case aCabec[CAB_HFLD2][nY][2]=="CE_FORNECE"
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->CE_FORNECE,(cAliasSC8)->C8_FORNECE)
							Case aCabec[CAB_HFLD2][nY][2]=="CE_LOJA"
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->CE_LOJA,(cAliasSC8)->C8_LOJA)
							Case aCabec[CAB_HFLD2][nY][2]=="CE_DESCFOR"
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->CE_DESCFOR,Posicione("SA2", 1, xFilial("SA2")+(cAliasSC8)->C8_FORNECE, "A2_NOME"))
							Case  aCabec[CAB_HFLD2][nY][2]=="CE_ENTREGA"
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->CE_ENTREGA,(cAliasSC8)->C8_DATPRF)
							Case  aCabec[CAB_HFLD2][nY][2]=="CE_ITEMCOT"
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->CE_ITEMCOT,(cAliasSC8)->C8_ITEM)
							Case  aCabec[CAB_HFLD2][nY][2]=="CE_NUMCOT"
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->CE_NUMCOT,(cAliasSC8)->C8_NUM)
							Case  aCabec[CAB_HFLD2][nY][2]=="CE_PRODUTO"
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->CE_PRODUTO,(cAliasSC8)->C8_PRODUTO)
							Case  aCabec[CAB_HFLD2][nY][2]=="CE_ITEMGRD"
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->CE_ITEMGRD,(cAliasSC8)->C8_ITEMGRD)
							Case  aCabec[CAB_HFLD2][nY][2]=="CE_QUANT"
								dbSelectArea("SCE")
								dbSetOrder(1)
								If lExistSCE
									While SCE->(!Eof()) .And. SCE->CE_FILIAL+SCE->CE_NUMCOT+SCE->CE_ITEMCOT+SCE->CE_PRODUTO+SCE->CE_FORNECE+SCE->CE_LOJA ==;
									    xFilial("SCE")+(cAliasSC8)->C8_NUM+(cAliasSC8)->C8_ITEM+(cAliasSC8)->C8_PRODUTO+(cAliasSC8)->C8_FORNECE+(cAliasSC8)->C8_LOJA
									    If SCE->CE_NUMPRO == (cAliasSC8)->C8_NUMPRO
											aAuditoria[nX][Len(aAuditoria[nX])][nY] := SCE->CE_QUANT
											aPlanilha[nX][Len(aPlanilha[nX])][1]    := "XX"//Marca fornecedor ganhador
											Exit
										Else
											aAuditoria[nX][Len(aAuditoria[nX])][nY] := 0
										Endif
									    SCE->(dbSkip())
									EndDo
								Else
									aAuditoria[nX][Len(aAuditoria[nX])][nY] := 0
								EndIf
							Case  aCabec[CAB_HFLD2][nY][2]=="CE_MOTIVO"
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := IIF(lExistSCE,SCE->CE_MOTIVO,(cAliasSC8)->C8_MOTIVO)
							OtherWise
								aAuditoria[nX][Len(aAuditoria[nX])][nY] := CriaVar(aCabec[CAB_HFLD2][nY][2],.T.)

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Verifica se o campo pertence a tabela SCE  ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If !Empty(SCE->(FieldPos(aCabec[CAB_HFLD2][nY][2])))
									dbSelectArea("SCE")
									dbSetOrder(1)
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Verifica se o fornecedor foi o vencedor    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If MsSeek(xFilial("SCE")+(cAliasSC8)->C8_NUM+(cAliasSC8)->C8_ITEM+(cAliasSC8)->C8_PRODUTO+;
										(cAliasSC8)->C8_FORNECE+(cAliasSC8)->C8_LOJA)

										//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										//³ Verifica a proposta correta    ³
										//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										While SCE->(!Eof()) .And. SCE->CE_FILIAL+SCE->CE_NUMCOT+SCE->CE_ITEMCOT+SCE->CE_PRODUTO+SCE->CE_FORNECE+SCE->CE_LOJA ==;
										    xFilial("SCE")+(cAliasSC8)->C8_NUM+(cAliasSC8)->C8_ITEM+(cAliasSC8)->C8_PRODUTO+(cAliasSC8)->C8_FORNECE+(cAliasSC8)->C8_LOJA
										    If SCE->CE_NUMPRO == (cAliasSC8)->C8_NUMPRO
												//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
												//³ Preenche o campo da auditoria  ³
												//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												aAuditoria[nX][Len(aAuditoria[nX])][nY] := SCE->&(aCabec[CAB_HFLD2][nY][2])
												Exit
											Endif
										    SCE->(dbSkip())
										EndDo
									EndIf							
								EndIf
						EndCase
					Next nY
					aAuditoria[nX][Len(aAuditoria[nX])][ Len(aCabec[CAB_HFLD2])+1] := .F.

					aadd(aListBox[nX],{})
					aadd(aColsSC8[nX],{})
					nPlanScan := Len(aListBox[nX])
				Else
					If (nPlanFornec > 0 .And. nPlanLoja > 0 .And. nPlanNumPro > 0 .And. nPlanItem > 0)
						If (nPlanScan := aScan(aPlanilha[nX], {|z|	z[nPlanFornec] == (cAliasSC8)->C8_FORNECE .And. ;
							z[nPlanLoja] == (cAliasSC8)->C8_LOJA    .And. ;
							z[nPlanNumPro] == (cAliasSC8)->C8_NUMPRO  .And. ;
							z[nPlanItem] == (cAliasSC8)->C8_ITEM   })) > 0
							If nPlanTotal > 0
								aPlanilha[nX, nPlanScan, nPlanTotal] += nCusto
							EndIf
						Endif
					EndIf

					If (nSC8Scan := aScan(aCotacao[nX], {|z|	z[nSC8Fornec, 2] == (cAliasSC8)->C8_FORNECE .And. ;
						z[nSC8Loja  , 2] == (cAliasSC8)->C8_LOJA    .And. ;
						z[nSC8NumPro, 2] == (cAliasSC8)->C8_NUMPRO  .And. ;
						z[nSC8Item  , 2] == (cAliasSC8)->C8_ITEM   })) > 0
						
						aCotacao[nX, nSC8Scan, nSC8Quant, 2] += (cAliasSC8)->C8_QUANT
						aCotacao[nX, nSC8Scan, nSC8Total, 2] += (cAliasSC8)->C8_TOTAL
						aCotacao[nX, nSC8Scan, nSC8Preco, 2] := aCotacao[nX, nSC8Scan, nSC8Total, 2] / aCotacao[nX, nSC8Scan, nSC8Quant, 2]
						
						If nPlanPreco > 0
							aPlanilha[nX, nPlanScan,nPlanPreco] := aCotacao[nX, nSC8Scan, nSC8Preco, 2]						
						EndIf
					Endif

				Endif
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Planilha de Fornecimento                                               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aadd(aListBox[nX][nPlanScan],Array(nUsadoSC8)) 
				aadd(aColsSC8[nX][nPlanScan],Array(nUsadoSC8))
				dbSelectArea(cAliasSC8)
				For nY := 1 To Len(aCabec[CAB_HFLD3])
					If aCampoSC8[nY][3] <> "M"
						aColsSC8[nX][nPlanScan][Len(aListBox[nX][nPlanScan])][nY] := FieldGet(FieldPos(aCampoSC8[nY][1]))
						aListBox[nX][nPlanScan][Len(aListBox[nX][nPlanScan])][nY] := TransForm(aColsSC8[nX][nPlanScan][Len(aListBox[nX][nPlanScan])][nY],aCampoSC8[nY][2])
					Else
						SC8->(msGoto( IIf(lQuery , (cAliasSC8)->SC8RECNO , (cAliasSC8)->(Recno())) ))
						aColsSC8[nX][nPlanScan][Len(aListBox[nX][nPlanScan])][nY] := &("SC8->"+aCampoSC8[nY][1])
						aListBox[nX][nPlanScan][Len(aListBox[nX][nPlanScan])][nY] := aColsSC8[nX][nPlanScan][Len(aListBox[nX][nPlanScan])][nY]
					EndIf
				Next nY
				aAdd(aColsSC8[nX][nPlanScan][Len(aListBox[nX][nPlanScan])], .F.)
				
				SCE->(dbSeek(xFilial("SCE") + (cAliasSC8)->(C8_NUM+C8_ITEM+C8_PRODUTO+C8_FORNECE+C8_LOJA)))

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Definicao da Estrutura do array aCotaGrade ³
				//ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
				//³ 1 - C8_FORNECE                             ³
				//³ 2 - C8_LOJA                                ³
				//³ 3 - C8_NUMPRO                              ³
				//³ 4 - C8_ITEM                                ³
				//³ 5 - C8_PRODUTO (Familia)                   ³
				//³ 6 - Alimentado quando for produto de Grade ³
				//³ 6.1 - C8_PRODUTO                           ³
				//³ 6.2 - CE_QUANT                             ³
				//³ 6.3 - C8_DATPRF                            ³
				//³ 6.4 - C8_ITEMGRD                           ³
				//³ 6.5 - Recno SC8                            ³
				//³ 6.6 - C8_QUANT (Quantidade Original)       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If IsInCallStack("MATA160") .And. (nScan := aScan(aCotaGrade, {|z| z[1] + z[2] + z[3] + z[4] == ;
					(cAliasSC8)->C8_FORNECE + (cAliasSC8)->C8_LOJA + (cAliasSC8)->C8_NUMPRO + (cAliasSC8)->C8_ITEM})) == 0
					Aadd(aCotaGrade, {(cAliasSC8)->C8_FORNECE, (cAliasSC8)->C8_LOJA, (cAliasSC8)->C8_NUMPRO, (cAliasSC8)->C8_ITEM, RetCodProdFam((cAliasSC8)->C8_PRODUTO,!Empty((cAliasSC8)->C8_ITEMGRD)), {} })
					nScan := Len(aCotaGrade)
				Endif
				
				If (! Empty((cAliasSC8)->C8_ITEMGRD )) .And. nScan > 0
					Aadd(aCotaGrade[nScan, 6], {(cAliasSC8)->C8_PRODUTO,SCE->CE_QUANT, (cAliasSC8)->C8_DATPRF, (cAliasSC8)->C8_ITEMGRD, If(lQuery, (cAliasSC8)->SC8RECNO, (cAliasSC8)->(Recno())), (cAliasSC8)->C8_QUANT })
				Endif
												
				If ExistBlock("M160PLAN")
					aRetM160PL := ExecBlock("M160PLAN",.F.,.F.,{(cAliasSC8),aPlanilha[Len(aPlanilha)],aCpoSC8})
					If ValType(aRetM160PL) == "A" .And. Len(aRetM160PL) > 0
						aPlanilha[Len(aPlanilha)] := aRetM160PL
					Endif
				EndIf

			EndIf
		EndIf
	EndIf

	dbSelectArea(cAliasSC8)
	dbSkip()

EndDo

If !lVisual 
	If lGrupCom 
		Aviso(STR0069,STR0070+cGrupCom+ STR0072,{STR0016},2) //"Acesso Restrito"###"O  acesso  e  a utilizacao desta rotina e destinada apenas aos usuarios pertencentes ao grupo de compras : "###". com direito de analise de cotacao. Usuario sem permissao para utilizar esta rotina.  "###"Voltar"
	ElseIf lPedido 
		Help(" ",1,	"A160ENCER")
	EndIf
EndIf

lRetorno := Len(aPlanilha) > 0

If lRetorno .And. Existblock("MTVLDCOT")
	lRetorno := ExecBlock("MTVLDCOT",.F.,.F.,{cNumSC8})
	lRetorno := IIF(ValType(lRetorno)=="L",lRetorno,.T.)
EndIf

If lQuery
	dbSelectArea(cAliasSC8)
	dbCloseArea()
	dbSelectArea("SC8")
EndIf

RestArea(aAreaSX3)
RestArea(aArea)

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaCanAltPC³ Autor ³ Eduardo Riera         ³ Data ³31.08.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se um item de pedido de compra pode ser alterado    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := MaCanAltPC(ExpC1,ExpL1,ExpC2)					   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela de pedido compra                      ³±±
±±³          ³ExpL1: Indica se o help deve ser disparado                   ³±±
±±³          ³ExpC2: Codigo do help que foi gerado se o mesmo nao foi dispa³±±
±±³          ³       rado                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. - Se o pedido de compra pode ser alterado         ³±±
±±³          ³       .F. - Se o pedido de compra nao pode ser alterado     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo verificar se o pedido de compra³±±
±±³          ³pode ser excluida sem maiores problemas para a integridade do³±±
±±³          ³sistema                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaCanAltPC(cAliasPC,lHelp,cHelp)

Local lRetorno := .T.
DEFAULT lHelp  := .T.
DEFAULT cHelp  := ""
Do Case
Case (cAliasSC7)->C7_QUJE > 0
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A120ALTPC")
	Else
		cHelp := "A120ALTPC"
	EndIf
Case (cAliasSC7)->C7_RESIDUO > "S"
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A120ALTPC")
	Else
		cHelp := "A120ALTPC"
	EndIf
Case (cAliasSC7)->C7_QTDACLA > 0
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A120ALTPC")
	Else
		cHelp := "A120ALTPC"
	EndIf		
EndCase
Return(lRetorno)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaCanDelPC³ Autor ³ Eduardo Riera         ³ Data ³31.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se um item da pedido de compra pode ser excluido    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := MaCanDelPC(ExpC1,ExpL1,ExpC2)					   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela de pedido de compra                   ³±±
±±³          ³ExpL2: Indica se o help deve ser disparado                   ³±±
±±³          ³ExpC2: Codigo do help que foi gerado se o mesmo nao foi dispa³±±
±±³          ³       rado                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. - Se o pedido de compra pode ser excluido         ³±±
±±³          ³       .F. - Se a pedido de compra nao pode ser excluido     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo verificar se o pedido de compra³±±
±±³          ³pode ser excluida sem maiores problemas para a integridade   ³±±
±±³          ³do sistema                                                   ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaCanDelPC(cAliasSC7,lHelp,cHelp)

Local lRetorno := .T.
DEFAULT lHelp  := .T.
DEFAULT cHelp  := ""
Do Case
Case (cAliasSC7)->C7_QUJE > 0
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A120NDEL")
	Else
		cHelp := "A120NDEL"
	EndIf
Case (cAliasSC7)->C7_RESIDUO > "S"
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A120NDEL")
	Else
		cHelp := "A120NDEL"
	EndIf
Case (cAliasSC7)->C7_QTDACLA > 0
	lRetorno :=.F.
	If ( lHelp )
		Help(" ",1,"A120NDEL")
	Else
		cHelp := "A120NDEL"
	EndIf		
EndCase
Return(lRetorno)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaAvalPC  ³ Autor ³ Eduardo Riera         ³ Data ³22.08.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de avaliacao dos eventos de um pedido de compra       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaAvalPC(ExpC1,ExpN1,ExpL1,ExpL2,ExpC2,ExpL3,ExpB1,ExpL4)	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1:*Alias da tabela de pedido de compra                   ³±±
±±³          ³ExpN1:*Codigo do Evento                                      ³±±
±±³          ³       [1] Implantacao de uma Pedido de compra               ³±±
±±³          ³       [2] Estorno de um pedido de compra                    ³±±
±±³          ³       [3] Exclusao de um pedido de compra                   ³±±
±±³          ³       [4] Liberacao de um pedido de compra                  ³±±
±±³          ³       [5] Estorno da liberacao do pedido de compra          ³±±
±±³          ³       [6] Implantacao de um pre-documento de entrada        ³±±
±±³          ³       [7] Estorno de um pre-documento de entrada            ³±±
±±³          ³       [8] Implantacao de um documento de entrada            ³±±
±±³          ³       [9] Estorno de um documento de entrada                ³±±
±±³          ³       [10]Implantacao de um documento de entrada - Average  ³±±
±±³          ³       [11]Estorno de um documento de entrada     - Average  ³±±
±±³          ³ExpL1: Indica se este eh o ultimo registro a ser processado  ³±±
±±³          ³                                                        (OPC)³±±
±±³          ³ExpL2: Indica se somente os acumalados devem ser atualizados ³±±
±±³          ³                                                        (OPC)³±±
±±³          ³ExpC2: Alias da item do documento de entrada            (OPC)³±±
±±³          ³ExpL3: Indica se a amarracao fornecedor/produto deve ser atu-³±±
±±³          ³       alizada ( DEFAULT .F. )                          (OPC)³±±
±±³          ³ExpB1: CodeBlock de contabilizacao                      (OPC)³±±
±±³          ³       E passado para o codebock o codigo do evento          ³±±
±±³          ³ExpL4: Indica se o SB2 deve ser atualizado                   ³±±
±±³          ³               ( DEFAULT .T. )                          (OPC)³±±
±±³          ³ExpL9: Indica se o SA5 deverá ser atualizado pelo codigo do  |±±
±±³          ³       produto ou pela referência de grade                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.	                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo atualizar os eventos vinculados³±±
±±³          ³a um pedido de compra:                                       ³±±
±±³          ³A) Atualizacao das tabelas complementares.                   ³±±
±±³          ³B) Atualizacao das informacoes complementares ao PC          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalPC(cAliasSC7,nEvento,lLast,lAcumulados,cAliasSD1,lIncSA5,bCtbOnLine,lAtuSB2,lIncRef,lAltera)

Local aArea 	:= GetArea()
Local aAreaSCR 	:= SCR->(GetArea())
Local aAreaSF4  := SF4->(GetArea())
Local aEstSC1   := {}
Local aRecnoSC8 := {}
Local nX        := 0
Local nQtdSol   := 0
Local nQtdaEst  := 0
Local nRegSC1   := 0
Local nQtdALib  := 0
Local nQtdLib   := 0
Local nQuantRes := 0
Local lContinua := .T.
Local lQuery    := .F.                      
Local cQuery    := ""
Local cTipo     := ""
Local cFilSC1	:= ""
Local cAliasSCQ := "SCQ"
Local cAliasSC8 := "SC8"
Local cSC8Ident := ""
Local cFilialEnt:= SB2->(SC7->(xFilEnt((cAliasSC7)->C7_FILENT)))
Local cEntrega  := If(SuperGetMv("MV_PCFILEN"),IIF(!Empty(cFilialEnt),cFilialEnt,xFilial("SB2")),xFilial("SB2"))
Local lRestCot  := If(SuperGetMV("MV_PCEXCOT")=="1",.T.,.F.)
Local lPCExCot  := lRestCot
Local lSb1TES   := SuperGetMv("MV_SB1TES",.F.,.F.)
Local lEncSC3   := .T.
Local lFluig	  := !Empty(AllTrim(GetNewPar("MV_ECMURL",""))) .And. FWWFFluig()
Local lDHQInDic  := AliasInDic("DHQ") .And. SF4->(ColumnPos("F4_EFUTUR")) > 0
Local cProdRef      := " "
Local lReferencia   := .F. 
Local aArea2 := {}		
Local aAreaSC1 := {}
Local aAreaSC6 := {}		
Local aAreaSC7 := {}
Local lQSC1	   := .F.
DEFAULT cAliasSC7   := "SC7"
DEFAULT cAliasSD1   := "SD1"
DEFAULT lLast       := .F.
DEFAULT lAcumulados := .F.
DEFAULT lIncSA5     := .F.
DEFAULT lATUSB2     := .T.
DEFAULT bCtbOnLine  := {|| .T.}
DEFAULT lIncRef     := .F.
DEFAULT lAltera     := .F.

Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de um Pedido de Compra                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza dados complementares do Pedido de Compra                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lAcumulados
		If ( cAliasSC7 == "SC7" )
			RecLock(cAliasSC7)
			If !IsInCallStack("MATA160") .Or. ( IsInCallStack("MATA160") .And. Empty(SC8->C8_ACCNUM) )// Grava o campo usuário apenas se não possuir integração com o Market Place
				If Empty((cAliasSC7)->C7_USER)
					(cAliasSC7)->C7_USER := RetCodUsr()
				Endif
			EndIf
			If Empty((cAliasSC7)->C7_ENCER)
				(cAliasSC7)->C7_ENCER := If((cAliasSC7)->C7_QUANT - (cAliasSC7)->C7_QUJE > 0," ","E")
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza as tabelas auxiliares                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lAtuSB2 .And. (cAliasSC7)->C7_RESIDUO <> "S"
		
		dbSelectArea("SF4")
		dbSetOrder(1)
		MsSeek(xFilial("SF4",(cAliasSC7)->C7_FILIAL)+(cAliasSC7)->C7_TES)
		If Empty((cAliasSC7)->C7_TES) .Or. SF4->F4_ESTOQUE == "S" .Or. (lDHQInDic .And. SF4->F4_EFUTUR == "1")  // Compra com entrega futura.
			dbSelectArea("SB2")
			dbSetOrder(1)
			If ( !MsSeek(cEntrega+(cAliasSC7)->C7_PRODUTO+(cAliasSC7)->C7_LOCAL) )
				CriaSB2((cAliasSC7)->C7_PRODUTO,(cAliasSC7)->C7_LOCAL,cEntrega)
			EndIf
			If lSb1TES
				If (cAliasSC7)->C7_ESTOQUE == "S" .Or. Empty((cAliasSC7)->C7_ESTOQUE)
					GravaB2Pre("+",(cAliasSC7)->C7_QUANT-(cAliasSC7)->C7_QUJE,(cAliasSC7)->C7_TPOP,((cAliasSC7)->C7_QUANT-(cAliasSC7)->C7_QUJE)*(cAliasSC7)->C7_QTSEGUM/(cAliasSC7)->C7_QUANT)
				EndIf
			Else
				GravaB2Pre("+",(cAliasSC7)->C7_QUANT-(cAliasSC7)->C7_QUJE,(cAliasSC7)->C7_TPOP,((cAliasSC7)->C7_QUANT-(cAliasSC7)->C7_QUJE)*(cAliasSC7)->C7_QTSEGUM/(cAliasSC7)->C7_QUANT)
			EndIf
		EndIf
	EndIf
			
	If !lAcumulados
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Baixo as solicitacoes de compra vinculadas                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( !Empty((cAliasSC7)->C7_NUMSC) )
			If ( (cAliasSC7)->C7_TIPO == 1 .Or. (cAliasSC7)->C7_TIPO == 3 )
				CNB->(dbSetOrder(1))
				If ( !Empty((cAliasSC7)->C7_NUMCOT) ) //-- Pedido de compra originado por cotacao
					If !(xFilial("SC8",(cAliasSC7)->C7_FISCORI) == SC8->C8_FILIAL .And.;
						(cAliasSC7)->C7_NUMCOT == SC8->C8_NUM .And.;
						(cAliasSC7)->C7_PRODUTO == SC8->C8_PRODUTO .And.;
						(cAliasSC7)->C7_FORNECE == SC8->C8_FORNECE .And.;
						(cAliasSC7)->C7_LOJA == SC8->C8_LOJA .And.;
						(cAliasSC7)->C7_ITEM == SC8->C8_ITEMPED .And.;
						(cAliasSC7)->C7_NUM == SC8->C8_NUMPED )
						dbSelectArea("SC8")
						dbSetOrder(3)
						MsSeek(xFilial("SC8",(cAliasSC7)->C7_FISCORI)+(cAliasSC7)->C7_NUMCOT+(cAliasSC7)->C7_PRODUTO+(cAliasSC7)->C7_FORNECE+(cAliasSC7)->C7_LOJA+(cAliasSC7)->C7_NUM+(cAliasSC7)->C7_ITEM)
					EndIf
					If !(xFilial("SCE",(cAliasSC7)->C7_FISCORI) == SCE->CE_FILIAL .And.;
						SC8->C8_NUM == SCE->CE_NUMCOT .And.;
						SC8->C8_PRODUTO == SCE->CE_PRODUTO .And.;
						SC8->C8_FORNECE == SCE->CE_FORNECE .And.;
						SC8->C8_LOJA == SCE->CE_LOJA .And.;
						SC8->C8_ITEM == SCE->CE_ITEMCOT )
						dbSelectArea("SCE")
						dbSetOrder(1)
						MsSeek(xFilial("SCE",(cAliasSC7)->C7_FISCORI)+SC8->C8_NUM+SC8->C8_ITEM+SC8->C8_PRODUTO+SC8->C8_FORNECE+SC8->C8_LOJA)
					EndIf
					If !( xFilial("SC1",(cAliasSC7)->C7_FISCORI) == SC1->C1_FILIAL .And.;
						SC8->C8_NUM == SC1->C1_COTACAO .And.;
						SC8->C8_PRODUTO == SC1->C1_PRODUTO .And.;
						SC8->C8_IDENT == SC1->C1_IDENT )
						dbSelectArea("SC1")
						dbSetOrder(5)
						MsSeek(xFilial("SC1",(cAliasSC7)->C7_FILENT)+SC8->C8_NUM+SC8->C8_PRODUTO+SC8->C8_IDENT)
					EndIf
					nQtdAEst := SCE->CE_QUANT-(cAliasSC7)->C7_QUANT
					If nQtdAEst < 0
						nQtdaEst  := SC8->C8_QUANT-(cAliasSC7)->C7_QUANT
					EndIf
					nQtdAEst := Max(0,nQtdAEst)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Quando a quantidade do Pedido de Compra for alterada para um valor menor do ³
					//³que a soma das SC´s vinculadas a cotação, deve-se diminuir o Qtd da Cotacao ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( nQtdAEst > 0 )
						RecLock("SC8")
						SC8->C8_QUANT -= nQtdAEst
						SC8->C8_TOTAL := SC8->C8_QUANT*SC8->C8_PRECO
						RecLock("SCE")
						SCE->CE_QUANT := Max(SCE->CE_QUANT - nQtdAEst,0)
						RecLock("SC1")
						SC1->C1_QUANT := Max(SC1->C1_QUANT - nQtdAEst,0)
					EndIf
					While ( !Eof() .And. xFilial("SC1",(cAliasSC7)->C7_FILENT) == SC1->C1_FILIAL .And.;
						SC8->C8_NUM     == SC1->C1_COTACAO .And.;
						SC8->C8_PRODUTO == SC1->C1_PRODUTO.And.;
						SC8->C8_IDENT   == SC1->C1_IDENT )
						
						//Implantacao de um pedido de compra atraves de cotacao
						nQtdSol := SC7->C7_QTDSOL
							
						SC7->C7_QTDSOL := Min(SC7->C7_QUANT-nQtdSol,SC1->C1_QUANT-SC1->C1_QUJE)
						If SC7->C7_QTDSOL > 0
							MaAvalSC("SC1",6,"SC8","SC7",Nil,lAtuSB2)
							SC7->C7_QTDSOL += nQtdSol
						Else
							SC7->C7_QTDSOL := nQtdSol
							If Empty(SC1->C1_PEDIDO)
								MaAvalSC("SC1",6,"SC8","SC7",Nil,lAtuSB2)
							Endif
						EndIf
						
						If SC7->C7_QTDSOL>=SC7->C7_QUANT
							Exit
						EndIf
						
						SC1->(dbSkip())
					EndDo
				ElseIf !Empty((cAliasSC7)->C7_NUMSC) .And. !IsInCallStack("CNTA120") .And. Empty((cAliasSC7)->C7_CODED)//-- Pedido de compra com SC vinculada
					dbSelectArea("SC1")					
					CNB->(dbSeek(xFilial("CNB")+(cAliasSC7)->(C7_CONTRA+C7_CONTREV+C7_PLANILH+C7_ITEMED)))
					SC1->(dbSetOrder(2))
					cFilSC1 := xFilial("SC1",(cAliasSC7)->C7_FISCORI)
					
					cSeekC1 := cFilSC1 + (cAliasSC7)->C7_PRODUTO+(cAliasSC7)->C7_NUMSC+(cAliasSC7)->C7_ITEMSC
					If SC1->(MsSeek(cSeekC1))
						While !SC1->(EOF()) .And. (SC1->(C1_FILIAL+C1_PRODUTO+C1_NUM+C1_ITEM) == cSeekC1) .Or. ;
								(SC1->(C1_FILIAL+C1_PRODUTO+C1_NUM+C1_ITEM) == xFilial("SC1")+CNB->(CNB_PRODUT+CNB_NUMSC+CNB_ITEMSC)) //-- Atualiza acumulado das SCs atendidas pelo pedido da medicao
								
								MaAvalSC("SC1",6,,"SC7")
					
							SC1->(dbSkip())
						EndDo	
					EndIf
					
				ElseIf !Empty((cAliasSC7)->C7_CODED) //-- Pedido de edital
					SC1->(dbOrderNickName("GCP01"))
					cFilSC1 := xFilial("SC1",(cAliasSC7)->C7_FISCORI)
				  	SC1->(dbSeek(cFilSC1+(cAliasSC7)->(C7_CODED+C7_NUMPR+C7_PRODUTO)))
				  	While !SC1->(EOF()) .And. SC1->(C1_FILIAL+C1_CODED+C1_NUMPR+C1_PRODUTO) == xFilial("SC1")+(cAliasSC7)->(C7_CODED+C7_NUMPR+C7_PRODUTO)
				  		//-- Atualiza acumulado das SCs atendidas pelo pedido do edital
						MaAvalSC("SC1",6,,"SC7")
											
						SC1->(dbSkip())
					End
				EndIf
			Else
				dbSelectArea("SC3")
				dbSetOrder(3)          
				If ( MsSeek(xFilial("SC3")+(cAliasSC7)->C7_PRODUTO+(cAliasSC7)->C7_NUMSC+(cAliasSC7)->C7_ITEMSC,.F.) )
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Ponto de entrada para impedir o encerramento do Contrato de Parceria ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ExistBlock("MT125ENC")
						lEncSC3 := ExecBlock("MT125ENC",.F.,.F.,{nEvento,cAliasSC7})
					EndIf
					If lEncSC3
						RecLock("SC3",.F.)
						SC3->C3_QUJE  += (cAliasSC7)->C7_QTDSOL
						SC3->C3_ENCER := IIf(SC3->C3_QUANT - SC3->C3_QUJE > 0," ","E")
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	If (cAliasSC7)->C7_RESIDUO <> "S"
		If lIncSA5
			dbSelectArea("SB1")
			dbSetOrder(1)
			MsSeek(xFilial("SB1")+(cAliasSC7)->C7_PRODUTO)
			
			AtuSA5((cAliasSC7)->C7_FORNECE,(cAliasSC7)->C7_LOJA,(cAliasSC7)->C7_PRODUTO,lIncRef)
			If !Empty(SB1->B1_GRUPO)
				dbSelectArea("SBM")
 				dbSetOrder( 1 )
				If dbSeek(xFilial("SBM")+SB1->B1_GRUPO)
					dbSelectArea("SAD")
					dbSetOrder(1)
					If !MsSeek(xFilial("SAD")+(cAliasSC7)->C7_FORNECE+(cAliasSC7)->C7_LOJA+SB1->B1_GRUPO,.F.)
						RecLock("SAD",.T.)
						SAD->AD_FILIAL	:= xFilial("SAD")
						SAD->AD_FORNECE := (cAliasSC7)->C7_FORNECE
						SAD->AD_LOJA    := (cAliasSC7)->C7_LOJA
						SAD->AD_NOMEFOR := SA2->A2_NOME
						SAD->AD_GRUPO   := SB1->B1_GRUPO
						SAD->AD_NOMGRUP := SBM->BM_DESC
						MsUnlock()
					EndIf
				EndIf
			EndIf
		EndIf
		
		If !Empty((cAliasSC7)->C7_SEQMRP) .And. !lAcumulados .And. Type("aPeriodos") == "A"
			If IsInCallStack("MATA710")
				A711CriSH5(SC7->C7_DATPRF,SC7->C7_PRODUTO,CriaVar("C2_OPC",.F.),Space(Len(SB1->B1_REVATU)),"SC7",SC7->(Recno()),SC7->C7_NUM,SC7->C7_ITEM,SC7->C7_OP,Max(0,SC7->C7_QUANT-SC7->C7_QUJE),"2",.T.,nil,nil,.T.)
			ElseIf IsInCallStack("MATA712")
				A712CriCZI(SC7->C7_DATPRF,SC7->C7_PRODUTO,CriaVar("C2_OPC",.F.),Space(Len(SB1->B1_REVATU)),"SC7",SC7->(Recno()),SC7->C7_NUM,SC7->C7_ITEM,SC7->C7_OP,Max(0,SC7->C7_QUANT-SC7->C7_QUJE),"2",.T.,/*13*/,/*14*/,.F.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza os arquivos do SIGAPMS                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If GetMV("MV_INTPMS",,"N") == "S"
			PMSWritePC(1,cAliasSC7)
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If AllTrim( Upper( ProcName(1) ) ) # "MA215PROC"
			If (cAliasSC7)->C7_TIPO != 2
				If Empty((cAliasSC7)->C7_NUMCOT)
					If ( IsInCallStack("GCPA011") .Or. IsInCallStack("GCPXGerPed") ) .And. Type('aRatCTBPC') == 'A'
						If Len(aRatCTBPC) == 0			//So efetua lancamento se nao houver rateio 
			   		   		LancaPCO("SC7","000052","07","MATA121")
			  	   		EndIf
					Else
						LancaPCO("SC7","000052","01","MATA121")
					EndIf
				   
					If lLast
						LancaPCO("SC7","000052","03","MATA121")
					EndIf
				Else
					If !lAltera
						LancaPCO("SC7","000052","02","MATA121")
					Else
						LancaPCO("SC7","000052","01","MATA121")
					EndIf
				Endif
			Else
				If Empty((cAliasSC7)->C7_NUMCOT)
					LancaPCO("SC7","000053","01","MATA122")
					If lLast
						LancaPCO("SC7","000053","03","MATA122")
					EndIf
				Else                
					LancaPCO("SC7","000053","02","MATA122")
				Endif
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno de um pedido de Compra                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 2
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza as tabelas auxiliares                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4",(cAliasSC7)->C7_FILIAL)+(cAliasSC7)->C7_TES)
	If Empty((cAliasSC7)->C7_TES) .Or. SF4->F4_ESTOQUE == "S" .Or. (lDHQInDic .And. SF4->F4_EFUTUR == "1")  // Compra com entrega futura.
		
		dbSelectArea("SB2")
		dbSetOrder(1)
		If ( !MsSeek(cEntrega+(cAliasSC7)->C7_PRODUTO+(cAliasSC7)->C7_LOCAL) )
			CriaSB2((cAliasSC7)->C7_PRODUTO,(cAliasSC7)->C7_LOCAL,cEntrega)
		EndIf
		If (cAliasSC7)->C7_RESIDUO <> "S"
			If lSb1TES
				If (cAliasSC7)->C7_ESTOQUE == "S" .Or. Empty((cAliasSC7)->C7_ESTOQUE)
					GravaB2Pre("-",(cAliasSC7)->C7_QUANT-(cAliasSC7)->C7_QUJE,(cAliasSC7)->C7_TPOP,((cAliasSC7)->C7_QUANT-(cAliasSC7)->C7_QUJE)*(cAliasSC7)->C7_QTSEGUM/(cAliasSC7)->C7_QUANT)
				EndIf
			Else
				GravaB2Pre("-",(cAliasSC7)->C7_QUANT-(cAliasSC7)->C7_QUJE,(cAliasSC7)->C7_TPOP,((cAliasSC7)->C7_QUANT-(cAliasSC7)->C7_QUJE)*(cAliasSC7)->C7_QTSEGUM/(cAliasSC7)->C7_QUANT)
			Endif
		Endif
	EndIf
	
	If !lAcumulados
		If ( !Empty((cAliasSC7)->C7_NUMSC) ) //-- Pedido com SC vinculada
			If ( (cAliasSC7)->C7_TIPO == 1 .Or. (cAliasSC7)->C7_TIPO == 3 )
				CN9->(dbSetOrder(1))
				SC1->(dbSetOrder(5))
				If !Empty((cAliasSC7)->C7_MEDICAO) .And. CN9->(dbSeek(xFilial("CN9")+(cAliasSC7)->(C7_CONTRA+C7_CONTREV))) .And. !Empty(CN9->CN9_NUMCOT)
					CNB->(dbSeek(xFilial("CNB")+(cAliasSC7)->(C7_CONTRA+C7_CONTREV+C7_PLANILH+C7_ITEMED)))					
					SC1->(dbSeek(xFilial("SC1")+CN9->CN9_NUMCOT+CNB->(CNB_PRODUT+CNB_IDENT)))
					While !SC1->(EOF()) .And. SC1->(C1_FILIAL+C1_COTACAO+C1_PRODUTO+C1_IDENT) == xFilial("SC1")+CN9->CN9_NUMCOT+CNB->(CNB_PRODUT+CNB_IDENT)
						//-- Atualiza acumulado das SCs atendidas pelo pedido da medicao
						MaAvalSC("SC1",7,,cAliasSC7,,,lPCExCot)
						
						SC1->(dbSkip())
					End	
				ElseIf !Empty( (cAliasSC7)->C7_NUMSC ) .And. !Empty((cAliasSC7)->C7_CODED) .And. !Empty((cAliasSC7)->C7_NUMPR) //-- Se possui SC e vindo do edital, atualiza relacionamento com SCs				
					CNB->(dbSeek(xFilial("CNB")+(cAliasSC7)->(C7_CONTRA+C7_CONTREV+C7_PLANILH+C7_ITEMED)))
					
					SC1->(dbSetOrder(2))
					cFilSC1 := xFilial("SC1",(cAliasSC7)->C7_FISCORI)
					cSeekC1 := cFilSC1+(cAliasSC7)->C7_PRODUTO+(cAliasSC7)->C7_NUMSC+(cAliasSC7)->C7_ITEMSC
					If SC1->(MsSeek(cSeekC1))
						While !SC1->(EOF()) .And. SC1->(C1_FILIAL+C1_PRODUTO+C1_NUM+C1_ITEM) == cSeekC1
							//-- Atualiza acumulado das SCs atendidas pelo pedido da medicao
							MaAvalSC("SC1",7,,cAliasSC7,,,lPCExCot)
							SC1->(dbSkip())
						Enddo
					Endif
				ElseIf !Empty((cAliasSC7)->C7_NUMSC) //-- Se possui SC, atualiza relacionamento com SCs
					CNB->(dbSeek(xFilial("CNB")+(cAliasSC7)->(C7_CONTRA+C7_CONTREV+C7_PLANILH+C7_ITEMED)))
					
					SC1->(dbSetOrder(2))
					cFilSC1 := xFilial("SC1",(cAliasSC7)->C7_FISCORI)
					cSeekC1 := cFilSC1+(cAliasSC7)->C7_PRODUTO+(cAliasSC7)->C7_NUMSC+(cAliasSC7)->C7_ITEMSC
					If SC1->(MsSeek(cSeekC1))
						While !SC1->(EOF()) .And. SC1->(C1_FILIAL+C1_PRODUTO+C1_NUM+C1_ITEM) == cSeekC1
							//-- Atualiza acumulado das SCs atendidas pelo pedido da medicao
							MaAvalSC("SC1",7,,cAliasSC7,,,lPCExCot)
							SC1->(dbSkip())
						Enddo
					Endif
				EndIf
			Else
				dbSelectArea("SC3")
				dbSetOrder(3)
				If ( MsSeek(xFilial("SC3")+(cAliasSC7)->C7_PRODUTO+(cAliasSC7)->C7_NUMSC+(cAliasSC7)->C7_ITEMSC,.F.) )
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Ponto de entrada para impedir o encerramento do Contrato de Parceria ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ExistBlock("MT125ENC")
						lEncSC3 := ExecBlock("MT125ENC",.F.,.F.,{nEvento,cAliasSC7})
					EndIf
					If lEncSC3
						RecLock("SC3",.F.)
						SC3->C3_QUJE  := IIf((cAliasSC7)->C7_QTDSOL > SC3->C3_QUJE,0,SC3->C3_QUJE - (cAliasSC7)->C7_QTDSOL)
						SC3->C3_ENCER := IIf(SC3->C3_QUANT - SC3->C3_QUJE > 0," ","E")
					EndIf
				EndIf
			EndIf
		ElseIf !Empty((cAliasSC7)->C7_CODED) //-- Pedido gerado por edital, volta SCs
			SC1->(dbOrderNickName("GCP01"))
			cFilSC1 := xFilial("SC1",(cAliasSC7)->C7_FISCORI)
			SC1->(dbSeek(cFilSC1+(cAliasSC7)->(C7_CODED+C7_NUMPR+C7_PRODUTO)))
			While !SC1->(EOF()) .And. SC1->(C1_FILIAL+C1_CODED+C1_NUMPR+C1_PRODUTO) == xFilial("SC1")+(cAliasSC7)->(C7_CODED+C7_NUMPR+C7_PRODUTO)
				MaAvalSC("SC1",7,,cAliasSC7,,,lPCExCot)
				SC1->(dbSkip())
			End
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza os arquivos do SIGAPMS                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If GetMV("MV_INTPMS",,"N") == "S"
		PMSWritePC(2,cAliasSC7)
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Exclusao de um Pedido de Compra                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 3
	If !Empty((cAliasSC7)->C7_ACCNUM)
		lRestCot := .T.
	EndIf

	If ( !Empty((cAliasSC7)->C7_NUMSC) ) .And. lContinua //-- Pedido com SC vinculada
		If ( (cAliasSC7)->C7_TIPO == 1 .Or. (cAliasSC7)->C7_TIPO == 3 )
			If !( Empty((cAliasSC7)->C7_NUMCOT) ) //-- Pedido gerado por cotacao
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza as tabelas auxiliares                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lAcumulados
					
					If lRestCot
						dbSelectArea("SC8")
						dbSetOrder(1)
						
						aRecnoSC8 := {}
					
						SC8->( dbCommit() )
						
						cAliasSC8 := GetNextAlias()
						
						cQuery := "SELECT C8_FILIAL,C8_NUM,C8_NUMPED,C8_PRODUTO,C8_ITEM,C8_IDENT, SC8.R_E_C_N_O_ SC8RECNO "
						cQuery += "FROM "+RetSqlName("SC8")+" SC8 "
						cQuery += "WHERE "
						cQuery += "C8_FILIAL ='" + xFilial( "SC8", (cAliasSC7)->C7_FISCORI )   + "' AND "
						cQuery += "C8_NUM ='" + ( cAliasSC7 )->C7_NUMCOT   + "' AND "
						cQuery += "((C8_NUMPED = 'XXXXXX' AND C8_ITEMPED = 'XXXX') OR (C8_NUMPED = '"+( cAliasSC7 )->C7_NUM+"' AND "
						cQuery += "C8_ITEMPED ='" + ( cAliasSC7 )->C7_ITEM    + "')) AND "
						cQuery += "C8_PRODUTO ='" + ( cAliasSC7 )->C7_PRODUTO    + "' AND "
						cQuery += "C8_FILENT   = '" +(cAliasSC7)->C7_FILENT +"' AND "
						cQuery += "D_E_L_E_T_=' '"
						
						cQuery := ChangeQuery( cQuery )
						
						dbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), cAliasSC8, .F.,.T. )
						
						//obtem o numero do item da cotação
						While !( cAliasSC8 )->( Eof() )
							If (cAliasSC8)->C8_NUMPED == (cAliasSC7)->C7_NUM
								cSC8Ident := (cAliasSC8)->C8_IDENT 
								Exit
							EndIf                                
							(cAliasSC8)->( dbSkip() )
						EndDo
														
						(cAliasSC8)->( dbEval( ;
							{|| AAdd( aRecnoSC8, ( cAliasSC8 )->SC8RECNO ) } ,; //ação
							{|| (cAliasSC8)->C8_IDENT == cSC8Ident}) )//condição

						If Len(aRecnoSC8)==0
							   lRestCot := .F.
						EndIf
						( cAliasSC8 )->( dbCloseArea() )
						dbSelectArea("SC8")
						dbSetOrder(3)
						MsSeek(xFilial("SC8",(cAliasSC7)->C7_FISCORI)+(cAliasSC7)->C7_NUMCOT+(cAliasSC7)->C7_PRODUTO+(cAliasSC7)->C7_FORNECE+(cAliasSC7)->C7_LOJA+(cAliasSC7)->C7_NUM+(cAliasSC7)->C7_ITEM)

						dbSelectArea("SCE")
						dbSetOrder(1)
						If MsSeek(xFilial("SCE",(cAliasSC7)->C7_FISCORI)+SC8->C8_NUM+SC8->C8_ITEM+SC8->C8_PRODUTO+SC8->C8_FORNECE+SC8->C8_LOJA)
							RecLock("SCE",.F.,.T.)
							dbDelete()
							MsUnlock()
						EndIf
					Else
						dbSelectArea("SC8")
						dbSetOrder(3)
						If MsSeek(xFilial("SC8",(cAliasSC7)->C7_FISCORI)+(cAliasSC7)->C7_NUMCOT+(cAliasSC7)->C7_PRODUTO+(cAliasSC7)->C7_FORNECE+(cAliasSC7)->C7_LOJA+(cAliasSC7)->C7_NUM+(cAliasSC7)->C7_ITEM)
							RecLock("SC8",.F.,.T.)
							SC8->C8_OBS := STR0003 //"P.C. Cancel., S.C. Estornada"
							MsUnlock()
						Endif
					EndIf
					
					dbSelectArea("SC1")
					dbSetOrder(2)
					MsSeek(xFilial("SC1",(cAliasSC7)->C7_FISCORI)+SC8->C8_NUMSC+SC8->C8_PRODUTO+SC8->C8_ITEMSC)
					While ( !Eof() .And. xFilial("SC1",(cAliasSC7)->C7_FISCORI) == SC1->C1_FILIAL .And.;
							SC8->C8_NUMSC     == SC1->C1_NUM .And.;
							SC8->C8_PRODUTO == SC1->C1_PRODUTO .And.;
							SC8->C8_ITEMSC   == SC1->C1_ITEM )
						aadd(aEstSC1,RecNo())
						// Estorno lancamentos SIGAPCO - Rateio da SC
						SCX->(dbSetOrder(1))
						If SCX->(MsSeek(xFilial("SCX")+SC1->(C1_NUM+C1_ITEM)))
							While SCX->(!Eof()) .And. SCX->(CX_FILIAL+CX_SOLICIT+CX_ITEMSOL) == xFilial("SC1")+SC1->(C1_NUM+C1_ITEM)
								LancaPCO("SC7","000051","03","MATA121",.T.)
								SCX->(DbSkip())
							End
						EndIf
						dbSelectArea("SC1")
						dbSkip()
					EndDo
					
					For nX := 1 To Len(aEstSC1)
						SC1->(MsGoto(aEstSC1[nX]))
						
						MaAvalSC("SC1",7,"SC8",cAliasSC7,,,lPCExCot)
						If SC7->C7_QTDSOL == 0
							Exit
						EndIf
					Next nX
					
                    If lRestCot
						For nX := 1 to Len( aRecnoSC8 )
							SC8->( msGoto( aRecnoSC8[ nX ] ) )
							If cSC8Ident == SC8->C8_IDENT .Or. lLast
		 						RecLock("SC8",.F.,.T.)
							
								SC8->C8_NUMPED  := ""
								SC8->C8_ITEMPED := ""
								SC8->C8_MOTIVO  := ""
								If SC8->(FieldPos("C8_MARKAUD")) > 0
									SC8->C8_MARKAUD  := .F.
								EndIf
								MsUnlock()
						  		PcoDetLan("000052","02","MATA121",.T.)  
							EndIf
						Next nX
                    EndIf
				EndIf
			EndIf
		EndIf
	ElseIf !Empty((cAliasSC7)->C7_CODED) //-- Pedido gerado por edital, volta SCs
		SC1->(dbOrderNickName("GCP01"))
		cFilSC1 := xFilial("SC1",(cAliasSC7)->C7_FISCORI)
		SC1->(dbSeek(cFilSC1+(cAliasSC7)->(C7_CODED+C7_NUMPR+C7_PRODUTO)))
		While !SC1->(EOF()) .And. SC1->(C1_FILIAL+C1_CODED+C1_NUMPR+C1_PRODUTO) == xFilial("SC1")+(cAliasSC7)->(C7_CODED+C7_NUMPR+C7_PRODUTO)
			MaAvalSC("SC1",7,,cAliasSC7,,,lPCExCot)
			SC1->(dbSkip())
		End
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui o documento se gerado na CPM                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
		A181EXCCPM(If((cAliasSC7)->C7_TIPO == 1,'2','3'),(cAliasSC7)->C7_NUM)
		
	If !lAcumulados
		If ( lLast ) .And. lContinua
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se tem SCR gravado faz o estorno.                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SCR")
			dbSetOrder(2)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ A rotina a seguir garante o funcionamento correto na base historica dos clientes, ³
			//³ pois com a implementacao do parametro MV_AEAPROV que estende o controle de alcadas³
			//³ para a AE, em 22/07/04 foi alterada a gravacao do tipo do doc para PC e AE afim   ³
			//³ de diferenciar o tipo de doc nos arquivos SC7 e SCR sem afetar o funcionamento ant³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cTipo := "PC" 
			MsSeek(xFilial("SCR") + cTipo + (cAliasSC7)->C7_NUM)
			
			If SCR->( Eof() ) 
				cTipo := "AE" 
				MsSeek(xFilial("SCR") + cTipo + (cAliasSC7)->C7_NUM)
			EndIf 

			While !Eof() .And. SCR->CR_FILIAL+Substr(SCR->CR_NUM,1,len((cAliasSC7)->C7_NUM)) == ;
			xFilial("SCR")+Substr((cAliasSC7)->C7_NUM,1,len((cAliasSC7)->C7_NUM)) .And. SCR->CR_TIPO == cTipo 

				If SCR->CR_STATUS == "03"
					MaAlcDoc({SCR->CR_NUM, cTipo,SCR->CR_VALLIB,,,(cAliasSC7)->C7_APROV},SCR->CR_DATALIB,3)
				EndIf
				Reclock("SCR",.F.,.T.)

				If lFluig .And. !Empty(SCR->CR_FLUIG)
					CancelProcess(Val(SCR->CR_FLUIG),FWWFUserID(Val(SCR->CR_FLUIG))," cancelado por contingência!",.F.)
				EndIf

				dbDelete()
				dbSkip()
			EndDo
			
			cTipo := "IP" 
			MsSeek(xFilial("SCR") + cTipo + (cAliasSC7)->C7_NUM)
			
			While !Eof() .And. SCR->CR_FILIAL+Substr(SCR->CR_NUM,1,len((cAliasSC7)->C7_NUM)) == ;
			xFilial("SCR")+Substr((cAliasSC7)->C7_NUM,1,len((cAliasSC7)->C7_NUM)) .And. SCR->CR_TIPO == "IP" 

				If SCR->CR_STATUS == "03"
					MaAlcDoc({SCR->CR_NUM, cTipo,SCR->CR_VALLIB,,,SCR->CR_GRUPO},SCR->CR_DATALIB,3)
				Else
					//Exclui registros dos itens da alcada 
					MaAlcItEC(SCR->CR_NUM,cTipo,,,,,,3)
				EndIf
				Reclock("SCR",.F.,.T.)

				If lFluig .And. !Empty(SCR->CR_FLUIG)
					CancelProcess(Val(SCR->CR_FLUIG),FWWFUserID(Val(SCR->CR_FLUIG))," cancelado por contingência!",.F.)
				EndIf

				dbDelete()
				dbSkip()
			EndDo
		EndIf
		If ExistBlock("MT120EXC")
			ExecBlock("MT120EXC",.f.,.f.)
		Endif
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza os arquivos do SIGAPMS                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If GetMV("MV_INTPMS",,"N") == "S"
		PMSWritePC(3,cAliasSC7)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If AllTrim( Upper( ProcName(1) ) ) # "MA215PROC"	
		If (cAliasSC7)->C7_TIPO != 2
			If Empty((cAliasSC7)->C7_NUMCOT)
				If !Empty(((cAliasSC7)->C7_CODED))
		   			LancaPCO("SC7","000052","07","MATA121",.T.)
				Else
			   		LancaPCO("SC7","000052","01","MATA121",.T.)
				EndIf

				If lLast
					LancaPCO("SC7","000052","03","MATA121",.T.)
				EndIf
			Else
				LancaPCO("SC7","000052","01","MATA121",.T.)
				LancaPCO("SC7","000052","02","MATA121",.T.)
			Endif
		Else
			If Empty((cAliasSC7)->C7_NUMCOT)
				LancaPCO("SC7","000053","01","MATA122",.T.)
				If lLast
					LancaPCO("SC7","000053","03","MATA122",.T.)
				EndIf
			Else                
				LancaPCO("SC7","000053","02","MATA122",.T.)
			Endif
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de um pre-documento de entrada                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 6
	If !Empty((cAliasSD1)->D1_PEDIDO+(cAliasSD1)->D1_ITEMPC)
		dbSelectArea("SC7")
		dbSetOrder(19)
		If !(xFilial("SC7")==SC7->C7_FILENT .And. SC7->C7_NUM==(cAliasSD1)->D1_PEDIDO .And. SC7->C7_ITEM==(cAliasSD1)->D1_ITEMPC .And. SC7->C7_PRODUTO==(cAliasSD1)->D1_COD  )
			MsSeek(xFilial("SC7")+(cAliasSD1)->D1_COD+ (cAliasSD1)->D1_PEDIDO+(cAliasSD1)->D1_ITEMPC)
		EndIf
		If !(Empty(SubStr(SC7->C7_ITEM,3)) .And. !Empty(SC7->C7_SEQUEN))
			RecLock("SC7",.F.)
			SC7->C7_QTDACLA += (cAliasSD1)->D1_QUANT
		EndIf
	EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno de um pre-documento de entrada                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 7
	If !Empty((cAliasSD1)->D1_PEDIDO+(cAliasSD1)->D1_ITEMPC)
		dbSelectArea("SC7")
		dbSetOrder(19)
		If !(xFilial("SC7")==SC7->C7_FILENT .And. SC7->C7_NUM==(cAliasSD1)->D1_PEDIDO .And. SC7->C7_ITEM==(cAliasSD1)->D1_ITEMPC .And. SC7->C7_PRODUTO==(cAliasSD1)->D1_COD)
			MsSeek(xFilial("SC7")+(cAliasSD1)->D1_COD+ (cAliasSD1)->D1_PEDIDO+(cAliasSD1)->D1_ITEMPC)
		EndIf
		If !(Empty(SubStr(SC7->C7_ITEM,3)) .And. !Empty(SC7->C7_SEQUEN))
			RecLock("SC7",.F.)
			SC7->C7_QTDACLA -= (cAliasSD1)->D1_QUANT
		EndIf		
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de um documento de entrada                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 8
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza dados do Pedido de Compra/Autorizacao de Entrega³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty((cAliasSD1)->D1_PEDIDO+(cAliasSD1)->D1_ITEMPC)
		dbSelectArea("SC7")
		dbSetOrder(19)
		If !(xFilial("SC7")==SC7->C7_FILENT .And. SC7->C7_NUM==(cAliasSD1)->D1_PEDIDO .And. SC7->C7_ITEM==(cAliasSD1)->D1_ITEMPC .And. SC7->C7_PRODUTO==(cAliasSD1)->D1_COD )
			MsSeek(xFilial("SC7")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_PEDIDO+(cAliasSD1)->D1_ITEMPC)
		EndIf
		If !(Empty(SubStr(SC7->C7_ITEM,3)) .And. !Empty(SC7->C7_SEQUEN))
			RecLock("SC7",.F.)
			SC7->C7_QUJE 	+= SD1->D1_QTDPEDI
			SC7->C7_ENCER 	:= IIF(C7_QUANT-C7_QUJE>0," ","E")
			dbSelectArea("SB2")
			dbSetOrder(1)
			If !(cEntrega==SB2->B2_FILIAL .And. SC7->C7_PRODUTO==SB2->B2_COD .And. SC7->C7_LOCAL==SB2->B2_LOCAL)
				If !MsSeek(cEntrega+SC7->C7_PRODUTO+SC7->C7_LOCAL)
					CriaSB2(SC7->C7_PRODUTO,SC7->C7_LOCAL,cEntrega)
				EndIf
			EndIf
			RecLock("SB2",.F.)
			
			If lSb1TES .And. !Empty((cAliasSC7)->C7_NUMSC)
				SC1->(dbSetOrder(2))
				SC1->(MsSeek(xFilial("SC1")+SC7->C7_PRODUTO+SC7->C7_NUMSC))				
				
				If (SF4->F4_ESTOQUE=="S" .And. SC1->C1_ESTOQUE=="S") .Or. (SF4->F4_ESTOQUE=="S" .And. Empty(SC1->C1_ESTOQUE))
					SB2->B2_SALPEDI -= SD1->D1_QTDPEDI
					SB2->B2_SALPED2 -= ConvUm(SD1->D1_COD,SD1->D1_QTDPEDI,0,2)
				EndIf
			Else
				// Verifica se TES do pedido atualiza estoque. Se estiver em branco tambem atualiza o saldo previsto.
				dbSelectArea("SF4")
				dbSetOrder(1)
				MsSeek(xFilial("SF4")+(cAliasSC7)->C7_TES)
				If Empty((cAliasSC7)->C7_TES) .Or. SF4->F4_ESTOQUE=="S" .Or. (lDHQInDic .And. SF4->F4_EFUTUR == "1")  // Compra com entrega futura.
					SB2->B2_SALPEDI -= SD1->D1_QTDPEDI
					SB2->B2_SALPED2 -= ConvUm(SD1->D1_COD,SD1->D1_QTDPEDI,0,2)
				EndIf
			EndIf 
			 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o arquivo de pre-requisicoes.                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nQtdALib := SD1->D1_QUANT
			dbSelectArea("SCQ")
			dbSetOrder(2)					

			cAliasSCQ := "MAAVALSD1"
			lQuery    := .T.
			lQSC1	  := .F.
			Do Case
			Case !Empty(SC7->C7_NUMCOT)
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "
				cQuery += RetSqlName("DHN")+" DHN, "
				cQuery += RetSqlName("SC1")+" SC1 "
				SC1->(dBSetOrder(1))
				If SC1->(dBSeek(SC7->C7_FISCORI+SC7->C7_NUMSC+SC7->C7_ITEMSC)) 				
					cQuery += "WHERE SC1.C1_FILIAL='"+SC7->C7_FISCORI+"' AND "
					lQSC1	  := .T.
				Else
					cQuery += "WHERE SC1.C1_FILIAL='"+xFilial("SC1")+"' AND "
				EndIf
				cQuery += "SC1.C1_COTACAO='"+SC7->C7_NUMCOT+"' AND "
				cQuery += "SC1.C1_PRODUTO='"+SC7->C7_PRODUTO+"' AND "
				cQuery += "SC1.D_E_L_E_T_=' ' AND "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				If lQSC1
					cQuery += "DHN.DHN_FILORI = '" + xFilial("DHN") + "' AND "
				Else
					cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				EndIf
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '1' AND "
				If lQSC1
					If SC1->C1_OBS=='SC gerada por SA              '
						cQuery += "DHN.DHN_DOCDES = SC1.C1_SCORI AND "
						cQuery += "DHN.DHN_ITDES = SC1.C1_ITSCORI AND "					
					Else				
						cQuery += "DHN.DHN_DOCDES = SC1.C1_NUM AND "
						cQuery += "DHN.DHN_ITDES = SC1.C1_ITEM AND "
					EndIf
				Else
					cQuery += "DHN.DHN_DOCDES = SC1.C1_NUM AND "
					cQuery += "DHN.DHN_ITDES = SC1.C1_ITEM AND "				
				EndIf
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_QUANT > SCQ.CQ_QTDISP AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
				cQuery += "ORDER BY SC1.C1_FILIAL,SC1.C1_DATPRF "
			Case SC7->C7_TIPO == 2
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "
				cQuery += RetSqlName("DHN")+" DHN " 
				cQuery += "WHERE "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '3' AND "
				cQuery += "DHN.DHN_DOCDES = '"+SC7->C7_NUM+"'  AND "
				cQuery += "DHN.DHN_ITDES = '"+SC7->C7_ITEM+"' AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_QUANT > SCQ.CQ_QTDISP AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
			OtherWise
				
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "	
				cQuery += RetSqlName("DHN")+" DHN, "	
				cQuery += RetSqlName("SC1")+" SC1 "
				cQuery += "WHERE SC1.C1_FILIAL='"+xFilial("SC1")+"' AND "
				cQuery += "SC1.C1_NUM='"+SC7->C7_NUMSC+"' AND "
				cQuery += "SC1.C1_ITEM='"+SC7->C7_ITEMSC+"' AND "					
				cQuery += "SC1.C1_PRODUTO='"+SC7->C7_PRODUTO+"' AND "
				cQuery += "SC1.D_E_L_E_T_=' ' AND "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '1' AND "
				cQuery += "DHN.DHN_DOCDES = SC1.C1_NUM AND "
				cQuery += "DHN.DHN_ITDES = SC1.C1_ITEM AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_QUANT > SCQ.CQ_QTDISP AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
				cQuery += "ORDER BY SC1.C1_FILIAL,SC1.C1_DATPRF "					
			EndCase
			
			cQuery := ChangeQuery(cQuery)
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSCQ)
			
			dbSelectArea(cAliasSCQ)										
			While !Eof()
				If nQtdALib > 0
					SCQ->(MsGoto((cAliasSCQ)->SCQRECNO))
					If !Localiza(SCQ->CQ_PRODUTO)
						RecLock("SCQ",.F.)
						nQtdLib := Min(SCQ->CQ_QUANT-SCQ->CQ_QTDISP,nQtdALib)
						nQtdALib-= nQtdLib
						SCQ->CQ_QTDISP += nQtdLib
						SCQ->CQ_STATUSC:= ""
						dbSelectArea("SB2")
						dbSetOrder(1)
						MsSeek(cEntrega+SCQ->CQ_PRODUTO+SCQ->CQ_LOCAL)
						Reclock("SB2",.F.)
						SB2->B2_QEMPSA += nQtdLib
					EndIf	
				Else
					Exit
				EndIf
				dbSelectArea(cAliasSCQ)
				dbSkip()
			EndDo
			If lQuery
				dbSelectArea(cAliasSCQ)
				dbCloseArea()
				dbSelectArea("SCQ")
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			LancaPCO("SC7","000054","15","MATA103")
			If lLast
				LancaPCO("SC7","000054","17","MATA103")
			EndIf
		EndIf
	EndIf
	
	// Efetua liberação do pedido de vendas, amarrado a solicitação de compras
	aArea2:= getarea()
	aAreaSC1:=  SC1->(getarea())
	aAreaSC6:=  SC6->(getarea())
	dbSelectArea("SC1")
	dbSetOrder(1)  //
	If MsSeek(xFilial("SC1")+(cAliasSC7)->C7_NUMSC+(cAliasSC7)->C7_ITEMSC)
			dbSelectArea("SC6")
			dbSetOrder(12)   //Filial + Ped. Venda + Produto + Sol.Compra
			If MsSeek(xFilial("SC6")+SC1->C1_PEDRES+SC1->C1_PRODUTO+SC1->C1_NUM)
				Ma410LbNfs(2,Nil,Nil)
				RecLock("SC6",.F.)
				Replace SC6->C6_QTDLIB With (SC6->C6_QTDLIB + SC7->C7_QUJE)
				MsUnlock()
				AtuSC5(SC1->C1_PEDRES)
			Endif
	Endif
	restarea(aAreaSC6)
	restarea(aAreaSC1)
	restarea(aArea2)
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno de um documento de entrada                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 9
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorna dados do Pedido de Compra/Autorizacao de Entrega ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty((cAliasSD1)->D1_PEDIDO+(cAliasSD1)->D1_ITEMPC)		
		dbSelectArea("SC7")
		dbSetOrder(19)
		If !(xFilial("SC7")==SC7->C7_FILENT .And. SC7->C7_NUM==(cAliasSD1)->D1_PEDIDO .And. SC7->C7_ITEM==(cAliasSD1)->D1_ITEMPC .And. SC7->C7_PRODUTO==(cAliasSD1)->D1_COD )
			MsSeek(xFilial("SC7")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_PEDIDO+(cAliasSD1)->D1_ITEMPC)
		EndIf
		If !(Empty(SubStr(SC7->C7_ITEM,3)) .And. !Empty(SC7->C7_SEQUEN))
			RecLock("SC7",.F.)
			If !Empty(SC7->C7_RESIDUO)
				nQuantRes	:= (SC7->C7_QUANT - SC7->C7_QUJE)
			EndIf
			SC7->C7_QUJE 	-= SD1->D1_QTDPEDI            
			SC7->C7_ENCER 	:= ""
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o Saldo em Pedido do SB2                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB2")
			dbSetOrder(1)
			If !(cEntrega==SB2->B2_FILIAL .And. SC7->C7_PRODUTO==SB2->B2_COD .And.SC7->C7_LOCAL==SB2->B2_LOCAL)
				If !MsSeek(cEntrega+SC7->C7_PRODUTO+SC7->C7_LOCAL)
					CriaSB2(SC7->C7_PRODUTO,SC7->C7_LOCAL,cEntrega)
				Endif
			EndIf
			If !SB2->(Eof())
				RecLock("SB2",.F.)
				If !Empty(SC7->C7_RESIDUO) 
					SC7->C7_RESIDUO	:= ""
					If SF4->F4_ESTOQUE=="S" //Atualiza se TES movimentar o Estoque
						SB2->B2_SALPEDI += SD1->D1_QTDPEDI + nQuantRes
						SB2->B2_SALPED2 += ConvUm(SD1->D1_COD,(SD1->D1_QTDPEDI + nQuantRes),0,2)	
					EndIf
				Else       
					If lSb1TES .And. !Empty((cAliasSC7)->C7_NUMSC)
						SC1->(dbSetOrder(2))
						SC1->(MsSeek(xFilial("SC1")+SC7->C7_PRODUTO+SC7->C7_NUMSC))				
						If (SF4->F4_ESTOQUE=="S" .And. SC1->C1_ESTOQUE=="S") .Or. (SF4->F4_ESTOQUE=="S" .And. Empty(SC1->C1_ESTOQUE))
							SB2->B2_SALPEDI += SD1->D1_QTDPEDI
							SB2->B2_SALPED2 += ConvUm(SD1->D1_COD,SD1->D1_QTDPEDI,0,2)
						EndIf
					Else
						// Verifica se TES do pedido atualiza estoque. Se estiver em branco tambem atualiza o saldo previsto.
						dbSelectArea("SF4")
						dbSetOrder(1)
						MsSeek(xFilial("SF4")+(cAliasSC7)->C7_TES)
						If Empty((cAliasSC7)->C7_TES) .Or. SF4->F4_ESTOQUE=="S" .Or. (lDHQInDic .And. SF4->F4_EFUTUR == "1")  // Compra com entrega futura.
							SB2->B2_SALPEDI += SD1->D1_QTDPEDI
							SB2->B2_SALPED2 += ConvUm(SD1->D1_COD,SD1->D1_QTDPEDI,0,2)
						EndIf
					EndIf
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Estorna o arquivo de pre-requisicoes.                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nQtdALib := SD1->D1_QUANT
			dbSelectArea("SCQ")
			dbSetOrder(2)

			cAliasSCQ := "MAAVALSD1"
			lQuery    := .T.
			Do Case
			Case !Empty(SC7->C7_NUMCOT)
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "
				cQuery += RetSqlName("DHN")+" DHN, "
				cQuery += RetSqlName("SC1")+" SC1 "
				cQuery += "WHERE SC1.C1_FILIAL='"+xFilial("SC1")+"' AND "
				cQuery += "SC1.C1_COTACAO='"+SC7->C7_NUMCOT+"' AND "
				cQuery += "SC1.C1_PRODUTO='"+SC7->C7_PRODUTO+"' AND "
				cQuery += "SC1.D_E_L_E_T_=' ' AND "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '1' AND "
				cQuery += "DHN.DHN_DOCDES = SC1.C1_NUM AND "
				cQuery += "DHN.DHN_ITDES = SC1.C1_ITEM AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
				cQuery += "ORDER BY SC1.C1_FILIAL,SC1.C1_DATPRF "
			Case SC7->C7_TIPO == 2
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "
				cQuery += RetSqlName("DHN")+" DHN "
				cQuery += "WHERE "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '3' AND "
				cQuery += "DHN.DHN_DOCDES = '"+SC7->C7_NUM+"' AND "
				cQuery += "DHN.DHN_ITDES = '"+SC7->C7_ITEM+"' AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
			OtherWise
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "	
				cQuery += RetSqlName("DHN")+" DHN, "	
				cQuery += RetSqlName("SC1")+" SC1 "
				cQuery += "WHERE SC1.C1_FILIAL='"+xFilial("SC1")+"' AND "
				cQuery += "SC1.C1_NUM='"+SC7->C7_NUMSC+"' AND "
				cQuery += "SC1.C1_ITEM='"+SC7->C7_ITEMSC+"' AND "					
				cQuery += "SC1.C1_PRODUTO='"+SC7->C7_PRODUTO+"' AND "
				cQuery += "SC1.D_E_L_E_T_=' ' AND "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '1' AND "
				cQuery += "DHN.DHN_DOCDES = SC1.C1_NUM AND "
				cQuery += "DHN.DHN_ITDES = SC1.C1_ITEM AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
				cQuery += "ORDER BY SC1.C1_FILIAL,SC1.C1_DATPRF "					
			EndCase
			
			cQuery := ChangeQuery(cQuery)
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSCQ)
			
			dbSelectArea(cAliasSCQ)										
			While !Eof()
				If nQtdALib > 0
					SCQ->(MsGoto((cAliasSCQ)->SCQRECNO))
					If !Localiza(SCQ->CQ_PRODUTO)
						RecLock("SCQ",.F.)
						nQtdLib := Min(SCQ->CQ_QTDISP,nQtdALib)
						nQtdALib-= nQtdLib
						SCQ->CQ_QTDISP -= nQtdLib
						SCQ->CQ_STATUSC:= ""
						dbSelectArea("SB2")
						dbSetOrder(1)
						MsSeek(cEntrega+SCQ->CQ_PRODUTO+SCQ->CQ_LOCAL)
						Reclock("SB2",.F.)
						SB2->B2_QEMPSA -= nQtdLib
					EndIf	
				Else
					Exit
				EndIf
				dbSelectArea(cAliasSCQ)
				dbSkip()
			EndDo
			If lQuery
				dbSelectArea(cAliasSCQ)
				dbCloseArea()
				dbSelectArea("SCQ")
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			LancaPCO("SC7","000054","16","MATA103")
			If lLast
				LancaPCO("SC7","000054","18","MATA103")
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de um documento de entrada - Average                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 10
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza dados do Pedido de Compra/Autorizacao de Entrega³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(SWN->WN_PO_NUM)
		dbSelectArea("SC7")
		dbSetOrder(1)
		If MsSeek(xFilial("SC7")+SubStr(SWN->WN_PO_NUM,1,6)+'01  '+SWN->WN_ITEM)
			RecLock("SC7",.F.)
			SC7->C7_QUJE 	+= SWN->WN_QUANT
			SC7->C7_ENCER 	:= IIF(C7_QUANT-C7_QUJE>0," ","E")
			dbSelectArea("SB2")
			dbSetOrder(1)
			If !(cEntrega==SB2->B2_FILIAL .And. SC7->C7_PRODUTO==SB2->B2_COD .And. SC7->C7_LOCAL==SB2->B2_LOCAL)
				If !MsSeek(cEntrega+SC7->C7_PRODUTO+SC7->C7_LOCAL)
					CriaSB2(SC7->C7_PRODUTO,SC7->C7_LOCAL,cEntrega)
				EndIf
			EndIf
			RecLock("SB2",.F.)
			SB2->B2_SALPEDI -= SWN->WN_QUANT
			SB2->B2_SALPED2 -= ConvUm(SWN->WN_PRODUTO,SWN->WN_QUANT,0,2)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o arquivo de pre-requisicoes.                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nQtdALib := SWN->WN_QUANT
			dbSelectArea("SCQ")
			dbSetOrder(2)

			cAliasSCQ := "MAAVALSD1"
			lQuery    := .T.
			Do Case
			Case !Empty(SC7->C7_NUMCOT)
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "
				cQuery += RetSqlName("DHN")+" DHN, "
				cQuery += RetSqlName("SC1")+" SC1 "
				cQuery += "WHERE SC1.C1_FILIAL='"+xFilial("SC1")+"' AND "
				cQuery += "SC1.C1_COTACAO='"+SC7->C7_NUMCOT+"' AND "
				cQuery += "SC1.C1_PRODUTO='"+SC7->C7_PRODUTO+"' AND "
				cQuery += "SC1.D_E_L_E_T_=' ' AND "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '1' AND "
				cQuery += "DHN.DHN_DOCDES = SC1.C1_NUM AND "
				cQuery += "DHN.DHN_ITDES = SC1.C1_ITEM AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_QUANT > SCQ.CQ_QTDISP AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
				cQuery += "ORDER BY SC1.C1_FILIAL,SC1.C1_DATPRF "
			Case SC7->C7_TIPO == 2
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "	
				cQuery += RetSqlName("DHN")+" DHN "
				cQuery += "WHERE "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '3' AND "
				cQuery += "DHN.DHN_DOCDES = '"+SC7->C7_NUM+"' AND "
				cQuery += "DHN.DHN_ITDES = '"+SC7->C7_ITEM+"' AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_QUANT > SCQ.CQ_QTDISP AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
			OtherWise
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "	
				cQuery += RetSqlName("DHN")+" DHN, "	
				cQuery += RetSqlName("SC1")+" SC1 "
				cQuery += "WHERE SC1.C1_FILIAL='"+xFilial("SC1")+"' AND "
				cQuery += "SC1.C1_NUM='"+SC7->C7_NUMSC+"' AND "
				cQuery += "SC1.C1_ITEM='"+SC7->C7_ITEMSC+"' AND "					
				cQuery += "SC1.C1_PRODUTO='"+SC7->C7_PRODUTO+"' AND "
				cQuery += "SC1.D_E_L_E_T_=' ' AND "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '1' AND "
				cQuery += "DHN.DHN_DOCDES = SC1.C1_NUM AND "
				cQuery += "DHN.DHN_ITDES = SC1.C1_ITEM AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_QUANT > SCQ.CQ_QTDISP AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
				cQuery += "ORDER BY SC1.C1_FILIAL,SC1.C1_DATPRF "					
			EndCase
			
			cQuery := ChangeQuery(cQuery)
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSCQ)
			
			dbSelectArea(cAliasSCQ)										
			While !Eof()
				If nQtdALib > 0
					SCQ->(MsGoto((cAliasSCQ)->SCQRECNO))
					If !Localiza(SCQ->CQ_PRODUTO)
						RecLock("SCQ",.F.)
						nQtdLib := Min(SCQ->CQ_QUANT-SCQ->CQ_QTDISP,nQtdALib)
						nQtdALib-= nQtdLib
						SCQ->CQ_QTDISP += nQtdLib
						SCQ->CQ_STATUSC:= ""
						dbSelectArea("SB2")
						dbSetOrder(1)
						MsSeek(cEntrega+SCQ->CQ_PRODUTO+SCQ->CQ_LOCAL)
						Reclock("SB2",.F.)
						SB2->B2_QEMPSA += nQtdLib
					EndIf	
				Else
					Exit
				EndIf
				dbSelectArea(cAliasSCQ)
				dbSkip()
			EndDo
			If lQuery
				dbSelectArea(cAliasSCQ)
				dbCloseArea()
				dbSelectArea("SCQ")
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno de um documento de entrada                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 11
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorna dados do Pedido de Compra/Autorizacao de Entrega ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(SWN->WN_PO_NUM)
		dbSelectArea("SC7")
		dbSetOrder(1)
		If MsSeek(xFilial("SC7")+SubStr(SWN->WN_PO_NUM,1,6)+'01  '+SWN->WN_ITEM)
			RecLock("SC7",.F.)
			SC7->C7_QUJE 	-= SWN->WN_QUANT
			SC7->C7_ENCER 	:= ""
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o Saldo em Pedido do SB2                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB2")
			dbSetOrder(1)
			If !(cEntrega==SB2->B2_FILIAL .And. SC7->C7_PRODUTO==SB2->B2_COD .And.SC7->C7_LOCAL==SB2->B2_LOCAL)
				If !MsSeek(cEntrega+SC7->C7_PRODUTO+SC7->C7_LOCAL)
					CriaSB2(SC7->C7_PRODUTO,SC7->C7_LOCAL,cEntrega)
				Endif
			EndIf
			If !SB2->(Eof())
				RecLock("SB2",.F.)
				SB2->B2_SALPEDI += SWN->WN_QUANT
				SB2->B2_SALPED2 += ConvUm(SWN->WN_PRODUTO,SWN->WN_QUANT,0,2)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Estorna o arquivo de pre-requisicoes.                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nQtdALib := SWN->WN_QUANT
			dbSelectArea("SCQ")
			dbSetOrder(2)

			cAliasSCQ := "MAAVALSD1"
			lQuery    := .T.
			Do Case
			Case !Empty(SC7->C7_NUMCOT)
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "
				cQuery += RetSqlName("DHN")+" DHN, "
				cQuery += RetSqlName("SC1")+" SC1 "
				cQuery += "WHERE SC1.C1_FILIAL='"+xFilial("SC1")+"' AND "
				cQuery += "SC1.C1_COTACAO='"+SC7->C7_NUMCOT+"' AND "
				cQuery += "SC1.C1_PRODUTO='"+SC7->C7_PRODUTO+"' AND "
				cQuery += "SC1.D_E_L_E_T_=' ' AND "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '1' AND "
				cQuery += "DHN.DHN_DOCDES = SC1.C1_NUM AND "
				cQuery += "DHN.DHN_ITDES = SC1.C1_ITEM AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
				cQuery += "ORDER BY SC1.C1_FILIAL,SC1.C1_DATPRF "
			Case SC7->C7_TIPO == 2
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "	
				cQuery += RetSqlName("DHN")+" DHN "
				cQuery += "WHERE "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '3' AND "
				cQuery += "DHN.DHN_DOCDES = '"+SC7->C7_NUM+"' AND "
				cQuery += "DHN.DHN_ITDES = '"+SC7->C7_ITEM+"' AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
			OtherWise
				cQuery := "SELECT SCQ.R_E_C_N_O_ SCQRECNO "
				cQuery += "FROM "+RetSqlName("SCQ")+" SCQ, "	
				cQuery += RetSqlName("DHN")+" DHN, "	
				cQuery += RetSqlName("SC1")+" SC1 "
				cQuery += "WHERE SC1.C1_FILIAL='"+xFilial("SC1")+"' AND "
				cQuery += "SC1.C1_NUM='"+SC7->C7_NUMSC+"' AND "
				cQuery += "SC1.C1_ITEM='"+SC7->C7_ITEMSC+"' AND "					
				cQuery += "SC1.C1_PRODUTO='"+SC7->C7_PRODUTO+"' AND "
				cQuery += "SC1.D_E_L_E_T_=' ' AND "
				cQuery += "SCQ.CQ_FILIAL='"+xFilial("SCQ")+"' AND "
				cQuery += "DHN.DHN_FILIAL = '" + xFilial("DHN") + "' AND "
				cQuery += "DHN.D_E_L_E_T_= ' ' AND "
				cQuery += "DHN.DHN_TIPO = '1' AND "
				cQuery += "DHN.DHN_DOCDES = SC1.C1_NUM AND "
				cQuery += "DHN.DHN_ITDES = SC1.C1_ITEM AND "
				cQuery += "DHN.DHN_DOCORI=SCQ.CQ_NUM AND "
				cQuery += "DHN.DHN_ITORI=SCQ.CQ_ITEM AND "
				cQuery += "SCQ.CQ_NUMREQ = '"+Space(Len(SCQ->CQ_NUMREQ))+"' AND "
				cQuery += "SCQ.D_E_L_E_T_=' ' "
				cQuery += "ORDER BY SC1.C1_FILIAL,SC1.C1_DATPRF "					
			EndCase
			
			cQuery := ChangeQuery(cQuery)
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSCQ)
			
			dbSelectArea(cAliasSCQ)										
			While !Eof()
				If nQtdALib > 0
					SCQ->(MsGoto((cAliasSCQ)->SCQRECNO))
					If !Localiza(SCQ->CQ_PRODUTO)
						RecLock("SCQ",.F.)
						nQtdLib := Min(SCQ->CQ_QTDISP,nQtdALib)
						nQtdALib-= nQtdLib
						SCQ->CQ_QTDISP -= nQtdLib
						SCQ->CQ_STATUSC:= ""
						dbSelectArea("SB2")
						dbSetOrder(1)
						MsSeek(cEntrega+SCQ->CQ_PRODUTO+SCQ->CQ_LOCAL)
						Reclock("SB2",.F.)
						SB2->B2_QEMPSA -= nQtdLib
					EndIf	
				Else
					Exit
				EndIf
				dbSelectArea(cAliasSCQ)
				dbSkip()
			EndDo
			If lQuery
				dbSelectArea(cAliasSCQ)
				dbCloseArea()
				dbSelectArea("SCQ")
			EndIf
		EndIf
	EndIf
EndCase
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chamada do CodeBlock de Contabilizacao                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LancaCTB(bCtbOnLine,nEvento)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a integridade da rotina                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaSF4)
RestArea(aAreaSCR)
RestArea(aArea)
Return(.T.)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaUltForn ³ Autor ³ Eduardo Riera         ³ Data ³27.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Avalia os ultimos fornecimentos de materiais ( entrada )     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpA1 := MaUltForn(ExpC1,ExpA2,ExpA3,ExpN1,ExpL1)			   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto                                     ³±±
±±³          ³ExpA2: Array de retorno dos titulos dos campos definidos em  ³±±
±±³          ³       ExpA3.                                                ³±±
±±³          ³ExpA3: Array com a estrutura dos campos a serem retornados   ³±±
±±³          ³       [1] Nome do Campo                                     ³±±
±±³          ³       [2] Tipo do campo                                     ³±±
±±³          ³       [3] Tamanho do campo                                  ³±±
±±³          ³       [4] Numero de decimais do campo                       ³±±
±±³          ³       * Somente do SD1                                      ³±±
±±³          ³ExpN1: Quantidade de ultimos fornecimentos (Default 4)       ³±±
±±³          ³ExpL1: Efetua a conversao para a picture contida no diciona- ³±±
±±³          ³       rio de dados.                                         ³±±
±±³          ³       * DEFAULT .T.                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpA1: Array contendo os ultimos fornecimentos com os campos ³±±
±±³          ³       solicitados no parametro ExpA2.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo avaliar as ultimas <ExpN1>     ³±±
±±³          ³entregas do produto <ExpC1> retornando os campos ExpA3.      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaUltForn(cProduto,aTitles,aCampos,nQtUltFor,lPicture)

Local aArea    := GetArea()
Local aAreaSD1 := SD1->(GetArea())
Local aAreaSX3 := SX3->(GetArea())
Local aUltFor  := {}
Local cAliasSD1:= ""
Local nX       := 0
Local nY	      := 0
Local cQuery := ""
DEFAULT aTitles     := {}
DEFAULT aCampos 	:= {}
DEFAULT nQtUltFor	:= 4
DEFAULT lPicture    := .T.
cAliasSD1:= "SD1"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa a estrutura default da rotina                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( Empty(aCampos) )
	dbSelectArea("SX3")
	dbSetOrder(2)
	MsSeek("D1_EMISSAO")
	aadd(aCampos,{Trim(SX3->X3_CAMPO),SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("D1_QUANT")
	aadd(aCampos,{Trim(SX3->X3_CAMPO),SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("D1_VUNIT")
	aadd(aCampos,{Trim(SX3->X3_CAMPO),SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("D1_TOTAL")
	aadd(aCampos,{Trim(SX3->X3_CAMPO),SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	If cPaisLoc == "BRA"
		MsSeek("D1_VALIPI")
		aadd(aCampos,{Trim(SX3->X3_CAMPO),SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	Endif
	MsSeek("D1_CUSTO")
	aadd(aCampos,{Trim(SX3->X3_CAMPO),SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("D1_FORNECE")
	aadd(aCampos,{Trim(SX3->X3_CAMPO),SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	MsSeek("D1_LOJA")
	aadd(aCampos,{Trim(SX3->X3_CAMPO),SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
	dbSelectArea("SX3")
	dbSetOrder(1)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Avalia os ultimos fornecimentos do material                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cAliasSD1 := "MAULTFOR"
For nX := 1 To Len(aCampos)
	cQuery += ","+aCampos[nX][1]
Next nX
cQuery := "SELECT "+SubStr(cQuery,2)+" "
cQuery += "FROM "+RetSqlName("SD1")+" SD1 "
cQuery += "WHERE SD1.D1_FILIAL='"+xFilial("SD1")+"' AND "
cQuery += "SD1.D1_COD='"+cProduto+"' AND "
cQuery += "SD1.D1_TIPO='N' AND "
cQuery += "SD1.D_E_L_E_T_=' ' "
cQuery += "ORDER BY SD1.R_E_C_N_O_ DESC "
cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD1,.T.,.T.)
For nX := 1 To Len(aCampos)
	If ( aCampos[nX][2]<>"C" )
		TcSetField(cAliasSD1,aCampos[nX,1],aCampos[nX,2],aCampos[nX,3],aCampos[nX,4])
	EndIf
Next nX

SX3->(dbSetOrder(2))
SX3->(MsSeek("A2_NOME"))
aadd(aCampos,{Trim(SX3->X3_CAMPO),SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
SX3->(dbSetOrder(1))

While ( !Eof() )
	aadd(aUltFor,Array(Len(aCampos)))
	nY++
	For nX := 1 To Len(aCampos)
		aUltFor[nY][nX] := FieldGet(FieldPos(aCampos[nX][1]))
		aUltFor[nY][Len(aCampos)] := IIF(SA2->(MsSeek(xFilial("SA2")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA)),SA2->A2_NOME,"")
	Next nX
	If ( Len(aUltFor)>=nQtUltFor )
		Exit
	EndIf			
	dbSelectArea(cAliasSD1)
	dbSkip()
EndDo	
dbSelectArea(cAliasSD1)
dbCloseArea()
dbSelectArea("SD1")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Obtem os titulos com base no dicionario de dados             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( lPicture )
	If ( Len(aUltFor) == 0 )
		aadd(aUltFor,{})
		For nX := 1 To Len(aCampos)
			aadd(aUltFor[1],"")
		Next nX
	EndIf
	dbSelectArea("SX3")
	dbSetOrder(2)
	For nX := 1 To Len(aCampos)
		MsSeek(Trim(aCampos[nX][1]))
		aadd(aTitles,X3Titulo())
		For nY := 1 To Len(aUltFor)
			aUltFor[nY][nX] := TransForm(aUltFor[nY][nX],SX3->X3_PICTURE)
		Next nY
	Next nX
EndIf
RestArea(aAreaSX3)
RestArea(aAreaSD1)
RestArea(aArea)
Return(aUltFor)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaAvCotVen³ Autor ³ Eduardo Riera         ³ Data ³27.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Avalia as cotacoes em aberto e seleciona a melhor cotacao    ³±±
±±³          ³segundo os parametros da rotina                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpA1 := MaAvCotVen(ExpA1,ExpA2,ExpA3,ExpA4,ExpL1,ExpN1, 	   ³±±
±±³  		 ³					  ExpL2,ExpL3)			 				   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array das cotacoes em aberto  ( SC8 )                 ³±±
±±³          ³    [x][01] Ok - Indica se a cotacao foi selecionada (XX)    ³±±
±±³          ³    [x][02] Codigo do fornecedor                             ³±±
±±³          ³    [x][03] Loja do fornecedor                               ³±±
±±³          ³    [x][04] Nome reduzido                                    ³±±
±±³          ³    [x][05] Numero da proposta                               ³±±
±±³          ³    [x][06] Valor presente                                   ³±±
±±³          ³    [x][07] Data de Necessidade                              ³±±
±±³          ³    [x][08] Data de Entrega                                  ³±±
±±³          ³    [x][09] Desvio                                           ³±±
±±³          ³    [x][10] Nota do Fornecedor                               ³±±
±±³          ³    [x][11] Observacao                                       ³±±
±±³          ³    [x][12]0-Cotacao pode ser selecionada automaticamente    ³±±
±±³          ³           1-Cotacao nao pode ser selecionada automaticamente³±±
±±³          ³ExpA2: Array das cotacoes em aberto  ( SC8 )                 ³±±
±±³          ³    [x][01] Nome do campo                                    ³±±
±±³          ³    [x][02] Conteudo do campo                                ³±±
±±³          ³ExpA3: Array das cotacoes vencedoras ( SCE )                 ³±±
±±³          ³       [x] Array com os produtos da Cotacao                  ³±±
±±³          ³    [x][y] Array com a estrutura do acols                    ³±±
±±³          ³ExpA4: Array com a estrutura do aheader do SCE               ³±±
±±³          ³ExpL1: Considera prazo de entrega                       (OPC)³±±
±±³          ³       DEFAULT = .F.							               ³±±
±±³          ³ExpN1: atraso tolerado  		                          (OPC)³±±
±±³          ³       DEFAULT = 0							               ³±±
±±³          ³ExpL2: Verifica a nota do fornecedor                    (OPC)³±±
±±³          ³       DEFAULT = .F.							               ³±±
±±³          ³ExpL3: Selec.o melhor fornecedor das cotacoes validas   (OPC)³±±
±±³          ³       DEFAULT = .F.							               ³±±
±±³          ³ExpL4: Indica se a analise  da cotacao e por cotacao ou (OPC)³±±
±±³          ³       por produto. DEFAULT = .T. (Por Cotacao)              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpA1: retorna atualizada com o Vencedor pelo Sistema 	   ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Avalia as cotacoes em aberto e seleciona a melhor cotacao    ³±±
±±³          ³segundo os parametros da rotina                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvCotVen(aPlanilha,aCotacao,aSCE,aHeadSCE,lEntrega,nAtraso,lNota,lFornec,lProceCot,aCpoSC8,lSelFor)

Local aArea 	:= GetArea()
Local aAreaSA5  := SA5->(GetArea())
Local aFornec   := {}
Local aCalc     := aClone(aPlanilha)
Local nScan     := 0
Local nCalc     := 0
Local nFornec   := 0
Local nX    	:= 0
Local nY    	:= 0
Local nX1       := 1
Local nG        := 0
Local nPProd    := aScan(aCotacao[1][1],{|x| Trim(x[1])=="C8_PRODUTO"})
Local nPQtdSC8  := aScan(aCotacao[1][1],{|x| Trim(x[1])=="C8_QUANT"})

Local nSC8Recno := aScan(aCotacao[1][1],{|x| Trim(x[1])=="SC8RECNO"})
Local nPNumSC   := aScan(aCotacao[1][1],{|x| Trim(x[1])=="C8_NUMSC"})
Local nPItemSC  := aScan(aCotacao[1][1],{|x| Trim(x[1])=="C8_ITEMSC"})
Local lBloqPco  := .F., aBloqPco := {}

Local nPQtdSCE  := aScan(aHeadSCE,{|x| Trim(x[2])=="CE_QUANT"})
Local nPMotSCE  := aScan(aHeadSCE,{|x| Trim(x[2])=="CE_MOTIVO"})
Local nPRegSCE  := aScan(aHeadSCE,{|x| Trim(x[2])=="CE_REGIST"})
Local lSelec    := .F.
Local lM160COTVE:= ExistBlock("M160COTV") 

Local nPlanOK     := aScan(aCpoSC8,"PLN_OK")
Local nPlanForn   := aScan(aCpoSC8,"PLN_FORNECE")
Local nPlanLoja   := aScan(aCpoSC8,"PLN_LOJA")
Local nPlanNumPro := aScan(aCpoSC8,"PLN_NUMPRO")
Local nPlanTotal  := aScan(aCpoSC8,"PLN_TOTAL")
Local nPlanDtPrf  := aScan(aCpoSC8,"PLN_DATPRF")
Local nPlanDatPRZ := aScan(aCpoSC8,"PLN_DATPRZ")
Local nPlanNota   := aScan(aCpoSC8,"PLN_NOTA")
Local nPlanFlag   := aScan(aCpoSC8,"PLN_FLAG")
Local nPlanItem   := aScan(aCpoSC8,"PLN_ITEM")
Local nPlanVisto  := aScan(aCpoSC8,"PLN_VISTO")
Local lMa160PCOK  :=.T.
Local aCotxCot	 := {} 
Local cForn		 := ""
Local cProp       := ""
Local nFvlr		 := 0
Local l1st		  := .T.
Local cFornVenc	 := ""
Local cPropVenc	:= ""
Local nZ		  := 0  
Local nPosF		 := 0
Local cLoja		:= ""
Local aVencedor	:= {}
Local cLojaVenc	:= ""
Local dPrazo	:= STOD("")
Local aFornVenc	:= {}
Local nA		  := 0
Local nB		  := 0
Local nXvenc

DEFAULT lEntrega	:= .F.
DEFAULT lNota		:= .F.
DEFAULT lFornec 	:= .F.
DEFAULT nAtraso 	:= 0
DEFAULT lProceCot	:= .T.
DEFAULT lSelFor 	:= .F.
DEFAULT aCotaGrade 	:= {}
If lProceCot .Or. lFornec
	nX1 := 1
Else
	nX1 := Len(aPlanilha)
Endif

// Inicializa a seleção Manual por Item
If Len(aSelManual) < Len(aPlanilha)
	For nX:=Len(aSelManual) To Len(aPlanilha)
		Aadd(aSelManual,.F.)
	Next nX
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Seleciona os fornecedores validos para a cotacao             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := nX1 To Len(aPlanilha)
	For nY := 1 To Len(aPlanilha[nX])
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inclui todos os fornecedores antes de iniciar a analise      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nPlanFlag > 0
					
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se os precos que nao foram digitados                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( nPlanTotal > 0 .And. aPlanilha[nX][nY][nPlanTotal] == 0 )
				aPlanilha[nX][nY][nPlanFlag] := 1
				For nA := 1 To Len(aPlanilha)
					For nB := 1 To Len(aPlanilha[nA]) 
						If (lFornec .And. aPlanilha[nX][nY][2] == aPlanilha[nA][nB][2])
							aPlanilha[nA][nB][nPlanFlag] := 1
						EndIf
					Next nB
				Next nA
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica as propostas validas                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nA := 1 To Len(aPlanilha)
				For nB := 1 To Len(aPlanilha[nA]) 
					If (aPlanilha[nX][nY][2] == aPlanilha[nA][nB][2] .And. aPlanilha[nX][nY][3] == aPlanilha[nA][nB][3] .And. aPlanilha[nX][nY][5] < aPlanilha[nA][nB][5])
						aPlanilha[nX][nY][nPlanFlag] := 1
					EndIf
				Next nB
			Next nA
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica o prazo de entrega e o atraso tolerado              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( lEntrega .And. nPlanDatPRZ > 0 .And. nPlanDtPrf > 0)
				If ( aPlanilha[nX][nY][nPlanDatPRZ] > (aPlanilha[nX][nY][nPlanDtPrf]+nAtraso) )
					aPlanilha[nX][nY][nPlanFlag] := 1
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica a nota do fornecedor                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( lNota )
				dbSelectArea("SB1")
				dbSetOrder(1)
				MsSeek(xFilial("SB1")+aCotacao[nX][1][nPProd][2])
				If ( nPlanNota > 0 .And. aPlanilha[nX][nY][nPlanNota] < SB1->B1_NOTAMIN )
					aPlanilha[nX][nY][nPlanFlag] := 1
				EndIf
			EndIf
		EndIf
		If !lProceCot .And. !lFornec .And. nPlanVisto > 0
			If !Empty(aPlanilha[nX][nY][nPlanVisto]) .And. nPlanFlag > 0
				aPlanilha[nX][nY][nPlanFlag] := 1
			Endif
			aPlanilha[nX][nY][nPlanVisto] := "X"
		Endif	
	Next nY
Next nX
If ( lFornec )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Seleciona o melhor fornecedor das cotacoes validas           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nPlanFlag > 0 .And. nPlanForn > 0 .And. nPlanLoja > 0 .And. nPlanTotal > 0
		For nX := nX1 To Len(aPlanilha)
			For nY := 1 To Len(aPlanilha[nX])
				If ( aPlanilha[nX][nY][nPlanFlag] == 0 )
					nFornec := aScan(aFornec,{|x| x[1]==aPlanilha[nX][nY][nPlanForn] .And. x[2]==aPlanilha[nX][nY][nPlanLoja]})
					If ( nFornec == 0 )
						aadd(aFornec,{aPlanilha[nX][nY][nPlanForn],aPlanilha[nX][nY][nPlanLoja],aPlanilha[nX][nY][nPlanTotal],nX,aPlanilha[nX][nY][nPlanTotal],aPlanilha[nX][nY][nPlanNumPro]})
					Else
						If ( nX == aFornec[nFornec][4] )
							aFornec[nFornec][3] -= aFornec[nFornec][5]
							aFornec[nFornec][3] += Min(aPlanilha[nX][nY][nPlanTotal],aFornec[nFornec][5])
							aFornec[nFornec][4] := nX
							aFornec[nFornec][5] := Min(aPlanilha[nX][nY][nPlanTotal],aFornec[nFornec][5])
						Else
							aFornec[nFornec][3] += aPlanilha[nX][nY][nPlanTotal]
							aFornec[nFornec][4] := nX
							aFornec[nFornec][5] := aPlanilha[nX][nY][nPlanTotal]
						EndIf
					EndIf
				EndIf
			Next nY
		Next nX
	EndIf
	If ( Len(aFornec) > 0 .And. nPlanForn > 0 .And. nPlanLoja > 0 .And. nPlanFlag > 0)
		aFornec := aSort(aFornec,,,{|x,y| x[3] < y[3]})
		For nX := 1 To Len(aPlanilha)
			nFornec := 0
			For nY := 1 To Len(aFornec)
				nFornec := aScan(aPlanilha[nX],{|x| x[nPlanForn]==aFornec[nY][1] .And. x[nPlanLoja]==aFornec[nY][2]})
				If ( nFornec > 0 )
					nFornec := nY
					Exit
				EndIf
			Next nY
			For nY := 1 To Len(aPlanilha[nX])
			   	If nFornec > 0 .And. ; // Fornecedor localizado
			   		aPlanilha[nX][nY][nPlanForn] == aFornec[nFornec][1] .And. ; // Verifica codigo do fornecedor
			   		aPlanilha[nX][nY][nPlanLoja] == aFornec[nFornec][2] .And. ; // Verifica codigo da Loja
			   		aPlanilha[nX][nY][nPlanTotal]>0  .And. ; // Verifica se o valor total eh maior que 0,00
			   		aPlanilha[nX][nY][nPlanNumPro] == aFornec[nFornec][6] // Verifica Numero do Produto
			  		aPlanilha[nX][nY][nPlanFlag] := 0					
				Else
				  	aPlanilha[nX][nY][nPlanFlag] := 1
				EndIf 
			Next nY
		Next nX
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Seleciona o melhor custo dos fornecedores selecionados       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If (nPlanForn > 0 .And. nPlanLoja > 0 .And. nPlanNumPro > 0 .And. nPlanFlag > 0 .And. nPlanOK > 0 .And. nPlanItem > 0 .And. nPlanDatPRZ > 0)
	For nX := nX1 To Len(aPlanilha)		
		For nY := 1 To Len(aPlanilha[nX])   
		    If aPlanilha[nX][nY][nPlanTotal]>0  .And. aPlanilha[nX][nY][nPlanFlag] == 0
				aPlanilha[nX][nY][nPlanFlag] := 0					
			Else	                              
				aPlanilha[nX][nY][nPlanFlag] := 1
			Endif
		Next nY
			
		aCalc[nX] := aSort(aCalc[nX],,,{|x,y| Str(x[nPlanTotal],18,2)+Dtos(x[nPlanDatPRZ])+Str(x[nPlanFlag],2,0) < Str(y[nPlanTotal],18,2)+Dtos(y[nPlanDatPRZ])+Str(y[nPlanFlag],2) })
		lSelec := .F. 
		nZ := Len(aCalc[nX])
		For nY := 1 To nZ
			//Verifica se o valor da melhor posição do aCalc é diferente de 0
			//se for igual ele passa para a proxima
			For nXvenc:= 1 To nZ 
			  If aCalc[nX][nXvenc][6] <> 0 //valor total da cotação diferente de 0
				Exit
			  EndIf
			Next   
			// Se nao encontrou valor, mantem o primeiro item (melhor) ja classificado no aCalc pelo aSort
			If nXvenc > nZ
				nXvenc := 1
			EndIf
			cForn := alltrim(aCalc[nX][nXvenc][2])
			nFvlr := aCalc[nX][nXvenc][6]
			cLoja := alltrim(aCalc[nX][nXvenc][3])
			cProp := alltrim(aCalc[nX][nXvenc][5])
			dPrazo:= aCalc[nX][nXvenc][nPlanDatPRZ] 
			If aPlanilha[nx][aScan(aPlanilha[nX],{|x| alltrim(x[nPlanForn])==cforn .And. alltrim(x[nPlanLoja])==cLoja .And. alltrim(x[nPlanNumPro])==cProp})][nPlanFlag] == 0 .And. aPlanilha[nX][aScan(aPlanilha[nX],{|x| alltrim(x[nPlanForn])==cforn .And. alltrim(x[nPlanLoja])==cLoja .And. alltrim(x[nPlanNumPro])==cProp})][nPlanTotal]>0   
		   		cFornVenc := ""
				cLojaVenc := ""
				cPropVenc := ""
				If l1st
					aadd(aCotxCot,{cForn,nFvlr,cLoja,cProp,dPrazo})
				Else
					nPosF := aScan(aCotxCot, {|x| x[1] == cForn .And. x[3] == cLoja .And. x[4] == cProp})
					If  nPosF > 0
						aCotxCot[nPosF][2] += nFvlr
					Else
						aadd(aCotxCot,{cForn,nFvlr,cLoja,cProp,dPrazo})
					Endif					
				Endif				
				l1st := .F. 
				aVencedor := FVencedor(lFornec,aCotxCot,lEntrega)
				cFornVenc := aVencedor[1]
				cLojaVenc := aVencedor[2]
				cPropVenc := aVencedor[3]
		    EndIf
			nCalc  := aScan(aPlanilha[nX],{|x| x[nPlanForn]==aCalc[nX][nY][nPlanForn] .And. x[nPlanLoja]==aCalc[nX][nY][nPlanLoja] .And. x[nPlanNumPro]==aCalc[nX][nY][nPlanNumPro] })
			If ( aPlanilha[nX][nCalc][nPlanFlag] == 0 .And. !lSelec )
				//Se vier marcado o vencedor valida se nao bloqueia pelo modulo PCO
				If SuperGetMV("MV_PCOINTE",.F.,"2")=="1"
					//Variaveis para analise de orcamento
					SC8->(MsGoTo(aCotacao[nX][nCalc][nSC8Recno][2]))
					SC1->(DbSetOrder(1))
					SC1->(MsSeek(xFilial("SC1")+aCotacao[nX][nCalc][nPNumSC][2]+aCotacao[nX][nCalc][nPItemSC][2]))
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Ponto de Entrada para ser validado antes  do tratamento do PCO          ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				   	If ExistBlock("MA160PCOK")
				   		lMa160PCOK:= ExecBlock("MA160PCOK",.F.,.F.,{aCotacao})
  					    If Valtype(lMa160PCOK) <> "L" 
					    	lMa160PCOK:=.T.
					    EndIf
				  	EndIf	
					          
					IF lMa160PCOK
						If !PcoVldLan('000052','02',"MATA160")                 
		                    lBloqPco := .T.
	    	                aAdd(aBloqPco, { nX, nCalc, nPQtdSCE,nPMotSCE,nPRegSCE })
	        	        EndIf
	     			EndIf  
	     			 
				EndIf
				IIf(lFornec,aPlanilha[nX][nCalc][nPlanOK]:="XX",aPlanilha[nX][nCalc][nPlanOK]:="")
				aSCE[nX][nCalc][nPQtdSCE] := aCotacao[nX][1][nPQtdSC8][2]
				aSCE[nX][nCalc][nPMotSCE] := Padr(STR0001,Len(aSCE[nX][nCalc][nPMotSCE])) //"ENCERRADO AUTOMATICAMENTE"
				aSCE[nX][nCalc][nPRegSCE] := 1 // Identifica o Vencedor Indicado pelo Sistema 
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se vencedor e o Produto for de Grade alimenta a Quantidade do item de Grade com a quantidade do SC8.³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nScan := aScan(aCotaGrade, {|z| z[1] + z[2] + z[3] + z[4] == ;
				aPlanilha[nX][nCalc][nPlanForn] + aPlanilha[nX][nCalc][nPlanLoja] + aPlanilha[nX][nCalc][nPlanNumPro] + aPlanilha[nX][nCalc][nPlanItem] })
	
		   		If Len(aCotaGrade[nScan][6]) > 0
					For nG := 1 To Len(aCotaGrade[nScan][6])
						aCotaGrade[nScan][6][nG][2] := aCotaGrade[nScan][6][nG][6]
					Next nG
				EndIf
				
			  	lSelec := .T.
			Else
				If lProceCot .or. lFornec
					aSCE[nX][nCalc][nPQtdSCE] := 0 				
					aPlanilha[nX][nCalc][nPlanOK]:="" 								
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Se nao for o vencedor e o Produto for de Grade zera a Quantidade do item de Grade.                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nScan := aScan(aCotaGrade, {|z| z[1] + z[2] + z[3] + z[4] == ;
					aPlanilha[nX][nCalc][nPlanForn] + aPlanilha[nX][nCalc][nPlanLoja] + aPlanilha[nX][nCalc][nPlanNumPro] + aPlanilha[nX][nCalc][nPlanItem] })
		
					If Len(aCotaGrade[nScan][6]) > 0
						For nG := 1 To Len(aCotaGrade[nScan][6])
							aCotaGrade[nScan][6][nG][2] := 0
						Next nG
					EndIf
				Else
					If nPlanVisto > 0 .And. Empty(aPlanilha[nX][nCalc][nPlanVisto])
						aSCE[nX][nCalc][nPQtdSCE] := 0
						aPlanilha[nX][nCalc][nPlanOK] := ""			
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Se nao for o vencedor e o Produto for de Grade zera a Quantidade do item de Grade.                  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						nScan := aScan(aCotaGrade, {|z| z[1] + z[2] + z[3] + z[4] == ;
						aPlanilha[nX][nCalc][nPlanForn] + aPlanilha[nX][nCalc][nPlanLoja] + aPlanilha[nX][nCalc][nPlanNumPro] + aPlanilha[nX][nCalc][nPlanItem] })
			
						If Len(aCotaGrade[nScan][6]) > 0
							For nG := 1 To Len(aCotaGrade[nScan][6])
								aCotaGrade[nScan][6][nG][2] := 0
							Next nG
						EndIf
					Endif	
				Endif	
			EndIf
			If lSelFor .And. aPlanilha[nX][nY][nPlanTotal] > 0 .And. !lFornec
				For nA := 1 To Len(aPlanilha)
					For nB := 1 To Len(aPlanilha[nA]) 
						If (aPlanilha[nX][nY][2] == aPlanilha[nA][nB][2] .And. aPlanilha[nX][nY][3] == aPlanilha[nA][nB][3])
							If(aPlanilha[nX][nY][5] < aPlanilha[nA][nB][5])
								aPlanilha[nX][nY][nPlanFlag] := 1
							Else
								aPlanilha[nX][nY][nPlanFlag] := 0
							Endif
						EndIf
					Next nB
				Next nA
			EndIf
			If lM160COTVE
				SC8->(MsGoTo(aCotacao[nX][nCalc][nSC8Recno][2]))
				aRet := ExecBlock("M160COTV",.F.,.F.,{aPlanilha[nX][nCalc][nPlanOK],aSCE[nX][nCalc][nPQtdSCE]})
				If ValType(aRet) == "A" .And. Len(aRet) > 0
					aPlanilha[nX][nCalc][nPlanOK]   := aRet[1]
					aSCE[nX][nCalc][nPQtdSCE] := aRet[2]
				Endif
			Endif			
		Next nY
		aCotxCot := {}    
	    aaDD(aFornVenc,{cFornVenc,cLojaVenc,cPropVenc})
	Next nX
EndIf
If lBloqPco .And. nPlanOK > 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Retira as marcas caso seja bloqueado pelo PCO                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 To Len(aBloqPco)
		aPlanilha[ aBloqPco[nX,1], aBloqPco[nX,2], nPlanOK] := ""
		aSCE[ aBloqPco[nX,1], aBloqPco[nX,2], aBloqPco[nX,3]] := 0
		aSCE[ aBloqPco[nX,1], aBloqPco[nX,2], aBloqPco[nX,4]] := ""
		aSCE[ aBloqPco[nX,1], aBloqPco[nX,2], aBloqPco[nX,5]] := 0
	Next //nX	 
EndIf
If ExistBlock("M160VENC") 
	aRet160PLN := ExecBlock("M160VENC",.F.,.F.,{aSCE,aPlanilha,aCotacao})
    aSCE       := aRet160PLN[1]
    aPlanilha  := aRet160PLN[2]
EndIf

// Inicializa a seleção Manual por Item
If Len(aSelManual) < Len(aPlanilha)
	For nX:=Len(aSelManual) To Len(aPlanilha)
		Aadd(aSelManual,.F.)
	Next nX
Endif

If !lFornec
	For nX := nX1 to len(aPlanilha)
		For nY := 1 to len(aPlanilha[nX])
			If lProceCot .Or. lFornec 
		  		cFornVenc := aFornVenc[nX][1] 
				cLojaVenc := aFornVenc[nX][2] 
				cPropVenc := aFornVenc[nX][3]
			Else
		  		cFornVenc := aFornVenc[len(aFornVenc)][1] 
				cLojaVenc := aFornVenc[len(aFornVenc)][2] 
				cPropVenc := aFornVenc[len(aFornVenc)][3]
			EndIf   
			
		    If alltrim(aPlanilha[nX][nY][2])==cFornVenc .And. alltrim(aPlanilha[nX][nY][3])==cLojaVenc .And. alltrim(aPlanilha[nX][nY][5])== cPropVenc ;
		    .And. !aSelManual[nX] // Verifica se selecionou o fornecedor manualmente
		   		aPlanilha[nX][nY][nPlanOK] := "XX"
	       Else
			    aPlanilha[nX][nY][nPlanOK] := ""
	       Endif
	    Next nY
	Next nX
Endif 
RestArea(aArea)
RestArea(aAreaSA5)
Return(aPlanilha)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ FVencedorºAutor  ³Julio Saraiva       º Data ³  23/04/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Escolhe qual vencedor tem a cotacao mais barata.           º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGACOM                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/

Function FVencedor(lFornec,aCotxCot,lEntrega)
Local cFornV := ""
Local cLojaV := ""	
Local cPropV := ""

Default lEntrega := .T.

If !lFornec
	If lEntrega
		asort(aCotxCot,,, {|x,y| Str(x[2])+Dtos(x[5]) < Str(y[2])+Dtos(y[5]) })
	Else
		asort(aCotxCot,,, {|x,y| x[2] < y[2] }) 
	EndIf
	cFornV := aCotxCot[1][1] // Fornecedor vencedor
	cLojaV := aCotxCot[1][3] // Loja vencedora
	cPropV := aCotxCot[1][4] // Proposta vencedora
Endif
Return ({cFornV,cLojaV,cPropV})

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaValPres ³ Autor ³ Eduardo Riera         ³ Data ³27.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Funcao de calculo do valor presente                          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpN1 := MaValPres(ExpN2,ExpD1,ExpN3,ExpN4)			 	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN2: Valor base a ser calculado                            ³±±
±±³          ³ExpD1: Data de pagamento                                     ³±±
±±³          ³ExpN3: Taxa a ser utilizada(%)                               ³±±
±±³          ³       * DEFAULT MV_JUROS                                    ³±±
±±³          ³ExpN4: 1 - Valor Presente * DEFAULT                          ³±±
±±³          ³       2 - Valor Futuro    								   ³±±
±±³ 	   	 ³ExpD5: Data de emissao do lancamento (default : dDatabase)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Valor presente                                        ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta funcao efetua a conversao do valor financeiro em uma    ³±±
±±³          ³determinada data, para seu correspondente na presente data   ³±±
±±³          ³como base numa taxa de juros.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaValPres(nValor,dData,nTaxa,nTipo,dDtEmissao)

Local nValFut  := 0
Local nValPres := 0 
Local nPrazo   

DEFAULT nTaxa := SuperGetMV("MV_JUROS")
DEFAULT nTipo := 1
DEFAULT dDtEmissao := dDataBase 
              
nPrazo := dData-dDtEmissao
                  
If nTipo == 1 //Present Value
	nValPres := nValor/( (1+(nTaxa/100)) ** (nPrazo/30) )
Else
	nValFut  := nValor*( (1+(nTaxa/100)) ** (nPrazo/30) )
EndIf

Return(nValPres+nValFut)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaAvalRA  ³ Autor ³ Eduardo Riera         ³ Data ³25.08.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de avaliacao dos eventos de uma pre-requisicao ao     ³±±
±±³          ³almoxarifado                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaValRA(ExpC1,ExpN1,ExpN2)							 	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela de solicitacao de compra              ³±±
±±³          ³ExpN1: Codigo do Evento                                      ³±±
±±³          ³       [1] Implantacao de uma pre-requisicao ao almoxarifado ³±±
±±³          ³       [2] Estorno de uma pre-requisicao ao almoxarifado     ³±±
±±³          ³ExpN2: Quantidade da Soma                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo atualizar os eventos vinculados³±±
±±³          ³a uma pre-requisicao                                         ³±±
±±³          ³A) Atualizacao das tabelas complementares.                   ³±±
±±³          ³B) Atualizacao das informacoes complementares a Requisicao ao³±±
±±³          ³almoxarifado                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalRA(cAliasSCQ,nEvento,nQtdSoma)

Local aArea 	:= GetArea()
DEFAULT cAliasSCQ := "SCQ"
DEFAULT nQtdSoma  := 0
Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de uma pre-requisicao ao almoxarifado                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 1 .Or. nEvento == 3
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza as tabelas auxiliares                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(xFilial("SB2")+(cAliasSCQ)->CQ_PRODUTO+(cAliasSCQ)->CQ_LOCAL) )
		CriaSB2((cAliasSCQ)->CQ_PRODUTO,(cAliasSCQ)->CQ_LOCAL)
	EndIf
	RecLock("SB2")
	SB2->B2_QEMPSA += If(nEvento==1,(cAliasSCQ)->CQ_QTDISP,nQtdSoma)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cancelamento de uma pre-requisicao ao almoxarifado                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 2
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza as tabelas auxiliares                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(xFilial("SB2")+(cAliasSCQ)->CQ_PRODUTO+(cAliasSCQ)->CQ_LOCAL) )
		CriaSB2((cAliasSCQ)->CQ_PRODUTO,(cAliasSCQ)->CQ_LOCAL)
	EndIf
	RecLock("SB2")
	SB2->B2_QEMPSA -= (cAliasSCQ)->CQ_QTDISP
EndCase
RestArea(aArea)
Return(.T.)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaSAPreReq³ Autor ³Edson Maricate         ³ Data ³25.08.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de conversao de uma Solicitacao ao Almoxarifado para  ³±±
±±³          ³uma prerequisicao                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaSAPreReq(ExpL1,ExpL2,ExpB1,ExpL3,ExpL4,ExpL5,ExpC1,ExpC2,  ³±±
±±³          ³			 ExpL6,ExpL7,ExpL8)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL1: Indica se a rotina deve avaliar a selecao da Markbrow-³±±
±±³          ³       se ou deve avaliar todos os registros                 ³±±
±±³          ³ExpL2: Indica se a rotina deve ser avaliada por data de neces³±±
±±³          ³       ssidade ou por data de emissao                        ³±±
±±³          ³ExpB1: Expressao de filtro a ser avaliada para cada registro ³±±
±±³          ³       do SCP.                                               ³±±
±±³          ³ExpL3: Indica se considera ou nao Prev.Entrada (SC)     (OPC)³±±
±±³          ³       DEFAULT = .F.                                         ³±±
±±³          ³ExpL4: Indica se a rotina devera gerar ou nao Solicitacao de ³±±
±±³          ³       Compras no SC1                                        ³±±
±±³          ³ExpL5: Considera Armazem da SA                               ³±±
±±³          ³ExpC1: Saldo do Armazem a considerar a necessidade           ³±±
±±³          ³ExpC2: Saldo ate o Armazem a considerar a necessidade        ³±±
±±³          ³ExpL6: Considerar o Lote Economico na geracacao da SC        ³±±
±±³          ³ExpL7: Considerar o saldo ja empenhado qdo baixa de OP       ³±±
±±³          ³ExpN1: Indica se aglutina ou nao as SC's  (OPC) DEFAULT = 1  ³±±
±±³          ³ExpL8: 													   ³±±
±±³          ³ExpL9: 													   ³±±
±±³          ³ExpA1: 													   ³±±
±±³          ³ExpL10: Indica se existe rateio na solicitacao ao armazem	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.	                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³                                                             ³±±
±±³          ³                                                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaSAPreReq(lMarkB,lDtNec,BFiltro,lConsSPed,lGeraDoc,lAmzSA,cSldAmzIni,cSldAmzFim,lLtEco,lConsEmp,nAglutDoc,lAuto,lEstSeg,aRecSCP,lRateio)

Local aArea     := GetArea()
Local aLotes    := {}
Local aSCs      := {}
Local aHeadSC1  := {}
Local aColsSC1  := {}
Local aHeadSCX  := {}
Local aColsSCX  := {}
Local aCampos	:= {}
Local aLinha	:= {}
Local aDocs		:= {}
Local aDocsCp	:= {}
Local aRateio	:= {}
Local aCTBEnt   := CTBEntArr()
Local aMT106SCQ := {}
local aCPAgl	:= {}
Local aResultado:= {}
Local aFornecedor:= {}
Local aPosDhn		:= {}
Local aSldPrev	:= {}

Local cEntidades:= ""
Local cNumSC    := ""
Local cNumSA    := ''
Local cItemSC   := ""
Local cCursor   := "SCP"
Local cQuery    := ""
Local cSeq      := "01"	
Local cMsgSC    := ""
Local cSeekSCP  := ""
Local cSeekSCQ  := ""
Local cMsg		:= ""
Local cChaveRat	:= ""
Local cUndRequi	:= SuperGetMv("MV_CCUNREQ")

Local nPrc		:= 0
Local nX        := 0
Local nQtde     := 0
Local nQtdPre   := 0
Local nEstoque  := 0
Local nLoteSC   := 0
Local nSaveSX8  := GetSX8Len()
Local nEstSeg	:= 0 
Local nRegSemSC := 0
Local nSaldo	:= 0
Local nLoop		:= 0

Local lIncluiReg:= .T.
Local lQuery    := .F.
Local lContinua	:= .T.
Local lVLCP 	:= .T.
Local lPrjCni   := ValidaCNI()
Local lErrAutSC	:= .F.
Local lVldPE	:= .T.
Local lMT106SCA := ExistBlock("MT106SCA")
Local lMASAVLSC := ExistBlock("MASAVLSC")
Local lEstNeg 	:= SuperGetMv("MV_ESTNEG",.F.,"N") == "S"
Local nSumLE    := 0

Local uLoteSC   := Nil

Private lxCont  := .F.                 // FSW - Controle de numeração SC

DEFAULT lMarkb  := .F.
DEFAULT lDtNec  := .F.
DEFAULT bFiltro := {|| .T.}
DEFAULT lLtEco  := .T.
DEFAULT lConsEmp:= .F.
DEFAULT nAglutDoc:=  2      
DEFAULT lAuto	:= .F.
DEFAULT lEstSeg	:= .F.
DEFAULT aRecSCP	:= {}
DEFAULT lRateio	:= .F.
DEFAULT lGeraDoc:= .T.

lConsSPed:=If(Valtype(lConsSPed) # "L",.F.,lConsSPed)

If lGeraDoc
	PcoIniLan("000051")
EndIf

dbSelectArea("SCP")
If lDtNec
	dbSetOrder(3)
Else
	dbSetOrder(4)
EndIf

//preparação para quebra por CP_DESCRI
SCP->(dbCommit())
cCursor := GetNextAlias()
lQuery  := .T.
cQuery  := "SELECT CP_FILIAL,R_E_C_N_O_ SCPRECNO "
cQuery  += "FROM "+RetSqlName("SCP")+" SCP "
cQuery  += "WHERE "
cQuery  += "CP_PREREQU<>'S' AND "
cQuery  += "D_E_L_E_T_=' ' "
If ( lMarkb )
	If ( ThisInv() )
		cQuery += "AND CP_OK<>'"+ThisMark()+"' "
	Else
		cQuery += "AND CP_OK='"+ThisMark()+"' "
	EndIf
EndIf

If ExistBlock("MT106QRY")
   c106Qry := ExecBlock("MT106QRY",.F.,.F.,{lAuto})
   If ValType(c106Qry) == "C"
	   cQuery += c106Qry
   EndIf	   
EndIf

cQuery += "ORDER BY "+SqlOrder(SCP->(IndexKey()))
cQuery := ChangeQuery( cQuery )

dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQuery ), cCursor, .F., .T. ) 		
	
While  !Eof() 
	If ( lQuery )
		dbSelectArea(cCursor)
		SCP->(MsGoto((cCursor)->SCPRECNO))
	EndIf
	SB1->(dbSetOrder(1))
	SB1->(MsSeek(xFilial("SB1",(cCursor)->CP_FILIAL)+SCP->CP_PRODUTO))
	
	dbSelectArea("SCP")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula a Necessidade de uma Solicitacao de Compra/Autorizacao de Entrega  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If	SCP->CP_PREREQU<>"S"              
		If !lQuery
			If ThisInv()
				If SCP->CP_OK == ThisMark()
					dbSelectArea("SCP")
					dbSkip()
					Loop
				EndIf
			Else
				If AllTrim(SCP->CP_OK) <> ThisMark()
					dbSelectArea("SCP")
					dbSkip()
					Loop
				EndIf
			EndIf		
		EndIf
		If lMarkb
			 IsMark("CP_OK",ThisMark(),ThisInv())
		EndIf
		If SB1->B1_MSBLQL == "1" // Verifica tambem se o produto nao esta bloqueado
			If !lAuto
				Aviso("B1_MSBLQL",OemtoAnsi(STR0091)+Alltrim(SB1->B1_COD)+OemtoAnsi(STR0092),{STR0118}) // "Ok"
			EndIf
		Else
			If ( Eval(bFiltro) )
				lIncluiReg	:=.T.
				cMsg		:= ""
				Begin Transaction
					dbSelectArea("SB2")
					dbSetOrder(1)
					If lAmzSA
						cSeekSCP := xFilial("SB2")+SCP->CP_PRODUTO+SCP->CP_LOCAL
					Else
						cSeekSCP := xFilial("SB2")+SCP->CP_PRODUTO
					EndIf
					nSaldo := 0
					If MsSeek(cSeekSCP)
						RecLock("SB2")
						If lAmzSA
				   			nSaldo  := SaldoSB2(.F.,lConsEmp)+If(lConsSPed,AvalSalPed(SCP->CP_PRODUTO,SCP->CP_LOCAL),0)
						Else
							While !Eof() .And. cSeekSCP == SB2->B2_FILIAL+SB2->B2_COD
								If SB2->B2_LOCAL < cSldAmzIni .Or. SB2->B2_LOCAL > cSldAmzFim
									SB2->(dbSkip())
									Loop
								EndIf
								nSaldo += SaldoSB2(.F.,lConsEmp)+If(lConsSPed,AvalSalPed(SB2->B2_COD,SB2->B2_LOCAL),0)
								SB2->(dbSkip())
							EndDo
						EndIf
					EndIf
					If ExistBlock("MT106GRV")
						ExecBlock("MT106GRV",.F.,.F.)
					EndIf
					 
					If lConsSPed/*Verifico se ja tratei o item e se tem saldo previsto para considerar*/
						If(Len(aDocs) > 0 .And. Len(aSldPrev) > 0)
							nZ:= aScan(aSldPrev,{|x| x[1] == SCP->CP_PRODUTO .and. x[3] == SCP->CP_FILIAL}) 
							If nZ <> 0
								nSaldo += aSldPrev[nZ][2]
							EndIf
						EndIf
					EndIf

                   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Calcula se possui estoque de segurança ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ       
					If lEstSeg
				   		nEstSeg   := CalcEstSeg( RetFldProd(SB1->B1_COD,"B1_ESTFOR","SB1") )
	                    If nEstSeg > 0
	                    	nSaldo:= nSaldo - nEstSeg 
	                    EndIf 
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Ponto de entrada que permite validar se deve ou nao ser  ³
					//³ gerada a pre-requisicao de solicitacao ao armazem.       ³				
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ExistBlock("MT106VGR") 
						If (Valtype(lContinua := ExecBlock("MT106VGR",.F.,.F.,{lAmzSA,nSaldo,lConsEmp,lConsSPed}))=='L') .And. !lContinua
						    //Quando executado o break o mesmo pulara para o final da funcao
						    //executando la o DbSkip() sem a necessesidade de se colocar um dbSkip loop aqui.
							DisarmTransaction()
						    break
						EndIf				
					EndIf						
					nQtde	:= SCP->CP_QUANT
					nEstoque:= 0
					cSeq    := "01"
					nQtdPre := nQtde
					uLoteSC := Nil
					While nQtde > 0
						nSaldo  := Max(0,nSaldo)
						nEstoque:= Min(nSaldo,nQtde)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica se pode gerar pre-requisicao com saldo negativo ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lEstNeg .And. !lGeraDoc .And. !(Rastro(SCP->CP_PRODUTO) .Or. Localiza(SCP->CP_PRODUTO))
							nEstoque := nQtde
						EndIf
	
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Grava Pre-Requisicao         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						nRegSemSC:=0
						dbSelectArea("SCQ")
						dbSetOrder(1)
						cSeekSCQ:=xFilial("SCQ",(cCursor)->CP_FILIAL)+SCP->CP_NUM+SCP->CP_ITEM
						dbSeek(cSeekSCQ)
						While !Eof() .And. cSeekSCQ == CQ_FILIAL+CQ_NUM+CQ_ITEM
							aPosDhn := COMPosDHN({2,{SCQ->CQ_FILIAL,SCQ->CQ_NUM,SCQ->CQ_ITEM}})
							If !aPosDhn[1] .Or. !((aPosDhn[2])->DHN_TIPO $ "1|2")
								nRegSemSC := SCQ->(Recno())
								nQtdPre   -= SCQ->CQ_QTDISP
								nQtde     -= SCQ->CQ_QTDISP
								If aPosDhn[1]
									(aPosDhn[2])->(DbCloseArea())
								EndIf
								Exit
							EndIf						
							SCQ->(dbSkip())
						End
				
						If !lGeraDoc .And. nRegSemSC > 0
							msGoto(nRegSemSC)
							RecLock("SCQ",.F.)
							SCQ->CQ_QTDISP := SCQ->CQ_QTDISP+nEstoque
							MsUnlock()
							lIncluiReg:=.F.
							MaAvalRA("SCQ",3,nEstoque)
						Else
							RecLock("SCQ",.T.)					
							SCQ->CQ_FILIAL	:= xFilial("SCQ",(cCursor)->CP_FILIAL)
							SCQ->CQ_NUM		:= SCP->CP_NUM
							SCQ->CQ_ITEM	:= SCP->CP_ITEM
							SCQ->CQ_PRODUTO	:= SCP->CP_PRODUTO
							SCQ->CQ_LOCAL	:= SCP->CP_LOCAL
							SCQ->CQ_UM		:= SCP->CP_UM
							SCQ->CQ_QUANT	:= nQtdPre
							SCQ->CQ_QTSEGUM	:= SCP->CP_QTSEGUM
							SCQ->CQ_SEGUM	:= SCP->CP_SEGUM
							SCQ->CQ_QTDISP	:= nEstoque
							SCQ->CQ_NUMSQ	:= cSeq
							SCQ->CQ_DATPRF	:= SCP->CP_DATPRF
							SCQ->CQ_DESCRI	:= SCP->CP_DESCRI
							SCQ->CQ_CC		:= SCP->CP_CC
							SCQ->CQ_CONTA	:= SCP->CP_CONTA
							SCQ->CQ_ITEMCTA	:= SCP->CP_ITEMCTA
							SCQ->CQ_CLVL	:= SCP->CP_CLVL
							SCQ->CQ_OP		:= SCP->CP_OP
							SCQ->CQ_OBS		:= SCP->CP_OBS	
							
							For nX := 1 To Len(aCTBEnt)
								SCQ->&("CQ_EC"+aCTBEnt[nX]+"CR") := SCP->&("CP_EC"+aCTBEnt[nX]+"CR")
								SCQ->&("CQ_EC"+aCTBEnt[nX]+"DB") := SCP->&("CP_EC"+aCTBEnt[nX]+"DB")
							Next nX
							
							//aMT106SCQ utilizada no P.E. MT106PRE
							aAdd(aMT106SCQ,{SCQ->CQ_FILIAL,SCQ->CQ_NUM,SCQ->CQ_ITEM,SCQ->CQ_NUMSQ,SCQ->CQ_PRODUTO,SCQ->CQ_LOCAL,SCQ->CQ_QUANT})
	
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Ponto de Entrada MA106SCQ     |
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If Existblock("MA106SCQ")
							   uLoteSC := ExecBlock("MA106SCQ",.F.,.F.)
							   If Valtype(uLoteSC) == "N" .And. uLoteSC > 0
							   		nLoteSC := uLoteSC
							   	EndIf	
							Endif
							MaAvalRA("SCQ",1)
						EndIf

						nLoteSC := IIf(uLoteSC <> Nil,nLoteSC,(SCQ->CQ_QUANT-SCQ->CQ_QTDISP))
						nLot2SC := ConvUm(SCP->CP_PRODUTO,nLoteSC,0,2)
						cMsgSC  := OemToAnsi(STR0002)+IIF(!Empty(SCP->CP_OBS)," - "+Left(SCP->CP_OBS,(Len(SC1->C1_OBS))-(Len(STR0002)+3)),"") //"SC gerada por SA"
	
						// Avalia empenho ja existente a fim de nao gerar SCS/AES caso ja tenha saldo empenhado
						If lConsEmp .And. AvalEmpSCP(SCP->CP_PRODUTO,SCP->CP_LOCAL,SCP->CP_OP,nQtdPre) 
							Reclock("SCP",.F.)
							SCP->CP_PREREQU := "S"
							MsUnlock()
							Exit
						// Qdo nao gera Documento
						ElseIf !lGeraDoc
							If QtdComp(nLoteSC) > QtdComp(0)
								cMsg := STR0086+" "+SCP->CP_NUM+" / "+SCP->CP_ITEM
							EndIf
							Reclock("SCP",.F.)
							SCP->CP_PREREQU := "S"
							MsUnlock()
							Exit
						EndIf	
	
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Ponto de Entrada - Geração de Solicitação de Compras					   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lMASAVLSC
							lVldPE := ExecBlock("MASAVLSC",.F.,.F.,{SB1->B1_COD,SB1->B1_LOCPAD,SB1->B1_CONTRAT}) 
							If Valtype(lVldPE) <> "L"
								lVldPE := .T.
							ElseIf !lVldPE  
								Reclock("SCP",.F.)
								SCP->CP_PREREQU := "S"
								MsUnlock() 
							EndIf
						EndIf

						If lGeraDoc .And. lVldPE
							//-- Calcula a quantidade conforme o Lote Economico, conforme parametro 8
							If lLtEco
								If ( nLoteSC > 0 )
									aLotes := CalcLote(SCQ->CQ_PRODUTO,nLoteSC,"C")
									nLoteSC:= 0
									For nX := 1 To Len(aLotes)
										nLoteSC += aLotes[nX]
									Next nX
								Else
									nLoteSC := 0
								EndIf
								nSumLE += nQtdPre
							EndIf
							
							aFornecedor:= COMPESQFOR(SCQ->CQ_PRODUTO) //-- Retorna codigo e loja do fornecedor
							nPrc:= COMPESQPRECO(SCQ->CQ_PRODUTO,(cCursor)->CP_FILIAL,aFornecedor[1],aFornecedor[2])
							aRateio:={}
							If SGS->(MsSeek(SCP->(CP_FILIAL+CP_NUM+CP_ITEM))) //Existe Rateio
								While !SGS->(EOF()) .AND. SGS->(GS_FILIAL+GS_SOLICIT+GS_ITEMSOL) == SCP->(CP_FILIAL+CP_NUM+CP_ITEM)
									cEntidades:= SGS->GS_CC 		+ "|" 
									cEntidades+= SGS->GS_CONTA		+ "|"
									cEntidades+= SGS->GS_ITEMCTA 	+ "|"
									cEntidades+= SGS->GS_CLVL 		+ "|"
									For nX := 1 To Len(aCTBEnt)
										cEntidades+= SGS->&("GS_EC"+aCTBEnt[nX]+"CR")	+ "|"
										cEntidades+= SGS->&("GS_EC"+aCTBEnt[nX]+"DB")	+ "|"
									Next nX
									aAdd(aRateio,{SGS->GS_PERC, cEntidades})
									
									SGS->(DbSkip())
								EndDo
							Else //-- Caso não existe rateio assume 100%
								cEntidades:= SCP->CP_CC 		+ "|" 
								cEntidades+= SCP->CP_CONTA		+ "|"
								cEntidades+= SCP->CP_ITEMCTA 	+ "|"
								cEntidades+= SCP->CP_CLVL 		+ "|"
								For nX := 1 To Len(aCTBEnt)
									cEntidades+= SCP->&("CP_EC"+aCTBEnt[nX]+"CR")		+ "|"
									cEntidades+= SCP->&("CP_EC"+aCTBEnt[nX]+"DB")		+ "|"
								Next nX								
							EndIf
							
							If !Empty(SCP->CP_VUNIT)
								nPrc:= SCP->CP_VUNIT
							EndIf
							If !Empty(aRateio)
								aAdd(aCampos,{"RATEIO"		, "1"})
							EndIf
							aAdd(aCampos,{"OBS"		, cMsgSC})	
							aAdd(aCampos,{"DATPRF"	, SCQ->CQ_DATPRF})	
							aAdd(aCampos,{"LOCAL"	, SCQ->CQ_LOCAL})	
							aAdd(aCampos,{"CC"		, SCQ->CQ_CC})	
							aAdd(aCampos,{"CONTA"	, SCQ->CQ_CONTA})	
							aAdd(aCampos,{"ITEMCTA"	, SCQ->CQ_ITEMCTA})	
							aAdd(aCampos,{"CLVL"	, SCQ->CQ_CLVL})	
							aAdd(aCampos,{"DESCRI"	, SCQ->CQ_DESCRI})	
							aAdd(aCampos,{"EMISSAO"	, dDataBase})						
							aAdd(aCampos,{"FILENT"	, xFilEnt((cCursor)->CP_FILIAL,"SC1")})
							aAdd(aCampos,{"COTACAO"	, If(SB1->B1_IMPORT=="S","IMPORT","")})	
							aAdd(aCampos,{"FORNECE"	, SB1->B1_PROC})	
							aAdd(aCampos,{"LOJA"	, SB1->B1_LOJPROC})								
							aAdd(aCampos,{"SOLICIT"	, SCP->CP_SOLICIT})
							aAdd(aCampos,{"VUNIT"	, SCP->CP_VUNIT})
							aAdd(aCampos,{"OS"		, If(empty(SCP->CP_NUMOS),SubStr(SCP->CP_OP,1,At("OS",SCP->CP_OP)-1),SCP->CP_NUMOS)})
							If lMT106SCA
					  			aCPAgl := Execblock("MT106SCA",.f.,.f.)
		                        If Valtype(aCPAgl) == "A"
		                        	aAdd(aCampos,{"MT106SCA",{aCPAgl[1], aCPAgl[2]}})
		                        Else
		                        	aAdd(aCampos,{"MT106SCA",{" ", " "}})
								EndIf
							Else
	                        	aAdd(aCampos,{"MT106SCA",{" ", " "}})
							EndIf
							
							If lLtEco .and. Ascan(aDocs,{|x| x[1] == SCP->CP_PRODUTO .and. iif(x[2] > 0,!(nSumLE > x[2]),.f.)}) <> 0
								nLoteSC := 0
	 						EndIf
							aadd(aDocs,;
									{SCP->CP_PRODUTO,;			//aPequena[x,1] : Produto
									 nLoteSC 		,;			//aPequena[x,2] : Quantidade da necessidade total
									 (cCursor)->CP_FILIAL,;		//aPequena[x,3] : Filial que será gerada o documento 
									 (cCursor)->CP_FILIAL,;		//aPequena[x,4] : Filial que será feita entrega do produto 
									 "1"     		,;			//aPequena[x,5] : Documento que será gerado sendo 1=Solicitação de Compras e 2=Pedido de Compra
									 aFornecedor[1]	,; 			//aPequena[x,6] : Fornecedor do produto
									 aFornecedor[2]	,; 			//aPequena[x,7] : Loja do fornecedor do produto
									 "001" 			,;			//aPequena[x,8] : Condição de pagamento
									 nPrc			,;		 	//aPequena[x,9] : Preço do Produto
									 aClone(aRateio),;		 	//aPequena[x,10] : Array de Rateio
									 SCP->CP_NUM	,;		 	//aPequena[x,11] : Código Documento
									 SCP->CP_ITEM	,;			//aPequena[x,12] : Item do Documento 
									 aClone(aCampos)	,;		 	//aPequena[x,13] : Dados de campos adicionais
									 (cCursor)->CP_FILIAL})	 	//aPequena[x,14] : Filial de Origem
							Reclock("SCP",.F.)
							SCP->CP_PREREQU := "S"
							MsUnlock()
							//limpa o array para o Loop
							aCampos	:= {}
							
							If lConsSPed/*Gravo o saldo previsto para entrar*/
								nZ:= Ascan(aSldPrev,{|x| x[1] == SCP->CP_PRODUTO.and. x[3] == SCP->CP_FILIAL}) 
								If  nZ <> 0
									aSldPrev[nZ,2] += nLoteSC
								Else  
									aAdd(aSldPrev,{SCP->CP_PRODUTO, nLoteSC, (cCursor)->CP_FILIAL})
								EndIf
							Endif
						EndIf
						
						nQtde -= nQtdPre
						nSaldo-= nEstoque
						cSeq  := Soma1(cSeq,Len(SCQ->CQ_NUMSQ))
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Ponto de Entrada para permitir a geração de Ordem de Produção pela Pré-Requisição³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If ExistBlock("MASAVLOP")
							 ExecBlock("MASAVLOP",.F.,.F.)
						EndIf	
						// Se houve erro na geracao da rotina automatica da solicitacao de compra desfaz alteracoes
						If lErrAutSC .And. !IsBlind()
							AVISO(STR0116,STR0117,{STR0118})
							DisarmTransaction()
							Exit
						EndIf
					EndDo
					
				End Transaction
				If !Empty(cMsg) .And. !lAuto
					Aviso(STR0014,cMsg,{STR0087},1)			
				EndIf
				If	Empty(cMsg)
					AAdd(aRecSCP,SCP->(Recno()))
				EndIf
			EndIf
		EndIf
	EndIf
	dbSelectArea(cCursor)
	dbSkip()
	lVLCP := .T. // Ativa variavel para validar novo item da Geracao de pre req. ao armazem 
EndDo

If !Empty(aDocs)
	aDocsCp := aClone(aDocs) 
	aResultado:= ComGeraDoc(aDocs,.T.,.F.,.F.,.T.,30,"MATA106",/*lEnviaEmail*/,nAglutDoc  )
	If ExistBlock("MT106SC1")
		For nLoop := 1 To Len( aResultado )
			If Len(aResultado[nLoop]) > 0
				dbSelectArea("SCP")
				dbSetOrder(1)
				dbSeek(aDocsCp[nLoop][14]+aDocsCp[nLoop][11]+aDocsCp[nLoop][12])
				Do Case
					//--Tipo de documento gerado pela biblioteca de compras
					Case aResultado[nLoop,1,3] == "1" //-- Solicitação de Compras
						SC1->(dbSetOrder(1)) //-- C1_FILIAL+C1_NUM+C1_ITEM+C1_ITEMGRD
						If SC1->(dbSeek(aResultado[nLoop,1,1]+aResultado[nLoop,1,2]))
							Execblock("MT106SC1",.F.,.F.,{"SC1",SC1->C1_NUM,SC1->C1_ITEM,SC1->(Recno())})
						EndIf
					Case aResultado[nLoop,1,3] == "2" //-- Pedido de Compras
						SC7->(dbSetOrder(1))  //-- C7_FILIAL+C7_NUM+C7_ITEM+C7_SEQUEN
						If SC7->(dbSeek(aResultado[nLoop,1,1]+aResultado[nLoop,1,2]))
							Execblock("MT106SC1",.F.,.F.,{"SC7",SC7->C7_NUM,SC7->C7_ITEM,SC7->(Recno())})
						EndIf
					Case aResultado[nLoop,1,3] == "3" //-- Autorização de Entrega
						SC7->(dbSetOrder(1))  //-- C7_FILIAL+C7_NUM+C7_ITEM+C7_SEQUEN
						If SC7->(dbSeek(aResultado[nLoop,1,1]+aResultado[nLoop,1,2]))
							Execblock("MT106SC1",.F.,.F.,{"SC7",SC7->C7_NUM,SC7->C7_ITEM,SC7->(Recno())})
						EndIf
					Case aResultado[nLoop,1,3] == "5" //-- Medição de Contrato
						CND->(dbSetOrder(4))  //--CND_FILIAL+CND_NUMMED
						If CND->(dbSeek(aResultado[nLoop,1,1]+aResultado[nLoop,1,2]))
							Execblock("MT106SC1",.F.,.F.,{"CND",CND->CND_NUMMED,,CND->(Recno())})
						EndIf
					Case aResultado[nLoop,1,3] == "6" //-- Solicitação de Importação
						SW1->(dbSetOrder(1)) //-- W1_FILIAL+W1_CC+W1_SI_NUM+W1_COD_I 
						If SW1->(MsSeek(aResultado[nLoop,1,1]+PadR(cUndRequi,Len(SW1->W1_CC))+aResultado[nLoop,1,2]))
							Execblock("MT106SC1",.F.,.F.,{"SW1",SW1->W1_SI_NUM,SW1->W1_COD_I,SW1->(Recno())})
						EndIf
				EndCase
			Endif
		Next nLoop
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³P.E. Apos a geracao completa da Pre-Requisicao	   ³
//³PARAMIXB[1] := CQ_FILIAL   PARAMIXB[2] := CQ_NUM    ³
//³PARAMIXB[3] := CQ_ITEM     PARAMIXB[4] := CQ_NUMSQ  ³ 
//³PARAMIXB[5] := CQ_PRODUTO  PARAMIXB[6] := CQ_LOCAL  ³
//³PARAMIXB[7] := CQ_QUANT                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MT106PRE")
	ExecBlock("MT106PRE",.F.,.F.,aMT106SCQ)
EndIf
If ( lQuery )
	dbSelectArea(cCursor)
	dbCloseArea()
	dbSelectArea("SCP")
EndIf
If lGeraDoc
	PcoFinLan("000051")
EndIf
RestArea(aArea)
Return(.T.)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaCanAltSA³ Autor ³Eduardo Riera          ³ Data ³07.03.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se eh possivel alterar a Solic.ao almoxarifado     ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := MaCanAltSA(ExpL2)  							   	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL2: Indica se consiste SCP->CP_NUMOS (OPC) DEFAULT = .T. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. se Ok                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaCanAltSA(lMata105)

Local lRetorno := .T.
DEFAULT lMata105 := .T.

Do Case
Case ( SCP->CP_PREREQU=="S" )
	lRetorno := .F.
Case ( !Empty(SCP->CP_NUMOS) .And. lMata105 .And. ExistOS(SCP->CP_NUMOS))
	lRetorno := .F.
EndCase

Return(lRetorno)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaCanDelSA³ Autor ³Eduardo Riera          ³ Data ³07.03.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se eh possivel excluir a Solic.ao almoxarifado     ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := MaCanDelSA(ExpL2)  							   	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL2: Indica se consiste SCP->CP_NUMOS (OPC) DEFAULT = .T. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. se Ok                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaCanDelSA(lMata105)

Local lRetorno := MaCanAltSA(lMata105)
DEFAULT lMata105 := .T.

Return(lRetorno)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaComView³ Autor ³ Edson Maricate          ³ Data ³23.11.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Cria uma tela de consulta das ultimas compras, cotacoes ,    ³±±
±±³          ³consumos de um determinado produto.                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaComView(ExpC1)			   							   	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaComView(cProduto)

Local aArea		:= GetArea()
Local aAreaSX3	:= SX3->(GetArea())
Local aAreaSB1	:= SB1->(GetArea())
Local aCpos		:= {}
Local nRecSB1
Local oBold
Local oDlg
Local lContCT  := .T.
Local lContPC  := .T.
Local lContNF  := .T.

Private aTELA[0][0],aGETS[0]
Private lRefresh	:= .T.
Private Inclui		:= .F.
Private Altera		:= .F.
Private aViewSC8
Private aViewSC7
Private aViewNF
Private aRecSD1
Private lPasMCV := .T. //passou no macomview, esta variavel serve para tratar erro na visualização ultimas faturas no historico de produto
Private aRotina	:= {{ , , 0 , 2 }}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para tratamento de visualizacao de dados              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                
If ExistBlock( "MC050CNT" )
	If Valtype( aRet := Execblock( "MC050CNT", .F., .F., (cProduto) ) ) == "A"
		If Valtype(aRet[1]) == "L"
			lContCT := aRet[1]  
		EndIf
		If Valtype(aRet[2]) == "L"
			lContPC := aRet[1]
		EndIf
		If Valtype(aRet[3]) == "L"
			lContNF := aRet[3]
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona o cadastro de produtos                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea('SB1')
dbSetOrder(1)
If MsSeek(xFilial("SB1")+cProduto)

	dbSelectArea("SX3")
	dbSetOrder(1)
	If MsSeek("SB1")
		While ( !Eof() .And. SX3->X3_ARQUIVO == "SB1" )
			If X3USO(X3_USADO) .And. cNivel >= X3_NIVEL .And. !(AllTrim(X3_CAMPO)$"B1_COD/B1_DESC")
				aAdd(aCpos,X3_CAMPO)
			EndIf
			dbSkip()
		Enddo
		RegToMemory("SB1", .F., .F. )
		DEFINE FONT oBold NAME "Arial" SIZE 0, -12 BOLD
		DEFINE MSDIALOG oDlg FROM 0,0  TO 340,600 TITLE OemToAnsi(STR0074) Of oMainWnd PIXEL      //   'Historico de Compras'
		EnChoice("SB1", nRecSB1, iif(Len(aRotina)>1,2,1), , , , aCpos ,{20,2,150,298} , ,3 )
		@ 157 ,10  BUTTON STR0063 SIZE 45 ,10  FONT oDlg:oFont ACTION MaComViewPC(SB1->B1_COD,lContPC)  OF oDlg PIXEL  //"Ultimos Pedidos"
		@ 157 ,56  BUTTON STR0064 SIZE 45 ,10  FONT oDlg:oFont ACTION MaComViewCT(SB1->B1_COD,lContCT)  OF oDlg PIXEL  //"Ultimas Cotacoes"
		@ 157 ,102 BUTTON STR0035 SIZE 45 ,10  FONT oDlg:oFont ACTION MaComViewSm(SB1->B1_COD)  OF oDlg PIXEL  //"Consumo"
		@ 157 ,148 BUTTON STR0065 SIZE 45 ,10  FONT oDlg:oFont ACTION MaComViewNF(SB1->B1_COD,lContNF)  OF oDlg PIXEL  //"Ultimas N.Fiscais"
		@ 157 ,194 BUTTON STR0066 SIZE 49 ,10  FONT oDlg:oFont ACTION MaViewSB2(SB1->B1_COD)  OF oDlg PIXEL  //"Consulta Estoques"
		@ 157 ,244 BUTTON STR0067 SIZE 45 ,10  FONT oDlg:oFont ACTION (oDlg:End())  OF oDlg PIXEL  //"Sair"
		@ 4  ,10   SAY Alltrim(cProduto)+ " - "+SB1->B1_DESC Of oDlg PIXEL SIZE 245 ,9 FONT oBold
		@ 13, 4 To 14,302 Label "" of oDlg PIXEL
		ACTIVATE MSDIALOG oDlg CENTERED
	EndIf
Endif

RestArea(aAreaSX3)
RestArea(aAreaSB1)
RestArea(aArea)
Return Nil


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaComViewPC³ Autor ³ Edson Maricate       ³ Data ³23.11.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Cria uma tela de consulta com os ultimos Pedidos de Compras. ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaComViewPC(ExpC1)		   							   	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Materiais                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaComViewPC(cProduto,lContPC)

Local aArea		:= GetArea()
Local aAreaSC7	:= SC7->(GetArea())
Local aNew      := {}
Local aHeadCpos	:= {STR0006,STR0007,STR0008,STR0009,STR0010,STR0011,STR0088,STR0012,STR0013}
Local cCursor
Local cQuery
Local oBold
Local cDescProd := ""
Local cQueryPE	:= ""
Local cFiltroPE := ""
Local nLoop := 0
Local lPcAdColH := ExistBlock("PCADCOLH") // Ponto de entrada para adicionar o Header ao adicionar mais colunas na listbox de consulta
Local lPcAdHead := ExistBlock("PCADHEAD") // Ponto de entrada para adicionar colunas ao Header
Local lPcAdLine := ExistBlock("PCADLINE") // Ponto de entrada para adicionar mais colunas na listbox de consulta
Local lPcAdFil	:= ExistBlock("PCADFIL")  // Ponto de entrada para manipulacao da query/filtro
Default lContPC := .T.
 
If lContPC
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona o cadastro de produtos                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SB1')
	dbSetOrder(1)
	If MsSeek(xFilial("SB1")+cProduto)
		cDescProd:=SB1->B1_DESC
		If aViewSC7 == Nil
			aViewSC7 := {}
			cCursor:= GetNextAlias()
			lQuery := .T.
			cQuery := ""
			cQuery += "SELECT * FROM "+RetSqlName("SC7")+" WHERE "
			cQuery += "C7_FILIAL='"+xFilial("SC7")+"' AND "
			cQuery += "C7_PRODUTO='"+cProduto+"' AND "
			cQuery += "D_E_L_E_T_ <> '*' "
			cQuery += "ORDER BY C7_DATPRF DESC"          
			If lPcAdFil
			   cQueryPE := Execblock('PCADFIL', .F., .F., {cQuery})
			   cQuery   := If(ValType(cQueryPE)=='C', cQueryPE, "")
			EndIf
			cQuery := ChangeQuery(cQuery)
			SC7->(dbCommit())
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor,.T.,.T.)
			aStruQuery	:= SC7->(dbStruct())
			For nLoop := 1 To Len( aStruQuery )
				If aStruQuery[nLoop,2] <> "C"
					TCSetField(cCursor,AllTrim(aStruQuery[nLoop,1]),aStruQuery[nLoop,2],aStruQuery[nLoop,3],aStruQuery[nLoop,4])
				EndIf 										
			Next nLoop
			While ( !Eof() )
				dbSelectArea("SE4")
				MsSeek(xFilial("SE4")+(cCursor)->C7_COND)
				dbSetOrder(1)
				dbSelectArea("SA2")
				dbSetOrder(1)
				MsSeek(xFilial("SA2")+(cCursor)->C7_FORNECE+(cCursor)->C7_LOJA)
				dbSelectArea(cCursor)		
				aAdd(aViewSC7,{C7_NUM,C7_ITEM,SA2->A2_NOME,TransForm(C7_QUANT,PesqPict("SC7","C7_QUANT")),TransForm(C7_PRECO,PesqPict("SC7","C7_PRECO")),TransForm(C7_QUJE,PesqPict("SC7","C7_QUJE")),C7_RESIDUO,C7_COND+" - "+SE4->E4_DESCRI,C7_DATPRF})

				If lPcAdLine
					aNew := ExecBlock("PCADLINE", .F., .F., aViewSC7[Len(aViewSC7)])
					If ValType(aNew) == "A"
						aViewSC7[Len(aViewSC7)] := aNew
					Endif	
				Endif
				
				dbSkip()					
			EndDo
			
			If lPcAdColH
				aNew := ExecBlock("PCADCOLH", .F., .F., aHeadCpos[Len(aHeadCpos)])
				If ValType(aNew) == "A"
					aHeadCpos[Len(aHeadCpos)] := aNew
				Endif	
			Endif 		
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de entrada para manipular as colunas da consulta de ultimos     ³
			//³ pedidos                                                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lPcAdHead
				aNew := ExecBlock("PCADHEAD", .F., .F., aHeadCpos)
				If ValType(aNew) == "A"
					aHeadCpos := aNew
				Endif	
			Endif 		
		EndIf
		If !Empty(aViewSC7)
			DEFINE FONT oBold NAME "Arial" SIZE 0, -12 BOLD
			DEFINE MSDIALOG oDlg FROM 0,0  TO 340,600 TITLE STR0005 Of oMainWnd PIXEL //"Historico de compras - Ultimos Pedidos"
			@ 13, 4 To 14,302 Label "" of oDlg PIXEL
			oListBox := TWBrowse():New( 20,2,298,130,,aHeadCpos,,oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,) //"Pedido"###"Item"###"Fornecedor"###"Quantidade"###"Preco Unit."###"Qtde. Entregue"###"Cond. Pagto."###"Previsao Entr."
			oListBox:SetArray(aViewSC7)
			oListBox:bLine := { || aViewSC7[oListBox:nAT]}
			@ 4  ,10   SAY Alltrim(cProduto)+ " - "+cDescProd Of oDlg PIXEL SIZE 245 ,9 FONT oBold
			@ 157 ,194  BUTTON STR0068 SIZE 45 ,10  FONT oDlg:oFont ACTION MaViewPC(aViewSC7[oListBox:nAT][1]) OF oDlg PIXEL  //"Visualizar"
			@ 157 ,244  BUTTON STR0016 SIZE 45 ,10  FONT oDlg:oFont ACTION (oDlg:End())  OF oDlg PIXEL  //"Voltar"
			ACTIVATE MSDIALOG oDlg CENTERED
		Else
			Aviso(STR0014,STR0015,{STR0016},2) //"Atencao"###"Nao existem pedidos colocados para este produto."###"Voltar"
		EndIf
	EndIf	
	RestArea(aAreaSC7)
	RestArea(aArea)
	Return Nil
EndIf



/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaComViewCT³ Autor ³ Edson Maricate       ³ Data ³23.11.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Cria uma tela de consulta com os ultimas Cotacoes do Prod.   ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaComViewCT(ExpC1)		   							   	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Materiais                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaComViewCT(cProduto,lContCT)

Local aArea		:= GetArea()
Local aAreaSC8	:= SC8->(GetArea())
Local aNew      := {}
Local aHeadCpos	:= {STR0018,STR0007,STR0008,STR0009,STR0010,STR0054,STR0012,STR0013,STR0079,STR0080,STR0081,STR0082,STR0083,STR0090,STR0097}
Local oBold
Local lCtAdColH := ExistBlock("CTADCOLH") // Ponto de entrada para adicionar o Header ao adicionar mais colunas na listbox de consulta
Local lCtAdLine := ExistBlock("CTADLINE") // Ponto de entrada para adicionar mais colunas na listbox de consulta
Local lCtAdFil	:= ExistBlock("CTADFIL")  // Ponto de entrada para manipulacao da query/filtro
Local cDescProd := ""
Local cFiltroPE	:= ""
Local cQueryPE	:= ""
Local nLoop := 0
Default lContCT := .T.

If lContCT
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona o cadastro de produtos                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SB1')
	dbSetOrder(1)
	If MsSeek(xFilial("SB1")+cProduto)
		cDescProd := SB1->B1_DESC
		If aViewSC8 == Nil
			aViewSC8 := {}
			cCursor:= CriaTrab(,.F.)
			lQuery := .T.
			cQuery := ""
			cQuery += "SELECT * FROM "+RetSqlName("SC8")+" WHERE "
			cQuery += "C8_FILIAL='"+xFilial("SC8")+"' AND "
			cQuery += "C8_PRODUTO='"+cProduto+"' AND "
			cQuery += "C8_PRECO <> 0  AND "
			cQuery += "D_E_L_E_T_ <> '*' "
			cQuery += "ORDER BY C8_DATPRF DESC"
			If lCtAdFil
			   cQueryPE := Execblock('CtAdFil', .F., .F., {cQuery})
			   cQuery   := If(ValType(cQueryPE)=='C', cQueryPE, "")
			EndIf					
			cQuery := ChangeQuery(cQuery)
			SC8->(dbCommit())
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor,.T.,.T.)
			aStruQuery	:= SC8->(dbStruct())
			For nLoop := 1 To Len( aStruQuery )
				If aStruQuery[nLoop,2] <> "C"
					TCSetField(cCursor,AllTrim(aStruQuery[nLoop,1]),aStruQuery[nLoop,2],aStruQuery[nLoop,3],aStruQuery[nLoop,4])
				EndIf 										
			Next nLoop
			While ( !Eof() )
				dbSelectArea("SE4")
				MsSeek(xFilial("SE4")+(cCursor)->C8_COND)
				dbSetOrder(1)
				dbSelectArea("SA2")
				dbSetOrder(1)
				MsSeek(xFilial("SA2")+(cCursor)->C8_FORNECE+(cCursor)->C8_LOJA)
				dbSelectArea(cCursor)
			    SC8->(MsGoto((cCursor)->(R_E_C_N_O_))) 
				aAdd(aViewSC8,{C8_NUM,C8_ITEM,SA2->A2_NOME,TransForm(C8_QUANT,PesqPict("SC8","C8_QUANT")),TransForm(C8_PRECO,PesqPict("SC8","C8_PRECO")),;
					TransForm(C8_TOTAL,PesqPict("SC8","C8_TOTAL")),C8_COND+" - "+SE4->E4_DESCRI,C8_DATPRF,C8_EMISSAO,;
					TransForm(C8_VALIPI,PesqPict("SC8","C8_VALIPI")),TransForm(C8_ALIIPI,PesqPict("SC8","C8_ALIIPI")+" %"),;
					TransForm(C8_VALICM,PesqPict("SC8","C8_VALICM")),TransForm(C8_PICM,PesqPict("SC8","C8_PICM")+" %"),C8_MOTIVO,SC8->C8_OBS})

				If lCtAdLine
					aNew := ExecBlock("CTADLINE", .F., .F., aViewSC8[Len(aViewSC8)])
					If ValType(aNew) == "A"
						aViewSC8[Len(aViewSC8)] := aNew
					EndIf	   
				EndIf 

				dbSkip()					
			EndDo
			dbSelectArea(cCursor)
			dbCloseArea()
			dbSelectArea("SC8")
			
			If lCtAdColH
				aNew := ExecBlock("CTADCOLH", .F., .F., aHeadCpos)
				If ValType(aNew) == "A"
					aHeadCpos := aNew
				Endif	   
			Endif 		
		EndIf
		
		If !Empty(aViewSC8)
			DEFINE FONT oBold NAME "Arial" SIZE 0, -12 BOLD
			DEFINE MSDIALOG oDlg FROM 0,0  TO 340,600 TITLE STR0017 Of oMainWnd PIXEL //"Historico de compras - Ultimas Cotacoes"
			@ 13, 4 To 14,302 Label "" of oDlg PIXEL
			oListBox := TWBrowse():New( 20,2,298,130,,aHeadCpos,,oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,)  //"Cotacao"###"Item"###"Fornecedor"###"Quantidade"###"Preco Unit."###"Total"###"Cond. Pagto."###"Previsao Entr."###"Data Emissao##Aliq IPI##Valor IPI###Aliq ICMS##Valor ICMS"
			oListBox:SetArray(aViewSC8)
			oListBox:bLine := { || aViewSC8[oListBox:nAT]}
			@ 4  ,10   SAY Alltrim(cProduto)+ " - "+cDescProd Of oDlg PIXEL SIZE 245 ,9 FONT oBold
			@ 157 ,244  BUTTON STR0016 SIZE 45 ,10  FONT oDlg:oFont ACTION (oDlg:End())  OF oDlg PIXEL  //"Voltar"
			ACTIVATE MSDIALOG oDlg CENTERED
		Else
			Aviso(STR0014,STR0019,{STR0016},2)	 //"Atencao"###"Nao existem cotacoes colocadas para este produto."###"Voltar"
		EndIf	
	EndIf
	
	RestArea(aAreaSC8)
	RestArea(aArea)
	Return Nil
EndIf	

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaComViewSm ³ Autor ³ Edson Maricate      ³ Data ³23.11.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Cria uma tela de consulta com os ultimos consumos do Produto ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaComViewSm(ExpC1)		   							   	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Materiais                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaComViewSm(cProduto)

Local aViewCsm		:= {}
Local aMeses		:= {STR0020,STR0021,STR0022,STR0023,STR0024,STR0025,STR0026,STR0027,STR0028,STR0029,STR0030,STR0031} //"Jan"###"Fev"###"Mar"###"Abr"###"Mai"###"Jun"###"Jul"###"Ago"###"Set"###"Out"###"Nov"###"Dez"
Local nX          := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona o cadastro de produtos                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea('SB1')
dbSetOrder(1)
If MsSeek(xFilial("SB1")+cProduto)
	dbSelectArea("SB3")
	dbSetOrder(1)
	If MsSeek(xFilial("SB3")+cProduto)
		cMeses	:= SPACE(3)
		nAno	:= YEAR(dDataBase)
		nMes	:= MONTH(dDataBase)
		aOrdem	:= {}
		nAno--
		For nx := nMes+1 To 12
			aADD(aViewCsm,{aMeses[nx],Str(nAno,4),&("B3_Q"+StrZero(nx,2))})
		Next nx
		nAno++
		For nx	:= 1 to nMes
			aADD(aViewCsm,{aMeses[nx],Str(nAno,4),&("B3_Q"+StrZero(nx,2))})
		Next nx
	EndIf
	If !Empty(aViewCsm)
		DEFINE FONT oBold NAME "Arial" SIZE 0, -12 BOLD
		DEFINE MSDIALOG oDlg FROM 0,0  TO 350,273 TITLE STR0032 Of oMainWnd PIXEL //"Consumos"
		@ 13, 4 To 14,302 Label "" of oDlg PIXEL
		oListBox := TWBrowse():New( 20,4,132,130,,{STR0033,STR0034,STR0035},{17,60,40},oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,) //"Mes"###"Ano"###"Consumo"
		oListBox:SetArray(aViewCsm)
		oListBox:bLine := { || {aViewCsm[oListBox:nAT][1],aViewCsm[oListBox:nAT][2],TransForm(aViewCsm[oListBox:nAt][3],PesqPict("SB3","B3_Q01")) }}
		If TamSX3("B1_COD")[1] > 15
			@ 4  ,10   SAY Alltrim(cProduto) Of oDlg PIXEL SIZE 245 ,9 FONT oBold
			@ 12 ,10   SAY SB1->B1_DESC      Of oDlg PIXEL SIZE 245 ,9 FONT oBold
		Else
	   		@ 4  ,10   SAY Alltrim(cProduto)+ " - "+SB1->B1_DESC Of oDlg PIXEL SIZE 245 ,9 FONT oBold
		EndIf
		@ 160 ,80  BUTTON STR0016 SIZE 45 ,10  FONT oDlg:oFont ACTION (oDlg:End())  OF oDlg PIXEL  //"Voltar"
		ACTIVATE MSDIALOG oDlg CENTERED
	Else
		Aviso(STR0014,STR0036,{STR0016},2) //"Atencao"###"Nao existe registros de consumo para este produto."###"Voltar"
	EndIf	
EndIf

Return Nil
    

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaComViewNF³ Autor ³ Edson Maricate       ³ Data ³23.11.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Cria uma tela de consulta com os ultimas Cotacoes do Prod.   ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaComViewNF(ExpC1)		   							   	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Materiais                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaComViewNF(cProduto,lContNF)

Local aArea		:= GetArea()
Local cDescProd := ""
Local aRet  
Local nLoop := 0
Default lContNF := .T.

If lContNF
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona o cadastro de produtos                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SB1')
	dbSetOrder(1)
	If MsSeek(xFilial("SB1")+cProduto)
		cDescProd:=SB1->B1_DESC
		If aViewNF == Nil
			aViewNF := {}
			aRecSD1	:= {}
			cCursor:= CriaTrab(,.F.)
			lQuery := .T.
			cQuery := ""
			cQuery += "SELECT SD1.*,SD1.R_E_C_N_O_ SD1RECNO FROM "+RetSqlName("SD1")+" SD1 WHERE "
			cQuery += "D1_FILIAL='"+xFilial("SD1")+"' AND "
			cQuery += "D1_COD='"+cProduto+"' AND "
			cQuery += "D1_TES <> '"+SPACE(LEN(SD1->D1_TES))+"'  AND "
			cQuery += "D_E_L_E_T_ <> '*' "
			cQuery += "ORDER BY D1_NUMSEQ DESC"
			cQuery := ChangeQuery(cQuery)
			SD1->(dbCommit())
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor,.T.,.T.)
			aStruQuery	:= SD1->(dbStruct())
			For nLoop := 1 To Len( aStruQuery )
				If aStruQuery[nLoop,2] <> "C"
					TCSetField(cCursor,AllTrim(aStruQuery[nLoop,1]),aStruQuery[nLoop,2],aStruQuery[nLoop,3],aStruQuery[nLoop,4])
				EndIf 										
			Next nLoop
			While ( !Eof() )
				If D1_TIPO $"DB"
					dbSelectArea("SA1")
					dbSetOrder(1)
					MsSeek(xFilial("SA1")+(cCursor)->D1_FORNECE+(cCursor)->D1_LOJA)
				Else
					dbSelectArea("SA2")
					dbSetOrder(1)
					MsSeek(xFilial("SA2")+(cCursor)->D1_FORNECE+(cCursor)->D1_LOJA)
				EndIf
				dbSelectArea(cCursor)
				aAdd(aViewNF,{D1_DTDIGIT,D1_TIPO,D1_DOC,D1_SERIE,If(D1_TIPO$"DB",SA1->A1_NOME,SA2->A2_NOME),TransForm(D1_QUANT,PesqPict("SD1","D1_QUANT")),;
				TransForm(IIF(D1_TIPO$"NDB",((D1_TOTAL-D1_VALDESC)/D1_QUANT),D1_VUNIT),PesqPict("SD1","D1_VUNIT")),D1_EMISSAO})
				aAdd(aRecSD1,SD1RECNO)
				dbSkip()
			EndDo
		EndIf
		
		If Existblock("MTULTNFE")
			aRet := ExecBlock("MTULTNFE",.F.,.F.,{aViewNF,aRecSD1})
			If ValType(aRet) == "A"
				If ValType(aRet[1]) == "A"
					aViewNF := aRet[1]
				Endif	
				If ValType(aRet[2]) == "A"
					aRecSD1 := aRet[2]
				Endif				
			Endif	
		EndIf	
		
		If !Empty(aViewNF)
			DEFINE FONT oBold NAME "Arial" SIZE 0, -12 BOLD
			DEFINE MSDIALOG oDlg FROM 0,0  TO 340,600 TITLE STR0037 Of oMainWnd PIXEL //"Historico de compras - Ultimas N.Fiscais"
			@ 13, 4 To 14,302 Label "" of oDlg PIXEL
			oListBox := TWBrowse():New( 20,2,298,130,,{STR0038,STR0039,STR0040,STR0041,STR0042,STR0009,STR0043,STR0089},,oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,)  //"Dt. Entrada"###"Tipo NF"###"Documento"###"Serie"###"Fornecedor/Cliente"###"Quantidade"###"Vlr. Unitario"###"Dt. Emissao"
			oListBox:SetArray(aViewNF)
			oListBox:bLine := { || aViewNF[oListBox:nAT]}
			@ 4  ,10   SAY Alltrim(cProduto)+ " - "+cDescProd Of oDlg PIXEL SIZE 245 ,9 FONT oBold
			@ 157 ,194  BUTTON STR0068 SIZE 45 ,10  FONT oDlg:oFont ACTION MaViewNF(aRecSD1[oListBox:nAt]) OF oDlg PIXEL  //"Visualizar"
			@ 157 ,244  BUTTON STR0016 SIZE 45 ,10  FONT oDlg:oFont ACTION (oDlg:End())  OF oDlg PIXEL  //"Voltar"
			ACTIVATE MSDIALOG oDlg CENTERED
		Else
			Aviso(STR0014,STR0044,{STR0016},2) //"Atencao"###"Nao existem Notas Fiscais de Entrada cadastradas para este produto."###"Voltar"
		EndIf	
	EndIf
	
	RestArea(aArea)
	Return Nil
EndIf

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaViewSB2  ³ Autor ³ Edson Maricate       ³ Data ³23.11.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Cria uma tela de consulta com os saldos atuais               ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MaViewSB2(ExpC1,ExpC2,ExpC3)							   	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto                                     ³±±
±±³          ³ExpC2: Filial de Consulta                                    ³±±
±±³          ³ExpC3: Local (almox.)de Consulta (OPC) DEFAULT = ""          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Materiais                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaViewSB2(cProduto,cFilCon,cAlmox)

Local aArea		:= GetArea()
Local aAreaSB1	:= SB1->(GetArea())
Local aAreaSB2	:= SB2->(GetArea())
Local aAreaSM0	:= SM0->(GetArea())
Local aViewB2	:= {}
Local aStruSB2  := {}
Local aNewSaldo := {}
Local nTotDisp	:= 0
Local nTotExecDisp:=0
Local nSaldo	:= 0
Local nQtPV		:= 0
Local nQemp		:= 0
Local nSalpedi	:= 0
Local nReserva	:= 0
Local nQempSA	:= 0
Local nSaldoSB2:=0
Local nQtdTerc :=0
Local nQtdNEmTerc:=0
Local nSldTerc :=0
Local nQEmpN :=0
Local nQAClass :=0
Local nQEmpPrj  := 0
Local nQEmpPre  := 0
Local nX        := 0
Local nB2_QATU  := 0,nB2_QPEDVEN := 0,nB2_QEMP := 0,nB2_SALPEDI := 0,nB2_QEMPSA := 0,nB2_RESERVA :=0
Local nB2_QTNP  := 0,nB2_QNPT := 0,	nB2_QTER := 0,nB2_QEMPN := 0,nB2_QACLASS := 0,nB2_QPRJ := 0, nB2_QPRE := 0

Local cFilialSB2:= xFilial("SB2")
Local cFilialSB1:= xFilial("SB1")
Local lViewSB2  := .T.
Local lMTVIEWFIL:= ExistBlock("MTVIEWFIL")
Local nAtIni    := 1
Local oListBox, oDlg, oBold
Local nHdl      := GetFocus()

Static lViewSB2PE
Static lViewSaldo

DEFAULT cAlmox := ""

If ValType(lViewSB2PE) # "L"
	lViewSB2PE	:= ExistBlock("MVIEWSB2SL")
EndIf

If ValType(lViewSaldo) # "L"
	lViewSaldo	:= ExistBlock("MVIEWSALDO")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para impedir a apresentacao da Dialog de Saldos do SB2³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MTVIEWB2")
	lViewSB2 := ExecBlock("MTVIEWB2",.F.,.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica a filial de pesquisa do saldo                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cFilCon)
	If !Empty(cFilialSB2)
		cFilialSB2 := cFilCon
	EndIf
	dbSelectArea("SM0")
	dbSetOrder(1)
	MsSeek(cEmpAnt+cFilCon)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona o cadastro de produtos                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea('SB1')
dbSetOrder(1)
If MsSeek(cFilialSB1+cProduto) .And. lViewSB2
	cCursor  := "MAVIEWSB2"
	lQuery   := .T.
	aStruSB2 := SB2->(dbStruct())		
	
	cQuery := ""
	cQuery += "SELECT * FROM "+RetSqlName("SB2")+" WHERE "
	cQuery += "B2_FILIAL='"+cFilialSB2+"' AND "
	cQuery += "B2_COD='"+cProduto+"' AND "
	cQuery += "B2_STATUS <> '2' AND "
	cQuery += "D_E_L_E_T_ <> '*' "
	cQuery += "ORDER BY B2_LOCAL "
	
	cQuery := ChangeQuery(cQuery)
	
	SB2->(dbCommit())			
	
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor,.T.,.T.)
	
	For nX := 1 To Len(aStruSB2)
		If aStruSB2[nX][2]<>"C"
			TcSetField(cCursor,aStruSB2[nX][1],aStruSB2[nX][2],aStruSB2[nX][3],aStruSB2[nX][4])
		EndIf
	Next nX
	
	dbSelectArea(cCursor)
	While ( !Eof() )
		nSaldoSB2:=SaldoSB2(,,,,,cCursor)
		// Executa o ponto de entrada para alterar o saldo disponivel pelo usuario
		If lViewSB2PE
			nTotExecDisp:=ExecBlock("MVIEWSB2SL",.F.,.F.,{(cCursor)->B2_COD,(cCursor)->B2_LOCAL,nSaldoSB2})
			If ValType(nTotExecDisp) == "N"
				nSaldoSB2 := nTotExecDisp		
			EndIf
		EndIf		

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de Entrada para alterar os itens da Consulta ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMTVIEWFIL
			lRetPE:=ExecBlock("MTVIEWFIL",.F.,.F.,{(cCursor)->B2_COD,(cCursor)->B2_LOCAL}) 
			If ValType(lRetPE)=="L" .And. lRetPE
				dbSelectArea(cCursor)
				dbSkip()
				Loop
			EndIf
		EndIf

		nB2_QATU    := (cCursor)->B2_QATU
		nB2_QPEDVEN := (cCursor)->B2_QPEDVEN
		nB2_QEMP    := (cCursor)->B2_QEMP
		nB2_SALPEDI := (cCursor)->B2_SALPEDI
		nB2_QEMPSA  := (cCursor)->B2_QEMPSA
		nB2_RESERVA := (cCursor)->B2_RESERVA
		nB2_QTNP    := (cCursor)->B2_QTNP
		nB2_QNPT    := (cCursor)->B2_QNPT
		nB2_QTER    := (cCursor)->B2_QTER
		nB2_QEMPN   := (cCursor)->B2_QEMPN
		nB2_QACLASS := (cCursor)->B2_QACLASS
		nB2_QPRJ 	:= (cCursor)->B2_QEMPPRJ
		nB2_QPRE 	:= (cCursor)->B2_QEMPPRE
		If lViewSaldo
			aNewSaldo := {}
			aAdd(aNewSaldo,{nSaldoSB2,nB2_QATU,nB2_QPEDVEN,nB2_QEMP,nB2_SALPEDI,nB2_QEMPSA,nB2_RESERVA,nB2_QTNP,;
			                nB2_QNPT,nB2_QTER,nB2_QEMPN,nB2_QACLASS,nB2_QPRJ,nB2_QPRE})				
			
			If ValType(aNewSaldo:=ExecBlock("MVIEWSALDO",.F.,.F.,{(cCursor)->B2_COD,(cCursor)->B2_LOCAL,aNewSaldo}))=="A" .And. Len(aNewSaldo) > 0
				nSaldoSB2   := aNewSaldo[1,1]
				nB2_QATU    := aNewSaldo[1,2]
				nB2_QPEDVEN := aNewSaldo[1,3]
				nB2_QEMP    := aNewSaldo[1,4]
				nB2_SALPEDI := aNewSaldo[1,5]
				nB2_QEMPSA  := aNewSaldo[1,6]
				nB2_RESERVA := aNewSaldo[1,7]
				nB2_QTNP    := aNewSaldo[1,8]
				nB2_QNPT    := aNewSaldo[1,9]
				nB2_QTER    := aNewSaldo[1,10]
				nB2_QEMPN   := aNewSaldo[1,11]
				nB2_QACLASS := aNewSaldo[1,12]
				nB2_QPRJ    := aNewSaldo[1,13]
				nB2_QPRE    := aNewSaldo[1,14]
            Endif
		EndIf						

		aAdd(aViewB2,{TransForm((cCursor)->B2_LOCAL,PesqPict("SB2","B2_LOCAL")),;
			TransForm(nSaldoSB2,PesqPict("SB2","B2_QATU")),;
			TransForm(nB2_QATU,PesqPict("SB2","B2_QATU")),;
			TransForm(nB2_QPEDVEN,PesqPict("SB2","B2_QPEDVEN")),;
			TransForm(nB2_QEMP,PesqPict("SB2","B2_QEMP")),;
			TransForm(nB2_SALPEDI,PesqPict("SB2","B2_SALPEDI")),;
			TransForm(nB2_QEMPSA,PesqPict("SB2","B2_QEMPSA")),;
			TransForm(nB2_RESERVA,PesqPict("SB2","B2_RESERVA")),;
			TransForm(nB2_QTNP,PesqPict("SB2","B2_QTNP")),;
		    TransForm(nB2_QNPT,PesqPict("SB2","B2_QNPT")),;
			TransForm(nB2_QTER,PesqPict("SB2","B2_QTER")),;
			TransForm(nB2_QEMPN,PesqPict("SB2","B2_QEMPN")),;
			TransForm(nB2_QACLASS,PesqPict("SB2","B2_QACLASS")),;
			TransForm(nB2_QPRJ,PesqPict("SB2","B2_QEMPPRJ")),;
			TransForm(nB2_QPRE,PesqPict("SB2","B2_QEMPPRE"))})
			
		If !Empty(cAlmox) .And. cAlmox == (cCursor)->B2_LOCAL
			nAtIni := Len(aViewB2)
		EndIf

		nTotDisp	+= nSaldoSB2
		nSaldo		+= nB2_QATU
		nQtPV		+= nB2_QPEDVEN
		nQemp		+= nB2_QEMP
		nSalpedi	+= nB2_SALPEDI
		nReserva	+= nB2_RESERVA
		nQempSA		+= nB2_QEMPSA
		nQtdTerc	+= nB2_QTNP
		nQtdNEmTerc	+= nB2_QNPT
		nSldTerc	+= nB2_QTER
		nQEmpN		+= nB2_QEMPN
		nQAClass	+= nB2_QACLASS
		nQEmpPrj    += nB2_QPRJ
		nQEmpPre    += nB2_QPRE
		dbSelectArea(cCursor)
		dbSkip()
	EndDo
	If lQuery
		dbSelectArea(cCursor)
		dbCloseArea()
		dbSelectArea("SB2")
	EndIf

	If !Empty(aViewB2)
		
		DEFINE FONT oBold NAME "Arial" SIZE 0, -12 BOLD
		DEFINE MSDIALOG oDlg FROM 000,000  TO 500,600 TITLE STR0045 Of oMainWnd PIXEL //"Saldos em Estoque"
		@ 023,004 To 24,296 Label "" of oDlg PIXEL
		@ 113,004 To 114,296 Label "" of oDlg PIXEL
		oListBox := TWBrowse():New( 30,2,297,69,,{STR0046,STR0047,STR0048,STR0049,STR0050,STR0051,STR0052,STR0053,RetTitle("B2_QTNP"),RetTitle("B2_QNPT"),RetTitle("B2_QTER"),RetTitle("B2_QEMPN"),RetTitle("B2_QACLASS"),RetTitle("B2_QEMPPRJ"),RetTitle("B2_QEMPPRE")},{17,55,55,55,55,55,55,55},oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,)  //"Local"###"Qtd.Disponivel"###"Sld.Atual"###"Qtd.Pedido de Vendas"###"Qtd. Empenhada"###"Qtd. Prevista Entrada"###"Qtd.Empenhada S.A."###"Qtd. Reservada"
		oListBox:SetArray(aViewB2)
		oListBox:bLine := { || aViewB2[oListBox:nAT]}
		oListBox:nAt   := Max(1,nAtIni)
		@ 004,010 SAY SM0->M0_CODIGO+"/"+FWCodFil()+" - "+SM0->M0_FILIAL+"/"+SM0->M0_NOME  Of oDlg PIXEL SIZE 245,009
		@ 014,010 SAY Alltrim(cProduto)+ " - "+SB1->B1_DESC Of oDlg PIXEL SIZE 245,009 FONT oBold
		@ 104,010 SAY STR0054 Of oDlg PIXEL SIZE 30 ,9 FONT oBold  //"TOTAL "
		
		@ 120,007 SAY STR0055 of oDlg PIXEL //"Quantidade Disponivel    "
		@ 119,075 MsGet nTotDisp Picture PesqPict("SB2","B2_QATU") of oDlg PIXEL SIZE 070,009 When .F.
		
		@ 120,155 SAY STR0059 of oDlg PIXEL //"Quantidade Empenhada "
		@ 119,223 MsGet nQemp Picture PesqPict("SB2","B2_QEMP") of oDlg PIXEL SIZE 070,009 When .F.
		
		@ 135,007 SAY STR0056 of oDlg PIXEL //"Saldo Atual   "
		@ 134,075 MsGet nSaldo Picture PesqPict("SB2","B2_QATU") of oDlg PIXEL SIZE 070,009 When .F.
		
		@ 135,155 SAY STR0060 of oDlg PIXEL //"Qtd. Entrada Prevista"
		@ 134,223 MsGet nSalPedi Picture PesqPict("SB2","B2_SALPEDI") of oDlg PIXEL SIZE 070,009 When .F.
		
		@ 150,007 SAY STR0057 of oDlg PIXEL //"Qtd. Pedido de Vendas  "
		@ 149,075 MsGet nQtPv Picture PesqPict("SB2","B2_QPEDVEN") of oDlg PIXEL SIZE 070,009 When .F.
		
		@ 150,155 SAY STR0061 of oDlg PIXEL //"Qtd. Reservada  "
		@ 149,223 MsGet nReserva Picture PesqPict("SB2","B2_RESERVA") of oDlg PIXEL SIZE 070,009 When .F.
		
		@ 165,007 SAY STR0058 of oDlg PIXEL //"Qtd. Empenhada S.A."
		@ 164,075 MsGet nQEmpSA Picture PesqPict("SB2","B2_QEMPSA") of oDlg PIXEL SIZE 070,009 When .F.
		
		@ 165,155 SAY RetTitle("B2_QTNP") of oDlg PIXEL
		@ 164,223 MsGet nQtdTerc Picture PesqPict("SB2","B2_QTNP") of oDlg PIXEL SIZE 070,009 When .F.
		
		@ 180,007 SAY RetTitle("B2_QNPT") of oDlg PIXEL
		@ 179,075 MsGet nQtdNEmTerc Picture PesqPict("SB2","B2_QNPT") of oDlg PIXEL SIZE 070,009 When .F.
		
		@ 180,155 SAY RetTitle("B2_QTER") of oDlg PIXEL 
		@ 179,223 MsGet nSldTerc Picture PesqPict("SB2","B2_QTER") of oDlg PIXEL SIZE 070,009 When .F.

		@ 195,007 SAY RetTitle("B2_QEMPN") of oDlg PIXEL 
		@ 194,075 MsGet nQEmpN Picture PesqPict("SB2","B2_QEMPN") of oDlg PIXEL SIZE 070,009 When .F.

		@ 195,155 SAY RetTitle("B2_QACLASS") of oDlg PIXEL 
		@ 194,223 MsGet nQAClass Picture PesqPict("SB2","B2_QACLASS") of oDlg PIXEL SIZE 070,009 When .F.

		@ 210,007 SAY RetTitle("B2_QEMPPRJ") of oDlg PIXEL 
		@ 209,075 MsGet nQEmpPrj Picture PesqPict("SB2","B2_QEMPPRJ") of oDlg PIXEL SIZE 070,009 When .F.
		
		@ 210,155 SAY RetTitle("B2_QEMPPRE") of oDlg PIXEL 
		@ 209,223 MsGet nQEmpPre Picture PesqPict("SB2","B2_QEMPPRE") of oDlg PIXEL SIZE 070,009 When .F.
   
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada para incluir campos na grid  e edits na tela de Consulta ao estoque ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("MTGRDVW")                                   
			ExecBlock("MTGRDVW",.F.,.F.,{@aViewB2,@oListBox,@oDlg})
		Endif 
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada para incluir Botao do Usuario na Dialog Saldos do SB2 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("BVIEWSB2") 
			@ 230,190 BUTTON STR0100 SIZE 045,010  FONT oDlg:oFont ACTION (ExecBlock("BVIEWSB2",.F.,.F.)) Of oDlg PIXEL //"Especifico"
		Endif

		@ 230,244  BUTTON STR0016 SIZE 045,010  FONT oDlg:oFont ACTION (oDlg:End())  OF oDlg PIXEL  //"Voltar"

		ACTIVATE MSDIALOG oDlg CENTERED
	Else
		Aviso(STR0014,STR0062,{STR0016},2) //"Atencao"###"Nao registro de estoques para este produto."###"Voltar"
	EndIf	
EndIf
RestArea(aAreaSM0)
RestArea(aAreaSB2)
RestArea(aAreaSB1)
RestArea(aArea)
SetFocus(nHdl)
Return(.T.)

 
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaViewPC ³ Autor ³ Edson Maricate        ³ Data ³15.10.1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de visualiza‡ao do pedido de compras.             ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void MaViewPc(ExpC1)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Numero do Pedido                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MaViewPC                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaViewPC(cPedido)

Local aArea		:= GetArea()
Local aAreaSC7	:= SC7->(GetArea())
Local aAreaSB1	:= SB1->(GetArea())
Private aRotina	:= {{ , , 0 , 2 }}
Private nTipoPed	:= 1
Private l120Auto	:= .F.

dbSelectArea("SC7")
dbSetOrder(1)
If MsSeek(xFilial("SC7")+cPedido)
	MatA120(SC7->C7_TIPO,,,2)
EndIf

RestArea(aAreaSC7)
RestArea(aAreaSB1)
RestArea(aArea)

Return(.T.)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaViewNF ³ Autor ³ Edson Maricate        ³ Data ³15.10.1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de visualiza‡ao da NF de Entrada                  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void MaViewNF(ExpN1)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Numero do registro de SD1                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MaViewNF                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaViewNF(nRecSD1)

Local aArea		:= GetArea()
Local aAreaSD1	:= SD1->(GetArea())
Local aAreaSF1	:= SF1->(GetArea())

dbSelectArea("SD1")
MsGoto(nRecSD1)

SF1->( DbSetOrder( 1 ) )
cSeekSF1:=xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA
If SF1->( dbSeek( cSeekSF1 ) )
	If cPaisLoc == "BRA"
		Private aRotina    := {{'' ,"A103NFiscal", 0, 2}}
        Private l103Auto   := .F.
        Private aAutoCab   := {}
        Private aAutoItens := {}
		A103NFiscal( "SF1", SF1->( Recno() ), 1 )
	Else
		VisualNfRem( "SF1", SF1->( Recno() ) )
	Endif
EndIf

RestArea(aAreaSD1)
RestArea(aAreaSF1)
RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaViewSC ³ Autor ³ Edson Maricate        ³ Data ³15.10.1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de visualiza‡ao das solicitacoes de compras.      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void MaViewSC(ExpC1)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Numero da Solicitacao                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MaViewSC                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaViewSC(cNumSC)

Local aArea		:= GetArea()
Local aAreaSC1	:= SC1->(GetArea())

dbSelectArea("SC1")
dbSetOrder(1)
If dbSeek(xFilial("SC1")+cNumSC)
	MATA110(,,2)
EndIf

RestArea(aAreaSC1)
RestArea(aArea)
Return(.T.)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaViewSA ³ Autor ³ Edson Maricate        ³ Data ³15.10.1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de visualiza‡ao das solicitacoes ao Almox.        ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void MaViewSA(ExpC1)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Numero da Solicitacao                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MaViewSA                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaViewSA(cNumSA)

Local aArea		:= GetArea()
Local aAreaSCP	:= SCP->(GetArea())

dbSelectArea("SCP")
dbSetOrder(1)
If dbSeek(xFilial("SCP")+cNumSA)
	MATA105(,,2)
EndIf

RestArea(aAreaSCP)
RestArea(aArea)
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaViewCT ³ Autor ³ Julio C.Guerato       ³ Data ³30.08.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de visualiza‡ao do Contrato de Parceria	          ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void MaViewCT(ExpC1)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Numero do Contrato                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MaViewCT                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaViewCT(cNumCT)

Local aArea		:= GetArea()
Local aAreaSC3	:= SC3->(GetArea())

dbSelectArea("SC3")
dbSetOrder(1)
If dbSeek(xFilial("SC3")+cNumCT)
	MATA125(,,2)
EndIf

RestArea(aAreaSC3)
RestArea(aArea)
Return(.T.)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaAtuSB6  ³ Autor ³ Eduardo Riera         ³ Data ³27.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do Poder de Terceiros                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpA1 := MaAtuSB6(ExpC1,ExpN1,ExpL1)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela de origem                             ³±±
±±³          ³ExpN1: Codigo do Evento da Rotina                            ³±±
±±³          ³       [1] Implantacao de um item do documento de entrada    ³±±
±±³          ³       [2] Estorno de um item do documento de entrada        ³±±
±±³          ³       [3] Implantacao de um item do documento de saida      ³±±
±±³          ³       [4] Estorno de um item do documento de saida          ³±±
±±³          ³ExpL1: Indica se a chamada ocorre por refaz SB6              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpA1: array com valores dos custos 	                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo atualizar o saldo de poder de  ³±±
±±³          ³terceiros e em terceiros conforme os parametros da rotina    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAtuSB6(cAlias,nEvento,lRefaz)

Local aArea     := GetArea()
Local aAreaSD2  := SD2->(GetArea())
Local aSB6      := {}
Local aStruSB6  := {}
Local aCustoSB6 := {0,0,0,0,0}
Local cAliasSB6 := "SB6"
Local lQuery    := .F.
Local cEstoque  := ""
Local nX        := 0
Local nQtdSB6   := 0
Local nSldSB6   := 0
Local nQtd2SB6  := 0
Local nSld2SB6  := 0
Local nRegSB6   := 0
Local nAuxReg   := 0
Local nQtdSB6Ori:= 0
Local nSldTesN3 := SuperGetMV("MV_SDTESN3",.F.,0)
Local cLocalSB2 := ""
Local cQuery    := ""

Default lRefaz := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ A460TESN3 - Ponto de entrada para considerar TES com atualiza estoque "N"  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Static lA460TESN3 := ExistBlock("A460TESN3")


Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualizacao do SB6 com base no SD1                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona registros                                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SF4")
	dbSetOrder(1)
	If xFilial("SF4")+(cAlias)->D1_TES <> SF4->F4_FILIAL+SF4->F4_CODIGO
		MsSeek(xFilial("SF4")+(cAlias)->D1_TES)
	EndIf
	cLocalSB2 := (cAlias)->D1_LOCAL
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o tipo de poder de terceiro                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Do Case
	Case SF4->F4_PODER3 == "R"
		RecLock("SB6",.T.)
		SB6->B6_FILIAL  := xFilial("SB6")
		SB6->B6_CLIFOR  := (cAlias)->D1_FORNECE
		SB6->B6_LOJA    := (cAlias)->D1_LOJA
		SB6->B6_PRODUTO	:= (cAlias)->D1_COD
		SB6->B6_LOCAL	:= (cAlias)->D1_LOCAL
		SB6->B6_PRUNIT 	:= (cAlias)->D1_VUNIT
		SB6->B6_TIPO	:= IIf(SF4->F4_PODER3=="R","D","E")
		SB6->B6_DOC 	:= (cAlias)->D1_DOC
		SB6->B6_SERIE	:= (cAlias)->D1_SERIE
		SB6->B6_EMISSAO	:= (cAlias)->D1_EMISSAO
		SB6->B6_DTDIGIT	:= (cAlias)->D1_DTDIGIT
		SB6->B6_TES     := (cAlias)->D1_TES
		SB6->B6_QUANT	:= (cAlias)->D1_QUANT
		SB6->B6_UM		:= (cAlias)->D1_UM
		SB6->B6_QTSEGUM	:= (cAlias)->D1_QTSEGUM
		SB6->B6_SEGUM   := (cAlias)->D1_SEGUM
		SB6->B6_PODER3 	:= SF4->F4_PODER3
		SB6->B6_TPCF    := IIf((cAlias)->D1_TIPO$"DB","C","F")
		SB6->B6_IDENT	:= (cAlias)->D1_NUMSEQ
		SB6->B6_SALDO	:= SB6->B6_QUANT
		If (cAlias)->D1_TIPO$"CIP"
			If (cAlias)->D1_IDENTB6 <> SB6->B6_IDENT
				SB6->B6_IDENTB6 := (cAlias)->D1_IDENTB6
			EndIf
			If Empty(SB6->B6_IDENTB6)
				nAuxReg := (cAlias)->(RecNo())
				dbSelectArea("SD1")
				dbSetOrder(1)
				If MsSeek(xFilial("SD1")+(cAlias)->D1_NFORI+(cAlias)->D1_SERIORI+(cAlias)->D1_FORNECE+(cAlias)->D1_LOJA+(cAlias)->D1_COD+(cAlias)->D1_ITEMORI)
					SB6->B6_IDENTB6 := (cAlias)->D1_IDENTB6
				EndIf
				(cAlias)->(MsGoto(nAuxReg))
			EndIf
		EndIf
		SB6->B6_ESTOQUE := SF4->F4_ESTOQUE
		cEstoque := SB6->B6_ESTOQUE
		If cEstoque == "S" .Or. lA460TESN3 .Or. (nSldTesN3 <> 0)
			SB6->B6_CUSTO1 := (cAlias)->D1_CUSTO
			SB6->B6_CUSTO2 := (cAlias)->D1_CUSTO2
			SB6->B6_CUSTO3 := (cAlias)->D1_CUSTO3
			SB6->B6_CUSTO4 := (cAlias)->D1_CUSTO4
			SB6->B6_CUSTO5 := (cAlias)->D1_CUSTO5
			SB6->B6_CUSFF1 := (cAlias)->D1_CUSFF1
			SB6->B6_CUSFF2 := (cAlias)->D1_CUSFF2
			SB6->B6_CUSFF3 := (cAlias)->D1_CUSFF3
			SB6->B6_CUSFF4 := (cAlias)->D1_CUSFF4
			SB6->B6_CUSFF5 := (cAlias)->D1_CUSFF5
		EndIf
		If ExistBlock("SB6GRAVA")
			ExecBlock("SB6GRAVA",.F.,.F.)
		EndIf
		aCustoSB6 := {SB6->B6_CUSTO1,;
			SB6->B6_CUSTO2,;
			SB6->B6_CUSTO3,;
			SB6->B6_CUSTO4,;
			SB6->B6_CUSTO5}
		SB6->(MsUnLock())
	Case SF4->F4_PODER3 == "D"
		
		aStruSB6  := SB6->(dbStruct())
		
		dbSelectArea("SB6")
		dbSetOrder(3)
		lQuery := .T.
		cAliasSB6 := "MaAtuSB6"
		
		cQuery := "SELECT SB6.*,R_E_C_N_O_ SB6RECNO "
		cQuery += "FROM "+RetSqlName("SB6")+" SB6 "
		cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' AND "
		cQuery += "SB6.B6_IDENT = '"+(cAlias)->D1_IDENTB6+"' AND "
		cQuery += "SB6.B6_PRODUTO = '"+(cAlias)->D1_COD+"' AND "
		cQuery += "SB6.B6_SALDO > 0 AND "
		cQuery += "SB6.B6_PODER3 = 'R' AND "
		cQuery += "SB6.D_E_L_E_T_=' ' "
		cQuery += "ORDER BY "+SqlOrder(SB6->(IndexKey()))
		
		cQuery := ChangeQuery(cQuery)
		
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.T.,.T.)
		
		For nX := 1 To Len(aStruSB6)
			If aStruSB6[nX][2] <> "C"
				TcSetField(cAliasSB6,aStruSB6[nX][1],aStruSB6[nX][2],aStruSB6[nX][3],aStruSB6[nX][4])
			EndIf
		Next nX
		
		nSldSB6  := (cAlias)->D1_QUANT
		nSld2SB6 := (cAlias)->D1_QTSEGUM
		
		While !Eof() .And. 	xFilial("SB6") == (cAliasSB6)->B6_FILIAL .And.;
				(cAliasSB6)->B6_IDENT == (cAlias)->D1_IDENTB6 .And.;
				(cAliasSB6)->B6_PRODUTO == (cAlias)->D1_COD .And.;
				nSldSB6 > 0
			If (cAliasSB6)->B6_SALDO > 0 .And. (cAliasSB6)->B6_PODER3 == "R"
				cLocalSB2 := (cAliasSB6)->B6_LOCAL
				nQtdSB6Ori:=(cAliasSB6)->B6_QUANT
				nQtdSB6  := Min((cAliasSB6)->B6_SALDO,nSldSB6)
				nQtd2SB6 := nSld2SB6
				nSldSB6  -= nQtdSB6
				If lQuery
					SB6->(MsGoto((cAliasSB6)->SB6RECNO))
				Else
					nRegSB6 := SB6->(RecNo())
				EndIf
				RecLock("SB6",.F.)
				aSB6 := {}
				For nX := 1 To Len(aStruSB6)
					aadd(aSB6,FieldGet(FieldPos(aStruSB6[nX][1])))
				Next nX
				SB6->B6_SALDO  -= nQtdSB6
				SB6->B6_UENT   := (cAlias)->D1_DTDIGIT
				SB6->B6_ATEND  := IIf(SB6->B6_SALDO<=0,"S","")
				cEstoque       := SB6->B6_ESTOQUE
				
				RecLock("SB6",.T.)
				For nX := 1 To Len(aStruSB6)
					FieldPut(nX,aSB6[nX])
				Next nX
				SB6->B6_CLIFOR  := (cAlias)->D1_FORNECE
				SB6->B6_LOJA    := (cAlias)->D1_LOJA
                SB6->B6_LOCAL   := (cAlias)->D1_LOCAL
				SB6->B6_SERIE   := (cAlias)->D1_SERIE
				SB6->B6_DOC     := (cAlias)->D1_DOC
				SB6->B6_TES     := (cAlias)->D1_TES
				SB6->B6_DTDIGIT := (cAlias)->D1_DTDIGIT
				SB6->B6_EMISSAO := (cAlias)->D1_EMISSAO
				SB6->B6_PODER3 	:= IIF(SB6->B6_PODER3=="R","D","R")
				SB6->B6_QUANT   := nQtdSB6
				SB6->B6_QTSEGUM := nQtd2SB6
				SB6->B6_UENT    := Ctod("")		
				SB6->B6_CUSTO1*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSTO2*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSTO3*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSTO4*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSTO5*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSFF1*= (nQtdSB6/nQtdSB6Ori)  
				SB6->B6_CUSFF2*= (nQtdSB6/nQtdSB6Ori)  
				SB6->B6_CUSFF3*= (nQtdSB6/nQtdSB6Ori)  
				SB6->B6_CUSFF4*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSFF5*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_SALDO   := 0
				SB6->B6_QULIB   := 0
				If ExistBlock("SB6GRAVA")
					ExecBlock("SB6GRAVA",.f.,.f.)
				EndIf
				aCustoSB6 := {SB6->B6_CUSTO1,;
					SB6->B6_CUSTO2,;
					SB6->B6_CUSTO3,;
					SB6->B6_CUSTO4,;
					SB6->B6_CUSTO5}						
				SB6->(MsUnLock())
				If !lQuery
					SB6->(MsGoto(nRegSB6))
					SB6->(MsUnLock())
				EndIf
			EndIf					
			dbSelectArea(cAliasSB6)
			dbSkip()
		EndDo
		If lQuery
			dbSelectArea(cAliasSB6)
			dbCloseArea()
			dbSelectArea("SB6")
		EndIf
	EndCase		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza os acumulados do poder de terceiro                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If xFilial("SB2")+(cAlias)->D1_COD+cLocalSB2 <> SB2->B2_FILIAL+SB2->B2_COD+SB2->B2_LOCAL
		If !MsSeek(xFilial("SB2")+(cAlias)->D1_COD+cLocalSB2)
			CriaSb2((cAlias)->D1_COD,cLocalSB2)
		EndIf
	EndIf
	RecLock("SB2")
	If ( SF4->F4_PODER3 $ "DR" )
		If ( SF4->F4_PODER3 == "D" )
			If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
				SB2->B2_QTER -= (cAlias)->D1_QUANT
			Else
				SB2->B2_QNPT -= (cAlias)->D1_QUANT
			EndIf
		Else
			If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
				SB2->B2_QTER += (cAlias)->D1_QUANT
			Else
				SB2->B2_QTNP += (cAlias)->D1_QUANT
			EndIf
		EndIf
	EndIf
	SB2->(MsUnLock())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o identificador de poder de terceiro                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cAlias=="SD1" .And. SF4->F4_PODER3=="R"
		RecLock("SD1")
		SD1->D1_IDENTB6 := SD1->D1_NUMSEQ
		If lRefaz
			MsUnlock()		
		EndIf
	EndIf
Case nEvento == 2    

	cLocalSB2 := (cAlias)->D1_LOCAL

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona registros                                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SF4")
	dbSetOrder(1)
	If xFilial("SF4")+(cAlias)->D1_TES <> SF4->F4_FILIAL+SF4->F4_CODIGO .And. (cAlias)->D1_TES<="500"
		MsSeek(xFilial("SF4")+(cAlias)->D1_TES)
	EndIf
	dbSelectArea("SB2")
	dbSetOrder(1)
	If xFilial("SB2")+(cAlias)->D1_COD+(cAlias)->D1_LOCAL <> SB2->B2_FILIAL+SB2->B2_COD+SB2->B2_LOCAL
		If !MsSeek(xFilial("SB2")+(cAlias)->D1_COD+(cAlias)->D1_LOCAL)
			CriaSb2((cAlias)->D1_COD,(cAlias)->D1_LOCAL)
		EndIf
	EndIf		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o tipo de poder de terceiro                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Do Case
	Case SF4->F4_PODER3=="R"
		dbSelectArea("SB6")
		dbSetOrder(3)
		If MsSeek(xFilial("SB6")+(cAlias)->D1_NUMSEQ+(cAlias)->D1_COD+"R")
			RecLock("SB6",.F.,.T.)
			cEstoque := SB6->B6_ESTOQUE
			dbDelete()
			MsUnlock()
		EndIf
	Case SF4->F4_PODER3=="D"
		dbSelectArea("SB6")
		dbSetOrder(3)
		If MsSeek(xFilial("SB6")+(cAlias)->D1_IDENTB6+(cAlias)->D1_COD+"R")
			RecLock("SB6",.F.)
			cEstoque := SB6->B6_ESTOQUE
			SB6->B6_UENT	:= Ctod("")
			SB6->B6_SALDO	:= SB6->B6_SALDO + (cAlias)->D1_QUANT
			SB6->B6_ATEND	:= IIf(SB6->B6_SALDO <= 0,"S","N")
			MsUnLock()
			
			aStruSB6  := SB6->(dbStruct())
			
			dbSelectArea("SB6")
			dbSetOrder(3)

			lQuery := .T.
			cAliasSB6 := "MaAtuSB6"
			
			cQuery := "SELECT SB6.*,R_E_C_N_O_ SB6RECNO "
			cQuery += "FROM "+RetSqlName("SB6")+" SB6 "
			cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' AND "
			cQuery += "SB6.B6_IDENT = '"+(cAlias)->D1_IDENTB6+"' AND "
			cQuery += "SB6.B6_PRODUTO = '"+(cAlias)->D1_COD+"' AND "
			cQuery += "SB6.B6_PODER3 = 'D' AND "
			cQuery += "SB6.B6_SERIE = '"+(cAlias)->D1_SERIE+"' AND "
			cQuery += "SB6.B6_DOC = '"+(cAlias)->D1_DOC+"' AND "
			cQuery += "SB6.D_E_L_E_T_=' ' "
			cQuery += "ORDER BY "+SqlOrder(SB6->(IndexKey()))
			
			cQuery := ChangeQuery(cQuery)
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.T.,.T.)
			
			For nX := 1 To Len(aStruSB6)
				If aStruSB6[nX][2] <> "C"
					TcSetField(cAliasSB6,aStruSB6[nX][1],aStruSB6[nX][2],aStruSB6[nX][3],aStruSB6[nX][4])
				EndIf
			Next nX

			While !Eof() .And. 	xFilial("SB6") == (cAliasSB6)->B6_FILIAL .And.;
					(cAliasSB6)->B6_IDENT == (cAlias)->D1_IDENTB6 .And.;
					(cAliasSB6)->B6_PRODUTO == (cAlias)->D1_COD
				
				If (cAliasSB6)->B6_SERIE == (cAlias)->D1_SERIE .And.;
						(cAliasSB6)->B6_DOC == (cAlias)->D1_DOC .And.;
						(cAliasSB6)->B6_PODER3 == "D"
					
					If lQuery
						SB6->(MsGoto((cAliasSB6)->SB6RECNO))
					EndIf
					
					RecLock("SB6",.F.)
					dbDelete()
					MsUnlock()
					
					Exit
					
				EndIf
				dbSelectArea(cAliasSB6)
				dbSkip()
			EndDo
			If lQuery
				dbSelectArea(cAliasSB6)
				dbCloseArea()
				dbSelectArea("SB6")
			EndIf
		EndIf
	EndCase
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza os acumulados do poder de terceiro                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SF4->F4_PODER3 $ "DR" )
		If ( SF4->F4_PODER3 == "D" )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Busca o local original do SB6 para atualizar o armazem correto         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB6")
			dbSetOrder(3)
			If MsSeek(xFilial("SB6")+(cAlias)->D1_IDENTB6+(cAlias)->D1_COD+"R")		
				cLocalSB2 := SB6->B6_LOCAL
			Endif				

			dbSelectArea("SB2")
			dbSetOrder(1)
			If MsSeek(xFilial("SB2")+(cAlias)->D1_COD+cLocalSB2)
		
				RecLock("SB2")					
				If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
					SB2->B2_QTER += (cAlias)->D1_QUANT
				Else
					SB2->B2_QNPT += (cAlias)->D1_QUANT
				EndIf
			Endif	
			
		Else
		
			RecLock("SB2")
			If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
				SB2->B2_QTER -= (cAlias)->D1_QUANT
			Else
				SB2->B2_QTNP -= (cAlias)->D1_QUANT
			EndIf
		EndIf
	EndIf
	SB2->(MsUnLock())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualizacao do SB6 com base no SD2                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 3
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona registros                                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SF4")
	dbSetOrder(1)
	If xFilial("SF4")+(cAlias)->D2_TES <> SF4->F4_FILIAL+SF4->F4_CODIGO
		MsSeek(xFilial("SF4")+(cAlias)->D2_TES)
	EndIf
	cLocalSB2 := (cAlias)->D2_LOCAL
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o tipo de poder de terceiro                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Do Case
	Case SF4->F4_PODER3 == "R"
		RecLock("SB6",.T.)
		SB6->B6_FILIAL  := xFilial("SB6")
		SB6->B6_CLIFOR  := (cAlias)->D2_CLIENTE
		SB6->B6_LOJA    := (cAlias)->D2_LOJA
		SB6->B6_PRODUTO	:= (cAlias)->D2_COD
		SB6->B6_LOCAL	:= (cAlias)->D2_LOCAL
		SB6->B6_PRUNIT 	:= (cAlias)->D2_PRCVEN
		SB6->B6_TIPO	:= IIf(SF4->F4_PODER3=="R","E","D")
		SB6->B6_DOC 	:= (cAlias)->D2_DOC
		SB6->B6_SERIE	:= (cAlias)->D2_SERIE
		SB6->B6_EMISSAO	:= (cAlias)->D2_EMISSAO
		SB6->B6_DTDIGIT	:= (cAlias)->D2_EMISSAO
		SB6->B6_TES     := (cAlias)->D2_TES
		SB6->B6_QUANT	:= (cAlias)->D2_QUANT
		SB6->B6_UM		:= (cAlias)->D2_UM
		SB6->B6_QTSEGUM	:= (cAlias)->D2_QTSEGUM
		SB6->B6_SEGUM   := (cAlias)->D2_SEGUM
		SB6->B6_PODER3 	:= SF4->F4_PODER3
		SB6->B6_TPCF    := IIf((cAlias)->D2_TIPO$"DB","F","C")
		SB6->B6_IDENT	:= (cAlias)->D2_NUMSEQ
		SB6->B6_SALDO	:= SB6->B6_QUANT
		If (cAlias)->D2_TIPO$"CIP"
			If (cAlias)->D2_IDENTB6 <> SB6->B6_IDENT
				SB6->B6_IDENTB6 := (cAlias)->D2_IDENTB6
			EndIf
			If Empty(SB6->B6_IDENTB6)
				nAuxReg := (cAlias)->(RecNo())
				dbSelectArea("SD2")
				dbSetOrder(3)
				If MsSeek(xFilial("SD2")+(cAlias)->D2_NFORI+(cAlias)->D2_SERIORI+(cAlias)->D2_CLIENTE+(cAlias)->D2_LOJA+(cAlias)->D2_COD+(cAlias)->D2_ITEMORI)
					SB6->B6_IDENTB6 := SD2->D2_IDENTB6
				EndIf
				(cAlias)->(MsGoto(nAuxReg))
			EndIf
		EndIf
		SB6->B6_ESTOQUE := SF4->F4_ESTOQUE
		cEstoque := SB6->B6_ESTOQUE
		If cEstoque == "S" .Or. lA460TESN3 .Or. (nSldTesN3 <> 0)
			SB6->B6_CUSTO1 := (cAlias)->D2_CUSTO1
			SB6->B6_CUSTO2 := (cAlias)->D2_CUSTO2
			SB6->B6_CUSTO3 := (cAlias)->D2_CUSTO3
			SB6->B6_CUSTO4 := (cAlias)->D2_CUSTO4
			SB6->B6_CUSTO5 := (cAlias)->D2_CUSTO5
			SB6->B6_CUSFF1 := (cAlias)->D2_CUSFF1
			SB6->B6_CUSFF2 := (cAlias)->D2_CUSFF2
			SB6->B6_CUSFF3 := (cAlias)->D2_CUSFF3
			SB6->B6_CUSFF4 := (cAlias)->D2_CUSFF4
			SB6->B6_CUSFF5 := (cAlias)->D2_CUSFF5
		EndIf
		If ExistBlock("SB6GRAVA")
			ExecBlock("SB6GRAVA",.F.,.F.)
		EndIf
		aCustoSB6 := {SB6->B6_CUSTO1,;
			SB6->B6_CUSTO2,;
			SB6->B6_CUSTO3,;
			SB6->B6_CUSTO4,;
			SB6->B6_CUSTO5}
		SB6->(MsUnLock())
	Case SF4->F4_PODER3 == "D"
		
		aStruSB6  := SB6->(dbStruct())
		
		dbSelectArea("SB6")
		dbSetOrder(3)
		
		lQuery := .T.
		cAliasSB6 := "MaAtuSB6"
		
		cQuery := "SELECT SB6.*,R_E_C_N_O_ SB6RECNO "
		cQuery += "FROM "+RetSqlName("SB6")+" SB6 "
		cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' AND "
		cQuery += "SB6.B6_IDENT = '"+(cAlias)->D2_IDENTB6+"' AND "
		cQuery += "SB6.B6_PRODUTO = '"+(cAlias)->D2_COD+"' AND "
		cQuery += "SB6.B6_SALDO > 0 AND "
		cQuery += "SB6.B6_PODER3 = 'R' AND "
		cQuery += "SB6.D_E_L_E_T_=' ' "
		cQuery += "ORDER BY "+SqlOrder(SB6->(IndexKey()))
		
		cQuery := ChangeQuery(cQuery)
		
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.T.,.T.)
		
		For nX := 1 To Len(aStruSB6)
			If aStruSB6[nX][2] <> "C"
				TcSetField(cAliasSB6,aStruSB6[nX][1],aStruSB6[nX][2],aStruSB6[nX][3],aStruSB6[nX][4])
			EndIf
		Next nX
		
		nSldSB6  := (cAlias)->D2_QUANT
		nSld2SB6 := (cAlias)->D2_QTSEGUM
		
		While !Eof() .And. 	xFilial("SB6") == (cAliasSB6)->B6_FILIAL .And.;
				(cAliasSB6)->B6_IDENT == (cAlias)->D2_IDENTB6 .And.;
				(cAliasSB6)->B6_PRODUTO == (cAlias)->D2_COD .And.;
				nSldSB6 > 0
			If (cAliasSB6)->B6_SALDO > 0 .And. (cAliasSB6)->B6_PODER3 == "R"
				nQtdSB6Ori:=(cAliasSB6)->B6_QUANT
				nQtdSB6  := Min((cAliasSB6)->B6_SALDO,nSldSB6)
				nQtd2SB6 := nSld2SB6
				nSldSB6  -= nQtdSB6
				cLocalSB2:= (cAliasSB6)->B6_LOCAL
				If lQuery
					SB6->(MsGoto((cAliasSB6)->SB6RECNO))
				Else
					nRegSB6 := SB6->(RecNo())
				EndIf
				
				RecLock("SB6",.F.)
				If SB6->B6_QULIB > 0
					SB6->B6_QULIB -= nQtdSB6
				EndIf
				SB6->B6_SALDO  -= nQtdSB6
				SB6->B6_UENT   := (cAlias)->D2_EMISSAO
				SB6->B6_ATEND  := IIf(SB6->B6_SALDO<=0,"S","")
				cEstoque       := SB6->B6_ESTOQUE
				
				aSB6 := {}
				For nX := 1 To Len(aStruSB6)
					aadd(aSB6,FieldGet(FieldPos(aStruSB6[nX][1])))
				Next nX				
				RecLock("SB6",.T.)
				For nX := 1 To Len(aStruSB6)
					FieldPut(nX,aSB6[nX])
				Next nX
				SB6->B6_CLIFOR  := (cAlias)->D2_CLIENTE
				SB6->B6_LOJA    := (cAlias)->D2_LOJA				
				SB6->B6_SERIE   := (cAlias)->D2_SERIE
				SB6->B6_DOC     := (cAlias)->D2_DOC
				SB6->B6_TES     := (cAlias)->D2_TES
				SB6->B6_DTDIGIT := (cAlias)->D2_EMISSAO
				SB6->B6_EMISSAO	:= (cAlias)->D2_EMISSAO
				SB6->B6_PODER3 	:= IIF(SB6->B6_PODER3=="R","D","R")
				SB6->B6_QUANT   := nQtdSB6
				SB6->B6_QTSEGUM := nQtd2SB6
				SB6->B6_UENT    := Ctod("")						
				SB6->B6_CUSTO1*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSTO2*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSTO3*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSTO4*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSTO5*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSFF1*= (nQtdSB6/nQtdSB6Ori)  
				SB6->B6_CUSFF2*= (nQtdSB6/nQtdSB6Ori)  
				SB6->B6_CUSFF3*= (nQtdSB6/nQtdSB6Ori)  
				SB6->B6_CUSFF4*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_CUSFF5*= (nQtdSB6/nQtdSB6Ori)
				SB6->B6_SALDO   := 0						
				SB6->B6_UENT   := Ctod("")
				SB6->B6_ATEND  := ""
				SB6->B6_QULIB  := 0
				If ExistBlock("SB6GRAVA")
					ExecBlock("SB6GRAVA",.f.,.f.)
				EndIf
				aCustoSB6 := {SB6->B6_CUSTO1,;
					SB6->B6_CUSTO2,;
					SB6->B6_CUSTO3,;
					SB6->B6_CUSTO4,;
					SB6->B6_CUSTO5}						
				SB6->(MsUnLock())
				If !lQuery
					SB6->(MsGoto(nRegSB6))
					SB6->(MsUnLock())
				EndIf
			EndIf					
			dbSelectArea(cAliasSB6)
			dbSkip()
		EndDo
		If lQuery
			dbSelectArea(cAliasSB6)
			dbCloseArea()
			dbSelectArea("SB6")
		EndIf
	EndCase
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza os acumulados do poder de terceiro                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If xFilial("SB2")+(cAlias)->D2_COD+cLocalSB2 <> SB2->B2_FILIAL+SB2->B2_COD+SB2->B2_LOCAL
		If !MsSeek(xFilial("SB2")+(cAlias)->D2_COD+cLocalSB2)
			CriaSb2((cAlias)->D2_COD,cLocalSB2)
		EndIf
	EndIf		
	RecLock("SB2")
	If ( SF4->F4_PODER3 $ "DR" )
		If ( SF4->F4_PODER3 == "D" )
			If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
				SB2->B2_QTER -= (cAlias)->D2_QUANT
			Else
				SB2->B2_QTNP -= (cAlias)->D2_QUANT
			EndIf			
		Else
			If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
				SB2->B2_QTER += (cAlias)->D2_QUANT
			Else
				SB2->B2_QNPT += (cAlias)->D2_QUANT
			EndIf
		EndIf
	EndIf
	SB2->(MsUnLock())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o identificador de poder de terceiro                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cAlias=="SD2" .And. SF4->F4_PODER3=="R"
		RecLock("SD2")
		SD2->D2_IDENTB6 := SD2->D2_NUMSEQ
		If lRefaz
			MsUnlock()		
		EndIf	
	EndIf

Case nEvento == 4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona registros                                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SF4")
	dbSetOrder(1)
	If xFilial("SF4")+(cAlias)->D2_TES <> SF4->F4_FILIAL+SF4->F4_CODIGO
		MsSeek(xFilial("SF4")+(cAlias)->D2_TES)
	EndIf
	cLocalSB2 := (cAlias)->D2_LOCAL
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o tipo de poder de terceiro                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Do Case
	Case SF4->F4_PODER3=="R"
		dbSelectArea("SB6")
		dbSetOrder(3)
		If MsSeek(xFilial("SB6")+(cAlias)->D2_NUMSEQ+(cAlias)->D2_COD+"R")
			RecLock("SB6",.F.,.T.)
			cEstoque := SB6->B6_ESTOQUE
			dbDelete()
			MsUnlock()
		EndIf
	Case SF4->F4_PODER3=="D"
		dbSelectArea("SB6")
		dbSetOrder(3)
		If MsSeek(xFilial("SB6")+(cAlias)->D2_IDENTB6+(cAlias)->D2_COD+"R")
			RecLock("SB6",.F.)
			SB6->B6_UENT	:= Ctod("")
			SB6->B6_SALDO	:= SB6->B6_SALDO + (cAlias)->D2_QUANT
			SB6->B6_ATEND	:= IIf(SB6->B6_SALDO <= 0,"S","N")
			cEstoque        := SB6->B6_ESTOQUE
			cLocalSB2       := SB6->B6_LOCAL
			MsUnLock()
			
			aStruSB6  := SB6->(dbStruct())
			
			dbSelectArea("SB6")
			dbSetOrder(3)

			lQuery := .T.
			cAliasSB6 := "MaAtuSB6"
			
			cQuery := "SELECT SB6.*,R_E_C_N_O_ SB6RECNO "
			cQuery += "FROM "+RetSqlName("SB6")+" SB6 "
			cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' AND "
			cQuery += "SB6.B6_IDENT = '"+(cAlias)->D2_IDENTB6+"' AND "
			cQuery += "SB6.B6_PRODUTO = '"+(cAlias)->D2_COD+"' AND "
			cQuery += "SB6.B6_PODER3 = 'D' AND "
			cQuery += "SB6.B6_SERIE = '"+(cAlias)->D2_SERIE+"' AND "
			cQuery += "SB6.B6_DOC = '"+(cAlias)->D2_DOC+"' AND "
			cQuery += "SB6.D_E_L_E_T_=' ' "
			cQuery += "ORDER BY "+SqlOrder(SB6->(IndexKey()))
			
			cQuery := ChangeQuery(cQuery)
			
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.T.,.T.)
			
			For nX := 1 To Len(aStruSB6)
				If aStruSB6[nX][2] <> "C"
					TcSetField(cAliasSB6,aStruSB6[nX][1],aStruSB6[nX][2],aStruSB6[nX][3],aStruSB6[nX][4])
				EndIf
			Next nX

			While !Eof() .And. 	xFilial("SB6") == (cAliasSB6)->B6_FILIAL .And.;
					(cAliasSB6)->B6_IDENT == (cAlias)->D2_IDENTB6 .And.;
					(cAliasSB6)->B6_PRODUTO == (cAlias)->D2_COD
				
				If (cAliasSB6)->B6_SERIE == (cAlias)->D2_SERIE .And.;
						(cAliasSB6)->B6_DOC == (cAlias)->D2_DOC .And.;
						(cAliasSB6)->B6_PODER3 == "D"
					
					If lQuery
						SB6->(MsGoto((cAliasSB6)->SB6RECNO))
					EndIf
					
					RecLock("SB6",.F.)
					dbDelete()
					MsUnlock()
					
					Exit
					
				EndIf
				dbSelectArea(cAliasSB6)
				dbSkip()
			EndDo
			If lQuery
				dbSelectArea(cAliasSB6)
				dbCloseArea()
				dbSelectArea("SB6")
			EndIf
		EndIf
	EndCase
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza os acumulados do poder de terceiro                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If xFilial("SB2")+(cAlias)->D2_COD+cLocalSB2 <> SB2->B2_FILIAL+SB2->B2_COD+SB2->B2_LOCAL
		If !MsSeek(xFilial("SB2")+(cAlias)->D2_COD+cLocalSB2)
			CriaSb2((cAlias)->D2_COD,cLocalSB2)
		EndIf
	EndIf		
	RecLock("SB2")
	If ( SF4->F4_PODER3 $ "DR" )
		If ( SF4->F4_PODER3 == "D" )
			If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
				SB2->B2_QTER += (cAlias)->D2_QUANT
			Else
				SB2->B2_QTNP += (cAlias)->D2_QUANT
			EndIf			
		Else
			If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
				SB2->B2_QTER -= (cAlias)->D2_QUANT
			Else
				SB2->B2_QNPT -= (cAlias)->D2_QUANT
			EndIf
		EndIf
	EndIf
	SB2->(MsUnLock())
EndCase

RestArea(aAreaSD2)
RestArea(aArea)
Return(aCustoSB6)


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³F4Poder3  ³ Autor ³ Eduardo Riera         ³ Data ³27.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³             !!! Obs.: Funcao alterada em 22/03/2006 !!!                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Consulta as documentos de poder de/em terceiros              ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := F4Poder3(ExpC1,ExpC2,ExpC3,ExpC4,ExpC5,ExpC6,ExpN1, ³±±
±±³          ³		    	    ExpC7,ExpC8)                       		   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do produto                                     ³±±
±±³          ³ExpC2: Almoxarifado                                          ³±±
±±³          ³ExpC3: Tipo do documento                                     ³±±
±±³          ³       [N] Normal                                            ³±±
±±³          ³       [B] Beneficiamento                                    ³±±
±±³          ³ExpC4: Tipo da operacao                                      ³±±
±±³          ³       [E] Entrada                                           ³±±
±±³          ³       [B] Saida                                             ³±±
±±³          ³ExpC5: Codigo do cliente/fornecedor                          ³±±
±±³          ³ExpC6: Loja do cliente/fornecedor                            ³±±
±±³          ³ExpN1: Codigo do registro da tabela selecionada              ³±±
±±³          ³ExpC7: tipo de atualizacao de estoque                        ³±±
±±³          ³ExpC8: Numero do pedido de venda                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. / .F.                                                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo realizar a interface com r de  ³±±
±±³          ³terceiros e em terceiros conforme os parametros da rotina    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function F4Poder3(cProduto,cLocal,cTpNF,cES,cCliFor,cLoja,nRegistro,cEstoque,cNumPV)

Local aArea     := GetArea()
Local aOrdem    := {AllTrim(RetTitle("F2_DOC"))+"+"+AllTrim(RetTitle("F2_SERIE")) ;
					,AllTrim(RetTitle("F2_EMISSAO")) ;
					,AllTrim(RetTitle("B6_IDENT")) ;
					,STR0149+"+"+STR0150+"+"+STR0151+"+"+STR0152 ; // "Ser.Doc.Vinc"##"Doc.Vinc."##"For.Doc.Vinc"##"Loja Doc.Vin."
					}
Local aChave    := {"B6_DOC+B6_SERIE","B6_EMISSAO","B6_IDENT","DH_DOC+DH_SERIE"}
Local aPesq     := {{Space(Len(SD1->D1_DOC+SD1->D1_SERIE)),"@!"},{Ctod(""),"@!"},{Space(Len(SB6->B6_IDENT)),"@!"},{Space(Len(SDH->DH_DOC+SDH->DH_SERIE)),"@!"}}
Local aHeadTrb  := {}
Local aStruTrb  := {}
Local aStruTrbO := {}
Local aSize     := MsAdvSize( .F. )
Local aObjects  := {}
Local aInfo     := {}
Local aPosObj   := {}
Local aNomInd   := {}
Local aSavHead  := aClone(aHeader)
Local aRegSB6   := {}
Local cTpCliFor := IIf((cES=="E" .And. !cTpNF$"DB").Or.(cES=="S" .And. cTpNF$"DB"),"F","C")
Local cAliasSD1 := "SD1"
Local cAliasSD2 := "SD2"
Local cAliasSB6 := "SB6"
Local cAliasTRB := "F4PODER3"
Local cCampo    := ""
Local cCampoTRB := ""
Local cNomeTrb  := ""
Local cQuery    := ""
Local cQuery1   := ""
Local cQuery2   := ""
Local cQuery3   := ""
Local cCombo    := ""
Local cTexto1   := ""
Local cTexto2   := ""
Local cReadVar  := ReadVar()
Local nHandle   := GetFocus()
Local nX        := 0
Local nSldQtd   := 0
Local nSldBru   := 0
Local nSldLiq   := 0
Local nComplPrc := 0
Local nOpcA     := 0
Local nPNfOri   := 0
Local nPSerOri  := 0
Local nPItemOri := 0
Local nPLocal   := 0
Local nPPrUnit  := 0
Local nPPrcVen  := 0
Local nPQuant   := 0
Local nPQuant2UM:= 0
Local nPLoteCtl := 0
Local nPNumLote := 0
Local nPDtValid := 0
Local nPPotenc  := 0
Local nPValor   := 0
Local nPValDesc := 0
Local nPDesc    := 0
Local nPIdentB6 := 0 
Local nPItem    := 0 
Local nPUnit    := 0 
Local nPTES     := 0
Local nPosLocal := 0
Local nPAlmTerc := 0
Local nPE		:= 0
Local nPos		:= 0
Local nCampos	:= 0
Local lQuery    := .F.
Local lRetorno  := .F.
Local lProcessa := .T.
Local lCria     := .F.
Local lMtProcP3 := ExistBlock("MTPROCP3")
Local lMTF4PD3I := ExistBlock("MTF4PD3I")
Local lMTF4P3UN := ExistBlock("MTF4P3UN") .And. ExecBlock("MTF4P3UN",.F.,.F.)
Local xPesq     := ""
Local cSeekSD7  := ""
Local cSeekSD1  := ""
Local oDlg
Local oPanel
Local oCombo
Local oGet
Local oGetDb
Local cLocalCQ	:= GetMvNNR('MV_CQ','98')
Local aArmazenCQ:= {},aTextoCQ:={}
Local aNew		:= {}
Local aNewCP	:= {}
Local lMtFillP3	:= ExistBlock("MTFILLP3")
Local aNF		:= {}
Local cNF		:= ""
Local aValNFR	:= {}
Local aValNFD	:= {}
Local aValNF	:= {}
Local nY		:= 0
Local nZ		:= 0
Local aA440VCOL	:= {}
Local nDecSB6	:= 0
Local lOpTriang	:= IsTriangular()
Local nDecD2Tot	:= TamSx3("D2_PRCVEN")[2]
Local nDecD1Tot	:= TamSx3("D1_VUNIT")[2]
Local nTamLote	:= TamSx3("D1_LOTECTL")[1]
Local nTamSLote	:= TamSx3("D1_NUMLOTE")[1]
Local aFiliais	:= {xFilial("SD1"),xFilial("SD2"),xFilial("SB6"),xFilial("SC6")}
Local aChaveSep	:= {}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MV_VLDDATA - Valida data de emissao do documento de beneficiamento  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lVldData	:= SuperGetMv("MV_VLDDATA",.F.,.T.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MV_DATAPD3 - numero default de dias retroativos na pesquisa das notas de poder de 3os   ³
//³ Se retorno for zero, nao utiliza o filtro de data retroativa nas querys da rotina       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local nDiasRetr	:= Abs(SuperGetMv("MV_DATAPD3",.F.,0))
Local dPrimData	:= dDataBase - nDiasRetr
Local dSegData	:= dDataBase
Local lDataRetr	:= nDiasRetr <> 0
Local aFieldSDH	:= {{"DH_SERIE" ,STR0149 ,"00"} ; //"Ser.Doc.Vinc"
					,{"DH_DOC" ,STR0150 ,"01"} ; //"Doc.Vinc."
					,{"DH_FORNECE" ,STR0151 ,"02"} ; // "For.Doc.Vinc"
					,{"DH_LOJAFOR" ,STR0152 ,"03"} ; // "Loja Doc.Vin." 
					}
Local cOrdem	:= ""

DEFAULT cNumPV := ""

If lDataRetr
	RetDataPD3(@dPrimData,@dSegData,@lDataRetr)
EndIf

//³ Montagem do arquivo temporario dos itens da SDH
SX3->( DbSetOrder(2) )
For nX := 1 to len(aFieldSDH)
	If SX3->(MsSeek(aFieldSDH[nX,01]))
		Aadd(aHeadTrb,{ aFieldSDH[nX,02] ;
						,SX3->X3_CAMPO ;
						,SX3->X3_PICTURE ;
						,SX3->X3_TAMANHO ;
						,SX3->X3_DECIMAL ;
						,SX3->X3_VALID ;
						,SX3->X3_USADO ;
						,SX3->X3_TIPO ;
						,SX3->X3_ARQUIVO ;
						,SX3->X3_CONTEXT ;
						,aFieldSDH[nX,03]})
		aadd(aStruTRB ,{SX3->X3_CAMPO ,SX3->X3_TIPO ,SX3->X3_TAMANHO ,SX3->X3_DECIMAL ,aFieldSDH[nX,03]})
	EndIf
Next nX

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Montagem do arquivo temporario dos itens do SB6                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SX3->( DbSetOrder(1) )
SX3->(MsSeek("SB6"))
While SX3->(!Eof()) .And. SX3->X3_ARQUIVO == "SB6"

	If ( X3USO(SX3->X3_USADO) .And. cNivel >= SX3->X3_NIVEL .And.;
	(lOpTriang .Or. Trim(SX3->X3_CAMPO) <> "B6_CLIFOR") .And.;
	(lOpTriang .Or. Trim(SX3->X3_CAMPO) <> "B6_LOJA") .And.;
	Trim(SX3->X3_CAMPO) <> "B6_PRODUTO" .And.;
	Trim(SX3->X3_CAMPO) <> "B6_QUANT" .And.;
	SX3->X3_CONTEXT<>"V" .And.;
	SX3->X3_TIPO<>"M" ) .Or.;
	Trim(SX3->X3_CAMPO) == "B6_DOC" .Or.;
	Trim(SX3->X3_CAMPO) == "B6_SERIE"  .Or.;
	Trim(SX3->X3_CAMPO) == "B6_EMISSAO" .Or.;
	Trim(SX3->X3_CAMPO) == "B6_TIPO"
	
		If AllTrim(SX3->X3_CAMPO)$"B6_IDENT"
			cOrdem := "04"
		ElseIf AllTrim(SX3->X3_CAMPO)$"B6_DOC" 
			cOrdem := "05"
		ElseIf AllTrim(SX3->X3_CAMPO)$"B6_SERIE"
			cOrdem := "06"
		Else
			cOrdem := "A"+SX3->X3_ORDEM
		EndIf
	
		Aadd(aHeadTrb,{ TRIM(SX3->(X3Titulo()));
						,SX3->X3_CAMPO ;
						,SX3->X3_PICTURE ;
						,SX3->X3_TAMANHO ;
						,SX3->X3_DECIMAL ;
						,SX3->X3_VALID ;
						,SX3->X3_USADO ;
						,SX3->X3_TIPO ;
						,SX3->X3_ARQUIVO ;
						,SX3->X3_CONTEXT ;
						,cOrdem })
		aadd(aStruTRB,{SX3->X3_CAMPO,SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cOrdem})
		If Trim(SX3->X3_CAMPO) == "B6_PRUNIT"
			Aadd(aHeadTrb,{ OemToAnsi("Valor Liquido"),;
							"B6_PRCVEN",;
							SX3->X3_PICTURE,;
							SX3->X3_TAMANHO,;
							SX3->X3_DECIMAL,;
							SX3->X3_VALID,;
							SX3->X3_USADO,;
							SX3->X3_TIPO,;
							SX3->X3_ARQUIVO,;
							SX3->X3_CONTEXT,;
							"A"+SX3->X3_ORDEM})
			aadd(aStruTRB,{"B6_PRCVEN",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL,"A"+SX3->X3_ORDEM})
		EndIf

	EndIf
	SX3->(dbSkip())
EndDo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³MTF4PD3I Ponto de entrada para adicionar indices de pesquisa na comboBox³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lMTF4PD3I
	aRetPE:= ExecBlock("MTF4PD3I",.F.,.F.)
	If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
		For nPE:= 1 to Len(aRetPE)
			If Ascan(aStruTRB,{|x| Trim(x[1]) == Trim(aRetPE[nPE])}) = 0
				MsgAlert(aRetPE[nPE]+STR0103)
			Else
				aadd(aChave,(aRetPE[nPE]))
				aadd(aOrdem,AllTrim(RetTitle(aRetPE[nPE])))
				aadd(aPesq,{Space(TamSX3(aRetPE[nPE])[1]),""})
			Endif
		Next
	EndIf
EndIf

aadd(aStruTRB,{"B6_TOTALL","N",18,If(cES == "S",nDecD2Tot,nDecD1Tot),"99"})
aadd(aStruTRB,{"B6_TOTALB","N",18,If(cES == "S",nDecD2Tot,nDecD1Tot),"99"})
aadd(aStruTRB,{"D2_NUMLOTE","C",nTamSLote,0,""})
aadd(aStruTRB,{"D2_LOTECTL","C",nTamLote,0,""})
aadd(aStruTRB,{"D1_NUMLOTE","C",nTamSLote,0,""})
aadd(aStruTRB,{"D1_LOTECTL","C",nTamLote,0,""})
aadd(aStruTrb,{"SD2RECNO" ,"N",18,0,"99"})
aadd(aStruTrb,{"SD1RECNO" ,"N",18,0,"99"})

aHeadTrb   := aSort(aHeadTrb,,,{|x,y| x[9]+x[11] < y[9]+y[11]})
aStruTrb   := aSort(aStruTrb,,,{|x,y| x[05] < y[05]})
aStruTrbO  := aclone(aStruTrb)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PE: MTPODER3CP - Adciona Campos ao Array de Trabalho   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MTPDR3CP")
	aNewCP := ExecBlock("MTPDR3CP", .F., .F., {cES,aStruTRB} )
	If ValType(aNewCP) == "A" .And. Len(aNewCP) > 0
		aStruTrb := aNewCP
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ajuste das casas decimais conforme a rotina                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cES == "S"
	SX3->(dbSetOrder(2))
	SX3->(MsSeek("D1_VUNIT"))
	nX := aScan(aHeadTrb,{|x| AllTrim(x[2]) == "B6_PRUNIT"})
	If nX > 0
		aHeadTrb[nX][3] := SX3->X3_PICTURE
		aHeadTrb[nX][4] := SX3->X3_TAMANHO
		aHeadTrb[nX][5] := SX3->X3_DECIMAL
	EndIf
	nX := aScan(aHeadTrb,{|x| AllTrim(x[2]) == "B6_PRCVEN"})
	If nX > 0
		aHeadTrb[nX][3] := SX3->X3_PICTURE
		aHeadTrb[nX][4] := SX3->X3_TAMANHO
		aHeadTrb[nX][5] := SX3->X3_DECIMAL
	EndIf
	If Rastro(cProduto)
		If SX3->(MsSeek("D1_LOTECTL"))
			Aadd(aHeadTrb,{ TRIM(SX3->(X3Titulo())),;
							"D1_LOTECTL",;
							SX3->X3_PICTURE,;
							SX3->X3_TAMANHO,;
							SX3->X3_DECIMAL,;
							SX3->X3_VALID,;
							SX3->X3_USADO,;
							SX3->X3_TIPO,;
							SX3->X3_ARQUIVO,;
							SX3->X3_CONTEXT,;
							"98" })
		EndIf
		If SX3->(MsSeek("D1_NUMLOTE"))
			Aadd(aHeadTrb,{ TRIM(SX3->(X3Titulo())),;
							"D1_NUMLOTE",;
							SX3->X3_PICTURE,;
							SX3->X3_TAMANHO,;
							SX3->X3_DECIMAL,;
							SX3->X3_VALID,;
							SX3->X3_USADO,;
							SX3->X3_TIPO,;
							SX3->X3_ARQUIVO,;
							SX3->X3_CONTEXT,;
							"99" })
		EndIf
	EndIf
Else
	SX3->(dbSetOrder(2))
	SX3->(MsSeek("D2_PRCVEN"))
	nX := aScan(aHeadTrb,{|x| AllTrim(x[2]) == "B6_PRUNIT"})
	If nX > 0
		aHeadTrb[nX][3] := SX3->X3_PICTURE
		aHeadTrb[nX][4] := SX3->X3_TAMANHO
		aHeadTrb[nX][5] := SX3->X3_DECIMAL
	EndIf
	nX := aScan(aHeadTrb,{|x| AllTrim(x[2]) == "B6_PRCVEN"})
	If nX > 0
		aHeadTrb[nX][3] := SX3->X3_PICTURE
		aHeadTrb[nX][4] := SX3->X3_TAMANHO
		aHeadTrb[nX][5] := SX3->X3_DECIMAL
	EndIf
	If Rastro(cProduto)
		If SX3->(MsSeek("D2_LOTECTL"))
			Aadd(aHeadTrb,{ TRIM(SX3->(X3Titulo())),;
							"D2_LOTECTL",;
							SX3->X3_PICTURE,;
							SX3->X3_TAMANHO,;
							SX3->X3_DECIMAL,;
							SX3->X3_VALID,;
							SX3->X3_USADO,;
							SX3->X3_TIPO,;
							SX3->X3_ARQUIVO,;
							SX3->X3_CONTEXT,;
							"98" })
		EndIf
		If SX3->(MsSeek("D2_NUMLOTE"))
			Aadd(aHeadTrb,{ TRIM(SX3->(X3Titulo())),;
							"D2_NUMLOTE",;
							SX3->X3_PICTURE,;
							SX3->X3_TAMANHO,;
							SX3->X3_DECIMAL,;
							SX3->X3_VALID,;
							SX3->X3_USADO,;
							SX3->X3_TIPO,;
							SX3->X3_ARQUIVO,;
							SX3->X3_CONTEXT,;
							"99" })
		EndIf
	EndIf
EndIf
IF (TamSx3("B6_PRUNIT")[2])>2 .And. (TamSx3("D1_VUNIT")[2])>2  .And. ;
(TamSx3("B6_PRUNIT")[2]) = (TamSx3("D1_VUNIT")[2])
	nDecSB6 := VAL(PADR("0.",(TamSx3("B6_PRUNIT")[2]+1),"0")+"1")
Else
	nDecSB6 := 0.01
EndIf

For nX := 1 To Len(aChave)
	aAdd(aChaveSep, StrTokArr( aChave[nX], "+" ))
Next nX

oTempTable := FWTemporaryTable():New( cAliasTRB )
oTempTable:SetFields( aStruTRB )
cNomeTrb := oTempTable:GetRealName()

For nX := 1 To Len(aChave)
	aAdd( aNomInd , StrTran( (SubStr( cNomeTrb, 1 , 7 ) + Chr( 64 + nX ) ), "_" , "") )
	oTempTable:AddIndex(Str(nX), aChaveSep[nX] )
Next nX

oTempTable:Create()
dbSelectArea(cAliasTRB)

If ExistBlock("MTPODER3")
	aNew := ExecBlock("MTPODER3", .F., .F., {cES,aHeadTrb} )
	If ValType(aNew) == "A" .And. Len(aNew) > 0
		aHeadTrb := aNew
	Endif
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verificacao do aHeader atual                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cES == "S"
	nPQuant   := aScan(aHeader,{|x| AllTrim(x[2])=="C6_QTDVEN"})
	nPValor   := aScan(aHeader,{|x| AllTrim(x[2])=="C6_VALOR"})
	nPIdentB6 := aScan(aHeader,{|x| AllTrim(x[2])=="C6_IDENTB6"})
	nPItem    := GDFieldPos( "C6_ITEM" )
	nPUnit    := GDFieldPos( "C6_PRCVEN" )
	nPTES     := GDFieldPos( "C6_TES" )
Else
	nPQuant   := aScan(aHeader,{|x| AllTrim(x[2])=="D1_QUANT"})
	nPValor   := aScan(aHeader,{|x| AllTrim(x[2])=="D1_TOTAL"})
	nPIdentB6 := aScan(aHeader,{|x| AllTrim(x[2])=="D1_IDENTB6"})
	nPTES     := GDFieldPos( "D1_TES" )
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualizacao do arquivo temporario com base nos itens do SD1         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SB6->(dbSetOrder(2))

lQuery    := .T.
cAliasSB6 := "F4PODER3_SQL"
cAliasSD1 := "F4PODER3_SQL"
cAliasSD2 := "F4PODER3_SQL"

If cES == "E"
	cQuery := "SELECT DISTINCT(0) SD1RECNO,SB6.R_E_C_N_O_ SB6RECNO,0 D1_VUNIT,0 D1_TOTAL,0 D1_VALDESC,SD2.R_E_C_N_O_ SD2RECNO,D2_PRCVEN,D2_TOTAL,D2_DESCON, D2_NUMLOTE NUMLOTE,D2_LOTECTL LOTECTL,D2_TIPO,'' D1_TIPO, "
Else
	cQuery := "SELECT DISTINCT(SD1.R_E_C_N_O_) SD1RECNO,SB6.R_E_C_N_O_ SB6RECNO,D1_VUNIT,D1_TOTAL,D1_VALDESC,0 SD2RECNO,0 D2_PRCVEN,0 D2_TOTAL,0 D2_DESCON,D1_NUMLOTE NUMLOTE,D1_LOTECTL LOTECTL,'' D2_TIPO,D1_TIPO, "
EndIf

cQuery += "B6_FILIAL,B6_PRODUTO,B6_CLIFOR,B6_LOJA,B6_PODER3,B6_IDENTB6,B6_TPCF,B6_QUANT,B6_QULIB "

If cES=="S"
	cQuery += ",'' DH_SERIE ,'' DH_DOC ,'' DH_FORNECE ,'' DH_LOJAFOR "
Else
	cQuery += ",DH_SERIE ,DH_DOC, DH_FORNECE ,DH_LOJAFOR "
EndIf

For nX := 1 To Len(aHeadTRB)
	If aHeadTRB[nX][2]<>"B6_PRCVEN"    .AND.;
	aHeadTRB[nX][2]<>"D2_NUMLOTE"  .AND.;
	aHeadTRB[nX][2]<>"D2_LOTECTL"  .And.;
	aHeadTRB[nX][2]<>"D2_TIPO"     .And.;
	aHeadTRB[nX][2]<>"D1_NUMLOTE"  .AND.;
	aHeadTRB[nX][2]<>"D1_LOTECTL"  .And.;
	aHeadTRB[nX][2]<>"D1_TIPO"     .And.;
	aHeadTRB[nX][2]<>"B6_CLIFOR"   .And.;
	aHeadTRB[nX][2]<>"B6_LOJA"     .And.;
	aHeadTRB[nX][2]<>"B6_PODER3"   .And.;
	aHeadTRB[nX][2]<>"B6_QULIB" ;
	.AND. !(AllTrim(aHeadTRB[nX][2])$"DH_SERIE$DH_DOC$DH_FORNECE$DH_LOJAFOR")
	
		cQuery += ","+aHeadTRB[nX][2]+" "
	EndIf
Next nX
cQuery1:= " FROM "+RetSqlName("SB6")+" SB6 "
If cES=="S"
	cQuery1 += "INNER JOIN " + RetSqlName("SD1")+" SD1 ON SD1.D1_FILIAL = '"+aFiliais[1]+"' "
	cQuery1 += " AND SD1.D1_NUMSEQ = SB6.B6_IDENT "
	If lVldData
		If lDataRetr
			cQuery1 += " AND SD1.D1_DTDIGIT >= '" + DTOS(dPrimData) + "' "
		EndIf
		cQuery1 += " AND SD1.D1_DTDIGIT <= '" + DTOS(dSegData) + "' "
	EndIf
	cQuery1 += "AND SD1.D_E_L_E_T_= ' ' "
	 
Else
	cQuery1 += " INNER JOIN " + RetSqlName("SD2")+" SD2 ON SD2.D2_FILIAL = '"+aFiliais[2]+"' "
	cQuery1 += " AND SD2.D2_NUMSEQ = SB6.B6_IDENT "
	If lVldData
		If lDataRetr
			cQuery1 += " AND SD2.D2_EMISSAO >= '" + DTOS(dPrimData) + "' "
		EndIf
		cQuery1 += " AND SD2.D2_EMISSAO <= '" + DTOS(dSegData) + "' "
	EndIf
	cQuery1 += " AND SD2.D_E_L_E_T_=' ' "
	
	cQuery1 += " LEFT JOIN " + RetSqlName("SDH")+" SDH ON SDH.DH_FILIAL = '"+xFilial("SDH")+"' "
	cQuery1 += " AND SDH.DH_OPER = '2' "  
	cQuery1 += " AND SDH.DH_TPMOV = '2' " 
	cQuery1 += " AND SDH.DH_IDENTNF  = SD2.D2_NUMSEQ "  
	cQuery1 += " AND SDH.D_E_L_E_T_=' ' "
	 
EndIf
cQuery1 += "WHERE SB6.B6_FILIAL = '"+aFiliais[3]+"' "
cQuery1 += " AND SB6.B6_PRODUTO = '"+cProduto+"' "
If !lOpTriang
	cQuery1 += " AND SB6.B6_CLIFOR = '"+cCliFor+"' "
	cQuery1 += " AND SB6.B6_LOJA = '"+cLoja+"' "
EndIf
cQuery1 += " AND SB6.B6_PODER3 = 'R' "
cQuery1 += " AND SB6.B6_TPCF = '"+cTpCliFor+"' "
cQuery1 += " AND SB6.B6_ATEND <> 'S' "
cQuery1 += " AND SB6.B6_SALDO > 0 "
cQuery1 += " AND SB6.B6_TIPO = " + IIf(cES=="S" ,"'D' " ,"'E' ")

cQuery1 += " AND SB6.D_E_L_E_T_ = ' ' "

cQuery += cQuery1 + " UNION ALL "
If cES == "E"
	cQuery += "SELECT DISTINCT(SD1.R_E_C_N_O_) SD1RECNO,SB6.R_E_C_N_O_ SB6RECNO,D1_VUNIT,D1_TOTAL,D1_VALDESC,0 SD2RECNO,0 D2_PRCVEN,0 D2_TOTAL,0 D2_DESCON, D1_NUMLOTE NUMLOTE,D1_LOTECTL LOTECTL,'' D2_TIPO, D1_TIPO, "
Else
	cQuery += "SELECT DISTINCT(0) SD1RECNO,SB6.R_E_C_N_O_ SB6RECNO,0 D1_VUNIT,0 D1_TOTAL,0 D1_VALDESC,SD2.R_E_C_N_O_ SD2RECNO,D2_PRCVEN,D2_TOTAL,D2_DESCON,D2_NUMLOTE NUMLOTE,D2_LOTECTL LOTECTL, D2_TIPO,'' D1_TIPO, "
EndIf

cQuery += "B6_FILIAL,B6_PRODUTO,B6_CLIFOR,B6_LOJA,B6_PODER3,B6_IDENTB6,B6_TPCF,B6_QUANT,B6_QULIB "

If cES=="S"
	cQuery += ",DH_SERIE ,DH_DOC, DH_FORNECE ,DH_LOJAFOR "
Else
	cQuery += ",'' DH_SERIE ,'' DH_DOC ,'' DH_FORNECE ,'' DH_LOJAFOR "
EndIf

For nX := 1 To Len(aHeadTRB)
	If aHeadTRB[nX][2]<>"B6_PRCVEN"    .AND.;
	aHeadTRB[nX][2]<>"D2_NUMLOTE"  .AND.;
	aHeadTRB[nX][2]<>"D2_LOTECTL"  .And.;
	aHeadTRB[nX][2]<>"D2_TIPO"     .And.;
	aHeadTRB[nX][2]<>"D1_NUMLOTE"  .AND.;
	aHeadTRB[nX][2]<>"D1_LOTECTL"  .And.;
	aHeadTRB[nX][2]<>"D1_TIPO"     .And.;
	aHeadTRB[nX][2]<>"B6_CLIFOR"   .And.;
	aHeadTRB[nX][2]<>"B6_LOJA"     .And.;
	aHeadTRB[nX][2]<>"B6_PODER3"   .And.;
	aHeadTRB[nX][2]<>"B6_QULIB" ;
	.AND. !(AllTrim(aHeadTRB[nX][2])$"DH_SERIE$DH_DOC$DH_FORNECE$DH_LOJAFOR")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Adiciona campos na Query que foram implementados atraves do PE: MTPODER3CP ³
		//| Caso o campo nao existir no Array Original, o mesmo será adicionado e sera |
		//| atribuido o conteudo padrao ao mesmo de acordo com o seu tipo.             |
		//| Esta situacao se faz necessaria, pois ao efetuar o Select Union, a tabela  |
		//| relacionada nao se encontrara na clausa From devido a inversão de tabelas  |
		//| em relação ao Select antes do Union.										   |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aNewCP)>0
			nPos:=aScan(aStruTrbO,{|x| Trim(x[1])==Trim(aHeadTRB[nX][2])})
			If nPos>0
				cQuery += ","+aHeadTRB[nX][2]+" "
			Else
				nPos:=aScan(aStruTrb,{|x| Trim(x[1])==Trim(aHeadTRB[nX][2])})
				cQuery += ","+IIF(aStruTrb[nPos][2]$"CDM","''",0)+" "+aHeadTRB[nX][2]+" "
			EndIf
		Else
			cQuery += ","+aHeadTRB[nX][2]+" "
		EndIf
	EndIf
Next nX
cQuery2:= " FROM "+RetSqlName("SB6")+" SB6 "
If cES=="S"
	cQuery2 += " INNER JOIN " + RetSqlName("SD2")+" SD2 ON SD2.D2_FILIAL = '"+aFiliais[2]+"' "
	cQuery2 += " AND SD2.D2_DOC = SB6.B6_DOC "
	cQuery2 += " AND SD2.D2_SERIE = SB6.B6_SERIE "
	cQuery2 += " AND SD2.D2_CLIENTE = SB6.B6_CLIFOR "
	cQuery2 += " AND SD2.D2_LOJA = SB6.B6_LOJA "
	cQuery2 += " AND SD2.D2_COD = SB6.B6_PRODUTO "
	cQuery2 += " AND SD2.D2_IDENTB6 = SB6.B6_IDENT "
	cQuery2 += " AND SD2.D2_QUANT = SB6.B6_QUANT "
	If lVldData
		If lDataRetr
			cQuery2 += " AND SD2.D2_EMISSAO >= '" + DTOS(dPrimData) + "' "
		EndIf
		cQuery2 += " AND SD2.D2_EMISSAO <= '" + DTOS(dSegData) + "' "
	EndIf
	cQuery2 += " AND SD2.D_E_L_E_T_=' ' "

	cQuery2 += " LEFT JOIN " + RetSqlName("SDH")+" SDH ON SDH.DH_FILIAL = '"+xFilial("SDH")+"' "
	cQuery2 += " AND SDH.DH_OPER = '2' "  
	cQuery2 += " AND SDH.DH_TPMOV = '2' " 
	cQuery2 += " AND SDH.DH_IDENTNF  = SD2.D2_NUMSEQ "  
	cQuery2 += " AND SDH.D_E_L_E_T_=' ' "
	 
Else
	cQuery2 += " INNER JOIN " + RetSqlName("SD1")+" SD1 ON SD1.D1_FILIAL = '"+aFiliais[1]+"' "
	cQuery2 += " AND SD1.D1_DOC = SB6.B6_DOC "
	cQuery2 += " AND SD1.D1_SERIE = SB6.B6_SERIE "
	cQuery2 += " AND SD1.D1_FORNECE = SB6.B6_CLIFOR "
	cQuery2 += " AND SD1.D1_LOJA = SB6.B6_LOJA "
	cQuery2 += " AND SD1.D1_COD = SB6.B6_PRODUTO "
	cQuery2 += " AND SD1.D1_IDENTB6 = SB6.B6_IDENT "
	cQuery2 += " AND SD1.D1_QUANT = SB6.B6_QUANT "
	If lVldData
		If lDataRetr
			cQuery2 += " AND SD1.D1_DTDIGIT >= '" + DTOS(dPrimData) + "' "
		EndIf
		cQuery2 += " AND SD1.D1_DTDIGIT <= '" + DTOS(dSegData) + "' "
	EndIf
	cQuery2 += " AND SD1.D_E_L_E_T_ = ' ' "
EndIf
cQuery2 += "WHERE SB6.B6_FILIAL = '"+aFiliais[3]+"' "
cQuery2 += " AND SB6.B6_PRODUTO = '"+cProduto+"' "
If !lOpTriang
	cQuery2 += " AND SB6.B6_CLIFOR = '"+cCliFor+"' "
	cQuery2 += " AND SB6.B6_LOJA = '"+cLoja+"' "
EndIf 
cQuery2 += " AND SB6.B6_PODER3 = 'D' "
cQuery2 += " AND SB6.B6_TPCF = '"+cTpCliFor+"' "
cQuery2 += " AND SB6.B6_ATEND <> 'S' " 
cQuery2 += " AND SB6.B6_SALDO > 0 "
cQuery2 += " AND SB6.B6_TIPO = " + IIf(cES=="S" ,"'D' " ,"'E' ")

cQuery2 += " AND SB6.D_E_L_E_T_ = ' ' "

cQuery := cQuery + cQuery2
cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.T.,.F.)

For nX := 1 To Len(aStruTRB)
	If aStruTRB[nX][2] <> "C"
		TcSetField(cAliasSB6,aStruTRB[nX][1],aStruTRB[nX][2],aStruTRB[nX][3],aStruTRB[nX][4])
	EndIf
Next nX

TcSetField(cAliasSD1,"D1_TOTAL","N",TamSx3("D1_TOTAL")[1], TamSx3("D1_TOTAL")[2] )
TcSetField(cAliasSD1,"D1_VALDESC","N",TamSx3("D1_VALDESC")[1], TamSx3("D1_TOTAL")[2] )
TcSetField(cAliasSD1,"D2_TOTAL","N",TamSx3("D2_TOTAL")[1], TamSx3("D2_TOTAL")[2] )
TcSetField(cAliasSD1,"D2_DESCON","N",TamSx3("D2_DESCON")[1], TamSx3("D2_DESCON")[2] )
TcSetField(cAliasSD1,"SD1RECNO","N",12, 0 )
TcSetField(cAliasSD1,"SD2RECNO","N",12, 0 )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Esta rotina, verifica se existem Produtos com Códigos e Quantidades iguais na Nota      |
//| para definir se irá gerar uma nova tabela através da montagem de um Array para          |
//| obter os precos reais de movimentação na SD1                                            |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lQuery
	If cES=="E"
		cQuery3:="SELECT DISTINCT(SD1.R_E_C_N_O_),COUNT(*) REGISTROS "+cQuery2+" GROUP BY SD1.R_E_C_N_O_ HAVING COUNT(*)>1"
		cQuery3 := ChangeQuery(cQuery3)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery3),"REGISTROS",.T.,.F.)
		dbSelectArea("REGISTROS")
		If !EOF()
			lCria:=.T.
		EndIf
		dbCloseArea()
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Esta rotina, ira gerar um Array com a mesma Estrutura da Query e buscar os registros    |
//| com os valores de movimentações reais. Isto é necessário, pois em situações onde existe |
//| o mesmo código do produto com quantidades iguais, porém com valores diferentes, a função|
//| apontava o 1a registro encontrado gerando divergências de valores entre as funcoes      |
//| F4PODER3 x CALCTERC 																	|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lQuery .And. lCria
	(cAliasSB6)->(dbGotop())

	nCampos := (cAliasSB6)->(FCount())

	SD1->(dbSetOrder(1))

	While (cAliasSB6)->(!Eof())
		If (cAliasSB6)->B6_PODER3 == "D"
			If cSeekSD1 != aFiliais[1]+(cAliasSB6)->B6_DOC+(cAliasSB6)->B6_SERIE+(cAliasSB6)->B6_CLIFOR+(cAliasSB6)->B6_LOJA+(cAliasSB6)->B6_PRODUTO
				SD1->(MsSeek(cSeekSD1 := aFiliais[1]+(cAliasSB6)->B6_DOC+(cAliasSB6)->B6_SERIE+(cAliasSB6)->B6_CLIFOR+(cAliasSB6)->B6_LOJA+(cAliasSB6)->B6_PRODUTO))
			EndIf
			While SD1->(!Eof()) .And. ;
			(cAliasSB6)->B6_FILIAL    == SD1->D1_FILIAL  .And.;
			(cAliasSB6)->B6_DOC       == SD1->D1_DOC     .And.;
			(cAliasSB6)->B6_SERIE     == SD1->D1_SERIE   .And.;
			(cAliasSB6)->B6_CLIFOR    == SD1->D1_FORNECE .And.;
			(cAliasSB6)->B6_LOJA      == SD1->D1_LOJA    .And.;
			(cAliasSB6)->B6_PRODUTO   == SD1->D1_COD

				cNF:= SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEM
				If (cAliasSB6)->B6_IDENT==SD1->D1_IDENTB6
					If Ascan(aNF,cNF) = 0 .And. Ascan(aValNFD,{|x| x[1] = (cAliasSB6)->SD1RECNO}) = 0 .And. Ascan(aValNFD,{|x| x[2] = (cAliasSB6)->SB6RECNO}) = 0
						aadd(aNF,cNF)
						aadd(aValNFD,Array(nCampos))
						For nZ:=1 To nCampos
							cCampoTRB := (cAliasSB6)->(FieldName(nZ))
							If cCampoTRB $ "SD2RECNO$D2_PRCVEN$D2_TOTAL$D2_DESCON"
								aValNFD[Len(aValNFD),nZ]:=0
							Else
								aValNFD[Len(aValNFD),nZ] := (cAliasSB6)->(&(cCampoTRB))
							EndIf
						Next nZ
						dbSelectArea("SD1")
						Exit
					EndIf
				EndIf
				SD1->(dbSkip())
			EndDo
		Else
			aadd(aValNFR,Array(nCampos))
			For nZ:=1 To nCampos
				cCampoTRB := (cAliasSB6)->(FieldName(nZ))
				If cCampoTRB $"D1_VUNIT$D1_TOTAL$D1_VALDESC"
					aValNFR[Len(aValNFR),nZ]:=0
				Else
					aValNFR[Len(aValNFR),nZ] := (cAliasSB6)->(&(cCampoTRB))
				EndIf
			Next nZ
		EndIf
		(cAliasSB6)->(dbSkip())
	EndDo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Cria arquivo de trabalho com os dados obtidos através do array que foi gerado  |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aStruSB6 := (cAliasSB6)->(dbStruct())
	SX3->(DbSetOrder(2))

	For nX := 1 To Len(aStruSB6)
		cCampo:=aStruSB6[nX][1]
		nY:=aScan(aStruTrb,{|x| AllTrim(x[1])==cCampo})
		If nY>0
			aStruSB6[nX][3]:=aStruTrb[nY][3]
			aStruSB6[nX][4]:=aStruTrb[nY][4]
		Else
			If Rat("RECNO",cCampo)>0
				aStruSB6[nX][3]:=18
				aStruSB6[nX][4]:=0
			Else
				SX3->(MsSeek(cCampo))
				If SX3->(!Eof())
					aStruSB6[nX][3]:=SX3->(X3_TAMANHO)
					aStruSB6[nX][4]:=SX3->(X3_DECIMAL)
				EndIf
			EndIf
		EndIf
	Next nX

	(cAliasSB6)->(dbCloseArea())

	cNomeTrb := ""
	cNomeTrb := FWOpenTemp(cAliasSB6,aStruSB6,,.T.)

	dbSelectArea(cAliasSB6)
	For nX := 1 to 2
		aValNF:={}
		aValNF:=iif(nX==1, aValNFR, aValNFD)
		For nY :=1 To Len(aValNF)
			RecLock(cAliasSB6,.T.)
			For nZ := 1 TO nCampos
				FieldPut(nZ, aValNF[nY,nZ])
			Next nZ
			MsUnlock()
		Next nY
	Next nX
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Inicia Processo de Calculo  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lQuery
	(cAliasSB6)->(dbGotop())
EndIf

(cAliasTRB)->(dbSetOrder(3))

While (cAliasSB6)->(!Eof()) .And. (cAliasSB6)->B6_FILIAL = aFiliais[3] .And.;
(cAliasSB6)->B6_PRODUTO == cProduto .And.;
IIF(lOpTriang,.T.,IIf(lQuery,.T.,(cAliasSB6)->B6_CLIFOR == cCliFor .And.;
(cAliasSB6)->B6_LOJA == cLoja ))

	lProcessa := .T.
	If lMtProcP3
		lProcessa := ExecBlock("MTPROCP3",.F.,.F.,{cAliasSB6,lQuery})
	Endif

	If lProcessa

		If !lQuery
			lProcessa := aScan(aRegSB6,SB6->(RecNo()))==0
		Else
			lProcessa := aScan(aRegSB6,(cAliasSB6)->SB6RECNO)==0
		EndIf

	EndIf

	//Se não possuir saldo não processa
	If (cAliasSB6)->B6_SALDO <= 0
		lProcessa := .F.
	EndIf

	If lProcessa

		If ((cES == "E" .And. (cAliasSB6)->B6_TIPO == "E") .Or. (cES == "S" .And. (cAliasSB6)->B6_TIPO == "D") ) .And.;
		(cAliasSB6)->B6_TPCF==cTpCliFor
			If !lQuery
				aadd(aRegSB6,SB6->(RecNo()))
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verificar qual eh a tabela de origem do poder de terceiros          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ((cAliasSB6)->B6_TIPO=="D" .And. (cAliasSB6)->B6_PODER3 == "R" ) .Or. ((cAliasSB6)->B6_TIPO=="E" .And. (cAliasSB6)->B6_PODER3 == "D")
					If (cAliasSB6)->B6_PODER3 == "R"
						SD1->(dbSetOrder(4))
						SD1->(MsSeek(aFiliais[1]+(cAliasSB6)->B6_IDENT))
					Else
						SD1->(dbSetOrder(1))
						SD1->(MsSeek(aFiliais[1]+(cAliasSB6)->B6_DOC+(cAliasSB6)->B6_SERIE+(cAliasSB6)->B6_CLIFOR+(cAliasSB6)->B6_LOJA+(cAliasSB6)->B6_PRODUTO))
						While SD1->(!Eof()) .And. aFiliais[1] == SD1->D1_FILIAL .And.;
						(cAliasSB6)->B6_DOC       == SD1->D1_DOC .And.;
						(cAliasSB6)->B6_SERIE     == SD1->D1_SERIE .And.;
						(cAliasSB6)->B6_CLIFOR    == SD1->D1_FORNECE .And.;
						(cAliasSB6)->B6_LOJA      == SD1->D1_LOJA .And.;
						(cAliasSB6)->B6_PRODUTO   == SD1->D1_COD

							If (cAliasSB6)->B6_IDENT==SD1->D1_IDENTB6 .And. (cAliasSB6)->B6_QUANT=SD1->D1_QUANT
								Exit
							EndIf

							SD1->(dbSkip())
						EndDo
					EndIf
				Else
					If (cAliasSB6)->B6_PODER3=="R"
						SD2->(dbSetOrder(4))
						SD2->(MsSeek(aFiliais[2]+(cAliasSB6)->B6_IDENT))
					Else
						SD2->(dbSetOrder(3))
						SD2->(MsSeek(aFiliais[2]+(cAliasSB6)->B6_DOC+(cAliasSB6)->B6_SERIE+(cAliasSB6)->B6_CLIFOR+(cAliasSB6)->B6_LOJA+(cAliasSB6)->B6_PRODUTO))
						While SD2->(!Eof()) .And. aFiliais[2] == SD2->D2_FILIAL .And.;
						(cAliasSB6)->B6_DOC == SD2->D2_DOC .And.;
						(cAliasSB6)->B6_SERIE == SD2->D2_SERIE .And.;
						(cAliasSB6)->B6_CLIFOR == SD2->D2_CLIENTE .And.;
						(cAliasSB6)->B6_LOJA == SD2->D2_LOJA .And.;
						(cAliasSB6)->B6_PRODUTO == SD2->D2_COD
							If (cAliasSB6)->B6_IDENT==SD2->D2_IDENTB6 .And. (cAliasSB6)->B6_QUANT=SD2->D2_QUANT
								Exit
							EndIf
							SD2->(dbSkip())
						EndDo
					EndIf
				EndIf
			Else
				aadd(aRegSB6,(cAliasSB6)->SB6RECNO)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calculo do saldo em valor e quantidade para devolucao de terceiros  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nSldQtd := 0
			nSldBru := 0
			nSldLiq := 0
			If ((cAliasSB6)->B6_TIPO=="D" .And. (cAliasSB6)->B6_PODER3 == "R" ) .Or. ((cAliasSB6)->B6_TIPO=="E" .And. (cAliasSB6)->B6_PODER3 == "D")
				lProcessa := lProcessa .And. (cAliasSD1)->D1_TIPO<>"I"
			Else
				lProcessa := lProcessa .And. (cAliasSD2)->D2_TIPO<>"I"
			EndIf
			If lProcessa
				If (cAliasSB6)->B6_PODER3 == "R" .And. Empty((cAliasSB6)->B6_IDENTB6)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Na primeira remessa deve-se tirar os valores contidos na interface  ³
					//³ para evitar baixa de saldo maior que o disponivel                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If cES == "E"
						For nX := 1 To Len(aCols)
							If nX <> N .And. !aCols[nX][Len(aHeader)+1] .And. aCols[nX][nPIdentB6]==(cAliasSB6)->B6_IDENT
								nSldQtd -= aCols[nX][nPQuant]
								nSldBru -= aCols[nX][nPValor]
							EndIf
						Next nX
					Else
						For nX := 1 To Len(aCols)
							If nX <> N .And. !aCols[nX][Len(aHeader)+1] .And. aCols[nX][nPIdentB6]==(cAliasSB6)->B6_IDENT
								nSldQtd -= aCols[nX][nPQuant]
								nSldLiq -= (aCols[nX][nPQuant]*aCols[nX][nPUnit])

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Desconsidera a quantidade ja faturada                               ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If !Empty( cNumPV )
									SC6->( dbSetOrder( 1 ) )
									If SC6->( MsSeek( aFiliais[4] + cNumPv + aCols[nX, nPItem ] ) )
										nSldQtd += SC6->C6_QTDENT
										nSldLiq += aCols[nX,nPUnit] * SC6->C6_QTDENT
										nSldLiq := A410Arred( nSldLiq, "C6_VALOR" )
									EndIf
								EndIf

							EndIf
						Next nX
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Calculo do saldo do poder de terceiros                              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nSldQtd  += (cAliasSB6)->B6_SALDO
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Calculo do saldo do poder de terceiros                              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nSldQtd  -= (cAliasSB6)->B6_SALDO
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verificar qual eh a tabela de origem do poder de terceiros e calcula³
				//³ o valor total do saldo de poder de/em terceiros                     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ((cAliasSB6)->B6_TIPO=="D" .And. (cAliasSB6)->B6_PODER3 == "R" ) .Or. ((cAliasSB6)->B6_TIPO=="E" .And. (cAliasSB6)->B6_PODER3 == "D")
					If (cAliasSB6)->B6_PODER3 == "R"
						nSldLiq += ((cAliasSD1)->D1_VUNIT * (cAliasSB6)->B6_SALDO)-(((cAliasSD1)->D1_VALDESC/(cAliasSB6)->B6_QUANT)*(cAliasSB6)->B6_SALDO)
						nSldBru += nSldLiq+A410Arred(nSldLiq*(cAliasSD1)->D1_VALDESC/(((cAliasSD1)->D1_VUNIT * (cAliasSB6)->B6_QUANT)-(cAliasSD1)->D1_VALDESC),"C6_VALOR")
					Else
						nSldLiq -= ((cAliasSD1)->D1_VUNIT * (cAliasSB6)->B6_SALDO)-(((cAliasSD1)->D1_VALDESC/(cAliasSB6)->B6_QUANT)*(cAliasSB6)->B6_SALDO)
						nSldBru -= Abs(nSldLiq)+A410Arred(Abs(nSldLiq)*(cAliasSD1)->D1_VALDESC/(((cAliasSD1)->D1_VUNIT * (cAliasSB6)->B6_QUANT)-(cAliasSD1)->D1_VALDESC),"C6_VALOR")
					EndIf
				Else
					If (cAliasSB6)->B6_PODER3 == "R"
						nSldBru += ((cAliasSD2)->D2_PRCVEN * (cAliasSB6)->B6_SALDO) + (((cAliasSD2)->D2_DESCON/(cAliasSB6)->B6_QUANT)*(cAliasSB6)->B6_SALDO)
						nSldLiq += nSldBru-A410Arred(nSldBru*(cAliasSD2)->D2_DESCON/(((cAliasSD2)->D2_PRCVEN * (cAliasSB6)->B6_QUANT)+(cAliasSD2)->D2_DESCON),"C6_VALOR")
					Else
						nSldBru -= ((cAliasSD2)->D2_PRCVEN * (cAliasSB6)->B6_SALDO) + (((cAliasSD2)->D2_DESCON/(cAliasSB6)->B6_QUANT)*(cAliasSB6)->B6_SALDO)
						nSldLiq -= Abs(nSldBru)-A410Arred(Abs(nSldBru)*(cAliasSD2)->D2_DESCON/(((cAliasSD2)->D2_PRCVEN * (cAliasSB6)->B6_QUANT)+(cAliasSD2)->D2_DESCON),"C6_VALOR")
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o arquivo temporario com os dados do poder de terceiro     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nSldQtd <> 0 .Or. nSldLiq <> 0
					If !Empty((cAliasSB6)->B6_IDENTB6)
						(cAliasTRB)->(MsSeek((cAliasSB6)->B6_IDENTB6))
					Else
						(cAliasTRB)->(MsSeek((cAliasSB6)->B6_IDENT))
					EndIf
					If (cAliasTRB)->(!Found())
						RecLock(cAliasTRB,.T.)
						For nX := 1 To Len(aStruTRB)
							If !AllTrim(aStruTRB[nX][1])$"B6_SALDO#B6_TOTALL#B6_TOTALB#B6_QULIB#B6_PRCVEN#D1_NUMLOTE#D1_LOTECTL#D2_NUMLOTE#D2_LOTECTL"
								(cAliasTRB)->(FieldPut(nX,(cAliasSB6)->(FieldGet(FieldPos(aStruTRB[nX][1])))))
							ElseIf AllTrim(aStruTRB[nX][1])$"D1_NUMLOTE#D1_LOTECTL#D2_NUMLOTE#D2_LOTECTL"
								(cAliasTRB)->(FieldPut(nX,(cAliasSB6)->(FieldGet(FieldPos(SubStr(aStruTRB[nX][1],4,7))))))
							ElseIf AllTrim(aStruTRB[nX][1])$"B6_PRCVEN"
								(cAliasTRB)->(FieldPut(nX,(cAliasSB6)->(FieldGet(FieldPos("D2_PRCVEN")))))
							EndIf
						Next nX
					Else
						RecLock(cAliasTRB)
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Verifica o documento original para obter alguns dados posteriores   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If (cAliasSB6)->B6_PODER3 == "R" .And. Empty((cAliasSB6)->B6_IDENTB6)
						For nX := 1 To Len(aStruTRB)
							If !AllTrim(aStruTRB[nX][1])$"B6_SALDO#B6_TOTALL#B6_TOTALB#B6_QULIB#B6_PRCVEN#D1_NUMLOTE#D1_LOTECTL#D2_NUMLOTE#D2_LOTECTL#B6_CUSTO1"
								(cAliasTRB)->(FieldPut(nX,(cAliasSB6)->(FieldGet(FieldPos(aStruTRB[nX][1])))))
							ElseIf AllTrim(aStruTRB[nX][1])$"D1_NUMLOTE#D1_LOTECTL#D2_NUMLOTE#D2_LOTECTL"
								(cAliasTRB)->(FieldPut(nX,(cAliasSB6)->(FieldGet(FieldPos(SubStr(aStruTRB[nX][1],4,7))))))
							ElseIf AllTrim(aStruTRB[nX][1])$"B6_PRCVEN"
								(cAliasTRB)->(FieldPut(nX,(cAliasSB6)->(FieldGet(FieldPos("D2_PRCVEN")))))
							EndIf
						Next nX
						If (cAliasSB6)->B6_TIPO=="D"
							(cAliasTRB)->SD1RECNO := IIf(lQuery,(cAliasSD1)->SD1RECNO,SD1->(RecNo()))
						Else
							(cAliasTRB)->SD2RECNO := IIf(lQuery,(cAliasSD2)->SD2RECNO,SD2->(RecNo()))
						EndIf
					EndIf
					(cAliasTRB)->B6_SALDO += a410Arred(nSldQtd,"C6_QTDVEN")
					(cAliasTRB)->B6_QULIB += a410Arred((cAliasSB6)->B6_QULIB,"C6_QTDVEN")
					(cAliasTRB)->B6_TOTALL+= nSldLiq
					(cAliasTRB)->B6_TOTALB+= nSldBru
					(cAliasTRB)->B6_CUSTO1:= ((cAliasSB6)->B6_CUSTO1 / (cAliasSB6)->B6_QUANT) * (cAliasSB6)->B6_SALDO

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Calcula o valor unitario do poder de terceiros                      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					(cAliasTRB)->B6_PRCVEN:= a410Arred((cAliasTRB)->B6_TOTALL/((cAliasTRB)->B6_SALDO),"D2_PRCVEN")
					
					(cAliasTRB)->B6_PRUNIT:= a410Arred((cAliasTRB)->B6_TOTALB/((cAliasTRB)->B6_SALDO),"D2_PRCVEN")
		            If cES == "E"
						If (cAliasTRB)->B6_PRUNIT == (cAliasTRB)->B6_PRCVEN .And. Abs((cAliasTRB)->B6_PRCVEN-(cAliasSD2)->D2_PRCVEN)<=nDecSB6
							(cAliasTRB)->B6_PRUNIT := A410Arred((cAliasSD2)->D2_PRCVEN,"C6_PRCVEN")
							(cAliasTRB)->B6_PRCVEN := A410Arred((cAliasSD2)->D2_PRCVEN,"C6_PRCVEN")
						ElseIf (cAliasTRB)->B6_PRUNIT == (cAliasTRB)->B6_PRCVEN .And. lMTF4P3UN
							(cAliasTRB)->B6_PRUNIT := A410Arred((cAliasSD2)->D2_PRCVEN,"C6_PRCVEN")
							(cAliasTRB)->B6_PRCVEN := A410Arred((cAliasSD2)->D2_PRCVEN,"C6_PRCVEN")
						EndIf
						(cAliasTRB)->D2_LOTECTL:= IIf(lQuery,(cAliasSD2)->LOTECTL,(cAliasSD2)->D2_LOTECTL)
						(cAliasTRB)->D2_NUMLOTE:= IIf(lQuery,(cAliasSD2)->NUMLOTE,(cAliasSD2)->D2_NUMLOTE)
					Else
						If (cAliasTRB)->B6_PRUNIT == (cAliasTRB)->B6_PRCVEN .And. Abs((cAliasTRB)->B6_PRCVEN-(cAliasSD1)->D1_VUNIT)<=nDecSB6
							(cAliasTRB)->B6_PRUNIT := A410Arred((cAliasSD1)->D1_VUNIT,"C6_PRCVEN")
							(cAliasTRB)->B6_PRCVEN := A410Arred((cAliasSD1)->D1_VUNIT,"C6_PRCVEN")
						ElseIf (cAliasTRB)->B6_PRUNIT == (cAliasTRB)->B6_PRCVEN .And. lMTF4P3UN
							(cAliasTRB)->B6_PRUNIT := A410Arred((cAliasSD1)->D1_VUNIT,"C6_PRCVEN")
							(cAliasTRB)->B6_PRCVEN := A410Arred((cAliasSD1)->D1_VUNIT,"C6_PRCVEN")
						EndIf

						(cAliasTRB)->D1_LOTECTL:= IIf(lQuery,(cAliasSD1)->LOTECTL,(cAliasSD1)->D1_LOTECTL)
						(cAliasTRB)->D1_NUMLOTE:= IIf(lQuery,(cAliasSD1)->NUMLOTE,(cAliasSD1)->D1_NUMLOTE)
					EndIf

					// Verifica se existe complemento de preco e acrescenta valor unitario correspondente
					If (nComplPrc := MaAvCpUnit((cAliasSB6)->(B6_FILIAL+B6_IDENT+B6_PRODUTO)+"R")) > 0
						(cAliasTRB)->B6_PRCVEN += nComplPrc
						(cAliasTRB)->B6_PRUNIT += nComplPrc
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Permite alterar os valores do arquivo de trabalho                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lMtFillP3
						ExecBlock("MTFILLP3",.F.,.F.,{aStruTRB,cAliasTRB,cAliasSB6,cAliasSD2,cAliasSD1,cES})
					EndIf

					MsUnLock()
				EndIf
			EndIf
		EndIf
	EndIf
	(cAliasSB6)->(dbSkip())
EndDo
If lQuery
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ARQUIVO TEMPORARIO DE MEMORIA (CTREETMP)                            ³
	//³A funcao MSCloseTemp ira substituir a linha de codigo abaixo:       ³
	//|--> dbCloseArea()                                                   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	FWCloseTemp(cAliasSB6,cNomeTrb)

	dbSelectArea("SB6")
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retira os documentos totalmente devolvidos                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cAliasTRB)
dbGotop()
While !Eof()
	If (cAliasTRB)->B6_SALDO <= 0 .Or. (cAliasTRB)->B6_ATEND == "S"
		dbDelete()
	EndIf
	dbSkip()
EndDo

dbSetOrder(1)
dbGotop()
PRIVATE aHeader := aHeadTRB
xPesq := aPesq[(cAliasTRB)->(IndexOrd())][1]
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona registros                                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cTpCliFor == "C"
	dbSelectArea("SA1")
	dbSetOrder(1)
	MsSeek(xFilial("SA1")+cCliFor+cLoja)
Else
	dbSelectArea("SA2")
	dbSetOrder(1)
	MsSeek(xFilial("SA2")+cCliFor+cLoja)
EndIf
dbSelectArea("SB1")
dbSetOrder(1)
MsSeek(xFilial("SB1")+cProduto)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calcula as coordenadas da interface                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aSize[1] /= 1.5
aSize[2] /= 1.5
aSize[3] /= 1.5
aSize[4] /= 1.3
aSize[5] /= 1.5
aSize[6] /= 1.3
aSize[7] /= 1.5

AAdd( aObjects, { 100, 020,.T.,.F.,.T.} )
AAdd( aObjects, { 100, 050,.T.,.T.} )
AAdd( aObjects, { 100, 030,.T.,.F.} )
aInfo   := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
aPosObj := MsObjSize( aInfo, aObjects,.T.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Interface com o usuario                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(cAliasTRB)->(Eof())
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0075) FROM aSize[7],000 TO aSize[6],aSize[5] OF oMainWnd PIXEL //"Documentos de Origem"
	@ aPosObj[1,1],aPosObj[1,2] MSPANEL oPanel PROMPT "" SIZE aPosObj[1,3],aPosObj[1,4] OF oDlg CENTERED LOWERED
	If lOpTriang
		cTexto1 := STR0076 //"Operacao Triangular"
	Else
		If cTpCliFor == "C"
			cTexto1 := AllTrim(RetTitle("F2_CLIENTE"))+"/"+AllTrim(RetTitle("F2_LOJA"))+": "+SA1->A1_COD+"/"+SA1->A1_LOJA+"  -  "+RetTitle("A1_NOME")+": "+SA1->A1_NOME
		Else
			cTexto1 := AllTrim(RetTitle("F1_FORNECE"))+"/"+AllTrim(RetTitle("F1_LOJA"))+": "+SA2->A2_COD+"/"+SA2->A2_LOJA+"  -  "+RetTitle("A2_NOME")+": "+SA2->A2_NOME
		EndIf
	EndIf

	@ 002,005 SAY cTexto1 SIZE aPosObj[1,3],008 OF oPanel PIXEL
	cTexto2 := AllTrim(RetTitle("B1_COD"))+": "+SB1->B1_COD+"/"+SB1->B1_DESC
	@ 012,005 SAY cTexto2 SIZE aPosObj[1,3],008 OF oPanel PIXEL
	oGetDb := MsGetDB():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],1,"Allwaystrue","allwaystrue","",.F., , ,.F., ,cAliasTRB,,,,,,.T.)

	DEFINE SBUTTON FROM aPosObj[3,1]+000,aPosObj[3,4]-030 TYPE 1 ACTION (nOpcA := 1,oDlg:End()) ENABLE OF oDlg
	DEFINE SBUTTON FROM aPosObj[3,1]+016,aPosObj[3,4]-030 TYPE 2 ACTION (nOpcA := 0,oDlg:End()) ENABLE OF oDlg

	@ aPosObj[3,1]+00,aPosObj[3,2]+00 SAY OemToAnsi(STR0077) PIXEL //"Pesquisar por:"
	@ aPosObj[3,1]+18,aPosObj[3,2]+00 SAY OemToAnsi(STR0078) PIXEL //"Localizar"
	@ aPosObj[3,1]+00,aPosObj[3,2]+40 MSCOMBOBOX oCombo VAR cCombo ITEMS aOrdem SIZE 150,044 OF oDlg PIXEL ;
	VALID ((cAliasTRB)->(dbSetOrder(oCombo:nAt)),(cAliasTRB)->(dbGotop()),xPesq := aPesq[(cAliasTRB)->(IndexOrd())][1],.T.)
	@ aPosObj[3,1]+18,aPosObj[3,2]+40 MSGET oGet VAR xPesq Of oDlg PICTURE aPesq[(cAliasTRB)->(IndexOrd())][2] PIXEL ;
	VALID ((cAliasTRB)->(MsSeek(Iif(ValType(xPesq)=="C",AllTrim(xPesq),xPesq),.T.)),.T.).And.IIf(oGetDb:oBrowse:Refresh()==Nil,.T.,.T.)
	ACTIVATE MSDIALOG oDlg CENTERED
Else
	Help(" ",1,"F4NAONOTA")
	lRetorno := .F.
EndIf
If nOpcA == 1
	lRetorno := .T.
	aHeader   := aClone(aSavHead)
	If cES == "S"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica os campos a serem atualizados                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPNfOri   := aScan(aHeader,{|x| AllTrim(x[2])=="C6_NFORI"})
		nPSerOri  := aScan(aHeader,{|x| AllTrim(x[2])=="C6_SERIORI"})
		nPItemOri := aScan(aHeader,{|x| AllTrim(x[2])=="C6_ITEMORI"})
		nPLocal   := aScan(aHeader,{|x| AllTrim(x[2])=="C6_LOCAL"})
		nPPrUnit  := aScan(aHeader,{|x| AllTrim(x[2])=="C6_PRUNIT"})
		nPPrcVen  := aScan(aHeader,{|x| AllTrim(x[2])=="C6_PRCVEN"})
		nPQuant   := aScan(aHeader,{|x| AllTrim(x[2])=="C6_QTDVEN"})
		nPQuant2UM:= aScan(aHeader,{|x| AllTrim(x[2])=="C6_UNSVEN"})
		nPLoteCtl := aScan(aHeader,{|x| AllTrim(x[2])=="C6_LOTECTL"})
		nPNumLote := aScan(aHeader,{|x| AllTrim(x[2])=="C6_NUMLOTE"})
		nPDtValid := aScan(aHeader,{|x| AllTrim(x[2])=="C6_DTVALID"})
		nPPotenc  := aScan(aHeader,{|x| AllTrim(x[2])=="C6_POTENCI"})
		nPValor   := aScan(aHeader,{|x| AllTrim(x[2])=="C6_VALOR"})
		nPValDesc := aScan(aHeader,{|x| AllTrim(x[2])=="C6_VALDESC"})
		nPIdentB6 := aScan(aHeader,{|x| AllTrim(x[2])=="C6_IDENTB6"})
		nPosLocal := aScan(aHeader,{|x| AllTrim(x[2])=="C6_LOCAL"})
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona registros                                                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SD1->(MsGoto((cAliasTRB)->SD1RECNO))
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(xFilial("SF4")+aCols[n][nPTES]))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Preenche acols                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nPIdentB6 <> 0
			aCols[N][nPIdentB6] := (cAliasTRB)->B6_IDENT
		EndIf
		If nPNfOri <> 0
			aCols[N][nPNfOri] := SD1->D1_DOC
		EndIf
		If nPSerOri <> 0
			aCols[N][nPSerOri] := SD1->D1_SERIE
		EndIf
		If nPItemOri <> 0
			aCols[N][nPItemOri] := SD1->D1_ITEM
		EndIf
		If nPPrUnit <> 0
			If (cAliasTRB)->B6_PRUNIT == (cAliasTRB)->B6_PRCVEN .And. Abs((cAliasTRB)->B6_PRCVEN-SD1->D1_VUNIT)<=nDecSB6
				aCols[N][nPPrUnit] := 0
			Else
				aCols[N][nPPrUnit] := A410Arred((cAliasTRB)->B6_PRUNIT,"C6_PRUNIT")
			EndIf
		EndIf
		If nPPrcVen <> 0
			If (cAliasTRB)->B6_PRUNIT == (cAliasTRB)->B6_PRCVEN .And. Abs((cAliasTRB)->B6_PRCVEN-SD1->D1_VUNIT)<=nDecSB6
				aCols[N][nPPrcVen] := A410Arred(SD1->D1_VUNIT,"C6_PRCVEN")
			Else
				aCols[N][nPPrcVen] := A410Arred((cAliasTRB)->B6_PRCVEN,"C6_PRCVEN")
			EndIf
		EndIf
		If nPQuant <> 0 .And. (aCols[N][nPQuant] > (cAliasTRB)->B6_SALDO .Or. aCols[N][nPQuant] == 0 )
			aCols[N][nPQuant] := Min((cAliasTRB)->B6_SALDO,A410SNfOri(cCliFor,cLoja,SD1->D1_DOC,SD1->D1_SERIE,"",SD1->D1_COD,(cAliasTRB)->B6_IDENT,aCols[n][nPosLocal])[1])
			If nPQuant2UM <> 0
				aCols[N][nPQuant2UM] := ConvUm(cProduto,aCols[N][nPQuant],0,2)
			EndIf
		EndIf
		If Rastro(cProduto) .And. SF4->F4_ESTOQUE=="S"
			If nPLoteCtl <> 0
				aCols[N][nPLoteCtl] := SD1->D1_LOTECTL
			EndIf
			If nPNumLote <> 0
				aCols[N][nPNumLote] := SD1->D1_NUMLOTE
			EndIf
			If nPDtValid <> 0 .Or. nPPotenc <> 0
				dbSelectArea("SB8")
				dbSetOrder(3)
				If MsSeek(xFilial("SB8")+cProduto+aCols[N][nPLocal]+aCols[n][nPLoteCtl]+IIf(Rastro(cProduto,"S"),aCols[N][nPNumLote],""))
					If nPDtValid <> 0
						aCols[n][nPDtValid] := SB8->B8_DTVALID
					EndIf
					If nPPotenc <> 0
						aCols[n][nPPotenc] := SB8->B8_POTENCI
					EndIf
				EndIf
			EndIf
		EndIf
		A410MultT("C6_QTDVEN",aCols[N,nPQuant])
		A410MultT("C6_PRCVEN",aCols[N,nPPrcVen])
		If nPValDesc <> 0 .And. nPPrUnit > 0
			If aCols[n][nPPrUnit]<>0
				aCols[n][nPValDesc] := a410Arred((aCols[n][nPPrUnit]-aCols[n][nPPrcVen])*IIf(aCols[n][nPQuant]==0,1,aCols[n][nPQuant]),"C6_VALDESC")
				A410MultT("C6_VALDESC",aCols[n][nPValDesc])
			EndIf
		EndIf
		If nPLocal <> 0
			aCols[N][nPLocal] := SD1->D1_LOCAL
			// Pesquisa os armazens dos movimentos do controle de qualidade
			If SD1->D1_LOCAL == cLocalCQ
				// Monta array com os armazens tratados na movimentacao do CQ
				cSeekSD7   := xFilial('SD7')+SD1->D1_NUMCQ+SD1->D1_COD+SD1->D1_LOCAL
				SD7->(dbSetOrder(1))
				SD7->(dbSeek(cSeekSD7))
				Do While !SD7->(Eof()) .And. cSeekSD7 == SD7->D7_FILIAL+SD7->D7_NUMERO+SD7->D7_PRODUTO+SD7->D7_LOCAL
					If SD7->D7_TIPO >= 1 .And. SD7->D7_TIPO <= 2 .And. SD7->D7_ESTORNO # 'S'
						If aScan(aArmazenCQ,SD7->D7_LOCDEST) == 0
							AADD(aArmazenCQ,SD7->D7_LOCDEST)
						EndIf
					EndIf
					SD7->(dbSkip())
				EndDo
				// Monta texto para apresentacao no combobox
				If Len(aArmazenCQ) > 1
					nOpca:=0
					For nx:=1 to Len(aArmazenCQ)
						AADD(aTextoCQ,OemToAnsi(STR0046)+" "+aArmazenCQ[nx])
					Next nx
					DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0084) From 130,70 To 270,360 OF oMainWnd PIXEL
					@ 05,13 SAY OemToAnsi(STR0085) OF oDlg PIXEL SIZE 110,9
					@ 17,13 TO 42,122 LABEL "" OF oDlg  PIXEL
					@ 23,17 MSCOMBOBOX oCombo VAR cCombo ITEMS aTextoCQ SIZE 100,044 OF oDlg PIXEL ON CHANGE (cLocalCQ:=aArmazenCQ[oCombo:nAt])
					DEFINE SBUTTON FROM 50,072 TYPE 1 Action (nOpca:=1,oDlg:End()) ENABLE OF oDlg PIXEL
					DEFINE SBUTTON FROM 50,099 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg PIXEL
					ACTIVATE MSDIALOG oDlg
					// Utiliza armazem relacionado ao movimento do CQ
					If nOpca == 1
						aCols[N][nPLocal] := cLocalCQ
					EndIf
				ElseIf Len(aArmazenCQ) > 0
					aCols[N][nPLocal] := aArmazenCQ[1]
				EndIf
			EndIf
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica os campos a serem atualizados                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPNfOri   := aScan(aHeader,{|x| AllTrim(x[2])=="D1_NFORI"})
		nPSerOri  := aScan(aHeader,{|x| AllTrim(x[2])=="D1_SERIORI"})
		nPItemOri := aScan(aHeader,{|x| AllTrim(x[2])=="D1_ITEMORI"})
		nPLocal   := aScan(aHeader,{|x| AllTrim(x[2])=="D1_LOCAL"})
		nPPrcVen  := aScan(aHeader,{|x| AllTrim(x[2])=="D1_VUNIT"})
		nPQuant   := aScan(aHeader,{|x| AllTrim(x[2])=="D1_QUANT"})
		nPQuant2UM:= aScan(aHeader,{|x| AllTrim(x[2])=="D1_QTSEGUM"})
		nPLoteCtl := aScan(aHeader,{|x| AllTrim(x[2])=="D1_LOTECTL"})
		nPNumLote := aScan(aHeader,{|x| AllTrim(x[2])=="D1_NUMLOTE"})
		nPDtValid := aScan(aHeader,{|x| AllTrim(x[2])=="D1_DTVALID"})
		nPPotenc  := aScan(aHeader,{|x| AllTrim(x[2])=="D1_POTENCI"})
		nPValor   := aScan(aHeader,{|x| AllTrim(x[2])=="D1_TOTAL"})
		nPValDesc := aScan(aHeader,{|x| AllTrim(x[2])=="D1_VALDESC"})
		nPDesc    := aScan(aHeader,{|x| AllTrim(x[2])=="D1_DESC"})
		nPIdentB6 := aScan(aHeader,{|x| AllTrim(x[2])=="D1_IDENTB6"})
		nPAlmTerc := aScan(aHeader,{|x| AllTrim(x[2])=="D1_ALMTERC"})
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona registros                                                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SD2->(MsGoto((cAliasTRB)->SD2RECNO))
		nRegistro := (cAliasTRB)->SD2RECNO
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(xFilial("SF4")+aCols[n][nPTES]))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Preenche acols                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nPIdentB6 <> 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Libera a trava obtida                                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cAntB6Ident := aCols[ n, nPIdentB6 ]
			If !Empty( cAntB6Ident ) .And. cAntB6Ident <> (cAliasTRB)->B6_IDENT
				Leave1Code( "SD1_D1_IDENTB6" + cAntB6Ident )
			EndIf
			aCols[N][nPIdentB6] := (cAliasTRB)->B6_IDENT
		EndIf
		If nPNfOri <> 0
			aCols[N][nPNfOri] := SD2->D2_DOC
		EndIf
		If nPSerOri <> 0
			aCols[N][nPSerOri] := SD2->D2_SERIE
		EndIf
		If nPItemOri <> 0
			aCols[N][nPItemOri] := SD2->D2_ITEM
		EndIf
		If nPLocal <> 0
			aCols[N][nPLocal] := SD2->D2_LOCAL
		EndIf
		If nPAlmTerc <> 0
			aCols[N][nPAlmTerc] := SD2->D2_ALMTERC
		EndIf
		If nPPrcVen <> 0
			aCols[N][nPPrcVen] := A410Arred((cAliasTRB)->B6_PRUNIT,"D1_VUNIT")
		EndIf
		If nPQuant <> 0 .And. ( aCols[N][nPQuant] > (cAliasTRB)->B6_SALDO .Or. aCols[N][nPQuant]==0 )
			aCols[N][nPQuant] := (cAliasTRB)->B6_SALDO
			If nPQuant2UM <> 0
				aCols[N][nPQuant2UM] := ConvUm(cProduto,aCols[N][nPQuant],0,2)
			EndIf
		EndIf
		If Rastro(cProduto) .And. SF4->F4_ESTOQUE=="S"
			If nPLoteCtl <> 0
				aCols[N][nPLoteCtl] := SD2->D2_LOTECTL
			EndIf
			If nPNumLote <> 0
				aCols[N][nPNumLote] := SD2->D2_NUMLOTE
			EndIf
			If nPDtValid <> 0 .Or. nPPotenc <> 0
				dbSelectArea("SB8")
				dbSetOrder(3)
				If MsSeek(xFilial("SB8")+cProduto+aCols[N][nPLocal]+aCols[n][nPLoteCtl]+IIf(Rastro(cProduto,"S"),aCols[N][nPNumLote],""))
					If nPDtValid <> 0
						aCols[n][nPDtValid] := SB8->B8_DTVALID
					EndIf
					If nPPotenc <> 0
						aCols[n][nPPotenc] := SB8->B8_POTENCI
					EndIf
				EndIf
			EndIf
		EndIf
		If nPValDesc <> 0 .And. nPQuant <> 0 .And. nPDesc <> 0
			aCols[n][nPValDesc] := a410Arred(((cAliasTRB)->B6_PRUNIT-(cAliasTRB)->B6_PRCVEN)*IIf(aCols[n][nPQuant]==0,1,aCols[n][nPQuant]),"D1_VALDESC")
		EndIf
		aCols[n][nPValor] := a410Arred(IIf(aCols[n][nPQuant]==0,1,aCols[n][nPQuant])*aCols[n][nPPrcVen],"D1_TOTAL")
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de Entrada para customizar o aCols.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("A440VCOL")
		aA440VCOL:= ExecBlock("A440VCOL",.f.,.f.,{aHeader,aCols})
		If ValType(aA440VCOL)=="A"
			aCols:= aClone(aA440VCOL)
		EndIf
	Endif

	If !Empty(cReadVar)

		Do Case
			Case cReadVar $ "M->C6_QTDVEN"
				&(cReadVar) := aCols[n][nPQuant]
			Case cReadVar $ "M->C6_UNSVEN"
				&(cReadVar) := aCols[n][nPQuant2UM]
			OtherWise
				cReadVar	:= StrTran(cReadVar,"M->","")
				nPosCpo	:= aScan(aHeader,{|x| AllTrim(x[2]) == cReadVar})
				If nPosCpo > 0
					&(cReadVar) := aCols[n][nPosCpo]
				Endif
		EndCase
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a integridade da rotina                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cAliasTRB)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ARQUIVO TEMPORARIO DE MEMORIA (CTREETMP)                            ³
//³A funcao MSCloseTemp ira substituir a linha de codigo abaixo:       ³
//|--> dbCloseArea()                                                   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
oTempTable:Delete()

RestArea(aArea)
SetFocus(nHandle)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaAvCpUnit³ Autor³ Brunno de Medeiros da Costa ³Data ³26/10/17 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Retorna Valor Correspondente a Complemento de Preco da NF      ³±±
±±³          ³ de Origem                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cChave: SB6->(B6_FILIAL+B6_IDENT+B6_PRODUTO+B6_PODER3)		  ³±±
±±³          ³ 																  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ F4Poder3, MATV410A                                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function MaAvCpUnit(cChave)

Local nComplPrc := 0, nQuant := 0, aAreaSB6 := SB6->(GetArea())

SB6->(DbSetOrder(3))
SB6->(DbSeek(cChave))
While cChave == SB6->(B6_FILIAL+B6_IDENT+B6_PRODUTO+B6_PODER3) .AND. !SB6->(Eof())
	If SB6->B6_TIPO == "D" .AND. SB6->B6_QUANT != 0
		nQuant += SB6->B6_QUANT
	EndIf
	SB6->(DbSkip())
EndDo

SB6->(DbSetOrder(4))
SB6->(DbSeek(cChave))
While cChave == SB6->(B6_FILIAL+B6_IDENTB6+B6_PRODUTO+B6_PODER3) .AND. !SB6->(Eof())
	If SB6->B6_TIPO == "D" .AND. SB6->B6_QUANT == 0
		nComplPrc += SB6->B6_PRUNIT / nQuant
	EndIf
	SB6->(DbSkip())
EndDo

RestArea(aAreaSB6)

Return nComplPrc


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaTesSel  ³ Autor ³ Rodrigo Sartorio      ³ Data ³19.11.2001 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de verificacao da quantidade digitada conforme a TES  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := MaTesSel(ExpC1)									   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo da TES                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. - A quantidade nao eh necessaria                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo verificar se a quantidade do   ³±±
±±³          ³produto deve ser informada ou nao.                           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaTesSel(cCodTes)

Local lRet    := .F.
Local aArea   := GetArea()
Local aAreaSF4:= SF4->(GetArea())
dbSelectArea('SF4')
dbSetOrder(1)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a TES PERMITE QUANTIDADE ZERO                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SF4->F4_CODIGO == cCodTes .Or. MsSeek(xFilial("SF4")+cCodTes)
	If F4_QTDZERO == "1"
		lRet:=.T.	
	EndIf
EndIf
RestArea(aAreaSF4)
RestArea(aArea)
RETURN(lRet)
    

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AvalEmpSCP³ Autor ³Rodrigo de A Sartorio  ³ Data ³30/06/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para verificar o empenho relacionado ao SCP         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := AvalEmpSCP(ExpC1,ExpC2,ExpC3,ExpN1)	              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1: Produto                                        	  ³±±
±±³          ³ ExpC2: Armazem                                        	  ³±±
±±³          ³ ExpC3: Ordem de Producao                               	  ³±±
±±³          ³ ExpN1: Quantidade                                     	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. - Se qtde.empenhada >= qtde. informada    		  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA185                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AvalEmpSCP(cProduto,cLocal,cOP,nQuant)

Local lRet:=.F.
Local aArea:=GetArea()
Local cSeek:=xFilial("SD4")+cProduto+cOP
Local cCompara:= "D4_FILIAL+D4_COD+D4_OP"
Local nQtdOri:=0  

If !Empty(cOP)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe empenho para o produto              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SD4")
	dbSetOrder(1)
	dbSeek(cSeek)
	While !EOF() .And. cSeek == &(cCompara)
		If D4_LOCAL == cLocal
			nQtdOri+=D4_QUANT
		EndIf
		dbSkip()
	End
	RestArea(aArea)
	lRet:=QtdComp(nQtdOri)>=QtdComp(nQuant)
EndIf
Return(lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AvalSalPed³ Autor ³Marcos V. Ferreira     ³ Data ³08/11/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao utilizada para verificar Previsao de Entrada, campo ³±±
±±³			 | B2_SALPEDI, verificando as SC's geradas por Solicitacao ao ³±±
±±³			 | Armazem e SC's geradas pelo MRP.							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpN1 := AvalSalPed(ExpC1,ExpC2)				              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1: Produto                                       	  ³±±
±±³          ³ ExpC2: Armazem                                         	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpN1: qtde prevista - reservas para SA e MRP. 			  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ COMXFUN                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AvalSalPed(cProd,cLocal)

Local aAreaAnt  := GetArea()
Local aAreaSB2  := SB2->(GetArea())
Local nQtdPrev  := 0
Local lQuery    := .F.
Local cQuery    := ''
Local cAliasSC1 := 'SC1'
Local nLE       := RetFldProd(cProd,"B1_LE")

Default cProd   := ''
Default cLocal  := ''

dbSelectArea('SB2')
dbSetOrder(1)
If dbSeek(xFilial("SB2")+cProd+cLocal)
	nQtdPrev := SB2->B2_SALPEDI
	If nQtdPrev > 0 .And. nLE <= 0
		dbSelectArea('SC1')
		dbSetOrder(2)

		lQuery := .T.
		cAliasSC1:= GetNextAlias()
		cQuery += "SELECT C1_QUANT,C1_QUJE,C1_ORIGEM,C1_SEQMRP,C1_OP "
		cQuery +=   "FROM "+RetSqlName("SC1")+" "
		cQuery +=  "WHERE C1_FILIAL='"+xFilial("SC1")+"' "
		cQuery +=   " AND C1_PRODUTO='"+cProd+"' "
		cQuery +=   " AND C1_LOCAL='"+cLocal+"' "
		cQuery +=   " AND C1_QUJE < C1_QUANT "
		cQuery +=   " AND D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSC1,.T.,.T.)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Analisa quantidade prevista para entrada ja reservada para SA ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		While !(cAliasSC1)->(Eof()) .And. IIf(lQuery,.T.,cSeek==(cAliasSC1)->C1_FILIAL+(cAliasSC1)->C1_PRODUTO)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se nao deve considerar a solicitacao de compras      ³	
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lQuery
				If (cAliasSC1)->C1_LOCAL <> cLocal .Or. (cAliasSC1)->C1_QUJE >= (cAliasSC1)->C1_QUANT
					dbSkip()
					Loop
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Subtrai da quantidade prevista das reservas para SA e MRP.    ³	
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If AllTrim((cAliasSC1)->C1_ORIGEM) == "MATA106" .Or. !Empty((cAliasSC1)->C1_SEQMRP) .Or. !Empty((cAliasSC1)->C1_OP)
				nQtdPrev -= (cAliasSC1)->C1_QUANT-(cAliasSC1)->C1_QUJE
			EndIf
			dbSkip()
		EndDo 
		If lQuery
			(cAliasSC1)->(dbCloseArea())
		EndIf
	EndIf
EndIf	

RestArea(aAreaSB2)
RestArea(aAreaAnt)
Return(nQtdPrev)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MatPesqCtr³ Autor ³Nereu Humberto Junior  ³ Data ³18/04/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao utilizada para verificar se a pesquisa do contrato  ³±±
±±³			 | de parceria deve ocorrer por fornecedor+loja padrao ou por ³±±
±±³			 | produto somente.                 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpN1 := MatPesqCtr(ExpL1,ExpC1,ExpC2,ExpC3,ExpC4)         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1: Indica se pesquisa ou somente testa o parametro     ³±±
±±³          ³ ExpC1: Fornecedor Padrao                               	  ³±±
±±³          ³ ExpC2: Loja Padrao                                   	  ³±±
±±³          ³ ExpC3: Produto                                             ³±±
±±³          ³ ExpC3: Chave de pesquisa utilizada no laco                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1: .T. -> Se achou um contrato valido.    			  ³±±
±±³          ³        .F. -> Se nao achou um contrato valido.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ COMXFUN/MATA650/MATA710/MATA712                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MatPesqCtr(lSeek,cProd,cForn,cLoja,cChaveSC3)

Local lRet  := .F.
Local lPesqForn := IIF(GetNewPar("MV_PESQCTP","F")=="F",.T.,.F.) //F - Pesquisa por Fornecedor  /  P - Pesquisa por Produto

If cChaveSC3 == Nil
	cChaveSC3 := ""
Endif

If lSeek 
	//--Utilizar indice que considera a filial de entrega, visando avaliar corretamente o saldo de acordo com a filial que recebera o material
	SC3->(dbSetOrder(4))
	If lPesqForn
		If SC3->(dbSeek(xFilial("SC3")+SB1->B1_COD+SB1->B1_PROC+SB1->B1_LOJPROC))
			lRet := .T.   
			//--Utilizar a filial de entrega na chave de pesquisa
			cChaveSC3 := 'SC3->C3_FILENT+SC3->C3_PRODUTO+SC3->C3_FORNECE+SC3->C3_LOJA == xFilial("SC3")+SB1->B1_COD+SB1->B1_PROC+SB1->B1_LOJPROC'
		Endif	
	Else
		If SC3->(dbSeek(xFilial("SC3")+SB1->B1_COD))
			lRet := .T.
			cChaveSC3 := 'SC3->C3_FILENT+SC3->C3_PRODUTO == xFilial("SC3")+SB1->B1_COD'
		Endif	
	Endif
Else
	lRet := lPesqForn
Endif	

Return(lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ATUSA5    ºAutor  ³Patricia D. Aguiar  º Data ³  03/09/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza Amarracao Produto x fornecedor                     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpC1= Codigo do fornecedor                                º±±
±±º          ³ ExpC2= Loja fornecedor                                     º±±
±±º          ³ ExpC3= Codigo do produto                                   º±±
±±º          ³ ExpL4= Indica de grava SA5 pelo codigo do produto ou pela  º±±
±±º          ³        referencia de grade                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function AtuSA5(cFornece,cLoja,cProduto,lIncRef)

Local aAreaSa5    := SA5->(GetArea())
Local aAreaSx3    := SX3->(GetArea())
Local cProdRef    := " "
Local lReferencia := .F.
Local lGrade      := MaGrade()
Local lAchou      := .F.
DEFAULT lIncRef   := .F.

cProdRef := cProduto
If lGrade
	lReferencia:= MatGrdPrRf(@cProdRef,.T.)
Endif

dbSelectArea("SA5")
dbSetOrder(1)
lAchou := MsSeek(xFilial("SA5")+cFornece+cLoja+cProduto,.F.)

If !lAchou
	
	If lReferencia
		
		DbSelectArea("SA5")
		DbSetOrder(9)
		
		lAchou := MsSeek(xFilial("SA5")+cFornece+cLoja+cProdRef,.F.)
		
	EndIf
	
	If (!lAchou .And. !lIncRef) .Or. (!lAchou .And. !lReferencia)
		
		RecLock("SA5", .T.)
			
			// Grava os inicializadores padroes dos demais campos.
			SX3->(DbSetOrder(1)) // Indice 1 - X3_ARQUIVO+X3_ORDEM
			If SX3->(DbSeek('SA5'))
				
				While SX3->(!EOF()) .And. SX3->X3_ARQUIVO == 'SA5'
					
					If SX3->X3_CONTEXT <> "V" // Retira os campos virtuais.
						
						SA5->&(SX3->X3_CAMPO) := CriaVar(SX3->X3_CAMPO, .T.)
						
					EndIf
					
					SX3->(DbSkip())
					
				EndDo
				
			EndIf
			
			SA5->A5_FILIAL  := xFilial("SA5")
			SA5->A5_FORNECE := cFornece
			SA5->A5_LOJA    := cLoja
			SA5->A5_NOMEFOR := Posicione("SA2",1,xFilial("SA2")+cFornece+cLoja,"A2_NOME")
			SA5->A5_PRODUTO := cProduto
			SA5->A5_NOMPROD := Posicione("SB1",1,xFilial("SB1")+cProduto,"B1_DESC")
			
		SA5->(MsUnlock())
		
	ElseIf !lAchou .And. lIncRef .And. lReferencia
		
		RecLock("SA5", .T.)
			
			// Grava os inicializadores padroes dos demais campos.
			SX3->(DbSetOrder(1)) // Indice 1 - X3_ARQUIVO+X3_ORDEM
			If SX3->(DbSeek('SA5'))
				
				While SX3->(!EOF()) .And. SX3->X3_ARQUIVO == 'SA5'
					
					If SX3->X3_CONTEXT <> "V" // Retira os campos virtuais.
						
						SA5->&(SX3->X3_CAMPO) := CriaVar(SX3->X3_CAMPO, .T.)
						
					EndIf
					
					SX3->(DbSkip())
					
				EndDo
				
			EndIf
			
			SA5->A5_FILIAL  := xFilial("SA5")
			SA5->A5_FORNECE := cFornece
			SA5->A5_LOJA    := cLoja
			SA5->A5_NOMEFOR := Posicione("SA2",1,xFilial("SA2")+cFornece+cLoja,"A2_NOME")
			SA5->A5_REFGRD  := cProdRef
			SA5->A5_DESREF  := DescPrRF(cProdRef)
			
		SA5->(MsUnlock())
		
	EndIf
	
EndIf

RestArea(aAreaSa5)
RestArea(aAreaSx3)

Return(cProdRef)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³aColsGradeºAutor  ³Marcelo Iuspa       º Data ³  12/02/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Monta acols aglutinado                                     º±±
±±º          ³                                                            º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ oGrade     = Objeto grade previamente criado               ³±±
±±³          ³ aCols      = aCols original conforme alimentado pelo WT    ³±±
±±³          ³ aHeader    = aHeader para pesquisa de campos lidos no aCols³±±
±±³          ³ cProduto   = Campo com o produto (Ex.: "C1_PRODUTO")       ³±± 
±±³          ³ cItem      = Campo com o item (Ex.: "C1_ITEM")             ³±± 
±±³          ³ cItemGrd   = Campo com o item da grade (Ex.: "C1_ITEMGRD") ³±± 
±±³          ³ nPosCodDes = Posicao do aHeader para descricao do produto  ³±± 
±±³          ³ nAcolsAnt = Tamanho do aCols antes da importação dos itens ³±± 
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Retorno   ³ Array para ser usado como aCols e alimentacao de itens     ³±± 
±±³          ³ de grade no objeto grade informado                         ³±± 
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Tratamento de aCols gerado pelo WT (sem grade) aglutinando º±±
±±³          ³ itens de grade e ao mesmo tempo alimentando o objeto grade ³±± 
±±³          ³ com os respectivos campos migrados da aCols original       ³±± 
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function aColsGrade(oGrade, aCols, aHeader, cProduto, cItem, cItemGrd,nPosCodDes,lZerou, nAcolsAnt)

Local nLoop
Local nLoop2
Local aColsGrade := {}
Local nItem      := aScan(aHeader,{|z| AllTrim(z[2]) == AllTrim(cItem   )})
Local nItemGrd   := aScan(aHeader,{|z| AllTrim(z[2]) == AllTrim(cItemGrd)})
Local nProduto   := aScan(aHeader,{|z| AllTrim(z[2]) == AllTrim(cProduto)})
Local cProdRef   := Nil
Local cCodProd   := Nil
Local aColsRet   := {}
Local nItGrade   := Nil  
Local lReferencia := .F.
Local nA  		 := 1
DEFAULT nPosCodDes:= 0
DEFAULT lZerou     := .F.

aEval(oGrade:aCposCtrlGrd, {|z,w| Aadd(aColsGrade, {z[1], GDFieldPos(z[1], aHeader), TamSX3(z[1])[3], w})})

If ValType(nAcolsAnt)=="N" .And. nAcolsAnt < Len(aCols)
	For nA:= 1 To nAcolsAnt
		Aadd(aColsRet, aCols[nA])//igualando o aCols para atualizar o MontaGrade apenas nos itens novos
	Next
EndIf

For nLoop := nA to Len(aCols)  
    cProdRef:=aCols[nLoop, nProduto]
    lReferencia:= IIF(__lpyme,MatGrdPrrf(@cProdRef,.T.),!Empty(cItemGrd))
   	If Empty(cProdRef) .Or. (! lReferencia) .Or. Empty(aCols[nLoop, nItemGrd])
		Aadd(aColsRet, aCols[nLoop])  
		oGrade:cProdRef := cProdRef
	  	oGrade:MontaGrade(Len(aColsRet), aCols[nLoop, nProduto],,,.F.,lZerou)
	Else
		IIF(!__lpyme,MatGrdPrrf(@cProdRef,.T.),NIL) 
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Inicializa o aHeadGrade e o AcolsGrade                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cCodProd := aCols[nLoop, nProduto]      
		oGrade:cProdRef := cProdRef

		If (nItGrade := aScan(aColsRet, {|z| z[nItem] == aCols[nLoop, nItem]})) == 0
			Aadd(aColsRet, aClone(aCols[nLoop]))
			nItGrade := Len(aColsRet)
			aColsRet[nItGrade, nProduto] := Pad(cProdRef, Len(SB1->B1_COD))
			If nPosCodDes >0
				aColsRet[nItGrade, nPosCodDes] := oGrade:GetDescProd(cProdRef)
			EndIf
			If !(Alltrim(cCodProd)==Alltrim(cProdRef))
				For nLoop2 := 1 to Len(aColsGrade)
					If aColsGrade[nLoop2,2]>0 		    
						If aColsGrade[nLoop2, 3] == "N"   
							aColsRet[nItGrade, aColsGrade[nLoop2, 2]] := 0
						ElseIf	aColsGrade[nLoop2, 3] == "D"
							If aColsGrade[nLoop2,2]>0 		    
								aColsRet[nItGrade, aColsGrade[nLoop2, 2]] := Ctod("")
							Endif
						EndIf
					EndIf
				Next
		
				oGrade:MontaGrade(nItGrade,@cProdRef,,,,lZerou)
				
			Endif
		EndIf

		cLinha   := AllTrim(Substr(cCodProd,oGrade:TamRef(nItGrade)+1,oGrade:TamLin(nItgrade)))
		cColuna  := AllTrim(Substr(cCodProd,oGrade:TamRef(nItgrade)+oGrade:TamLin(nItgrade)+1,oGrade:TamCol(nItgrade)))

		nColuna := oGrade:RetPosCol(nItGrade,cColuna)
		nLinha  := oGrade:RetPosLin(nItGrade,cLinha)

		If ( nColuna<>0 .And. nLinha <> 0 )
			nColuna++
			For nLoop2 := 1 to Len(aColsGrade)
				If aColsGrade[nLoop2,2]>0 		    
					If  aColsGrade[nLoop2, 3] == "N"
						aColsRet[nItGrade, aColsGrade[nLoop2, 2]] += aCols[nLoop, aColsGrade[nLoop2, 2]]
					ElseIf aColsGrade[nLoop2, 3] == "D"
						aColsRet[nItGrade, aColsGrade[nLoop2, 2]] := Max(aCols[nLoop, aColsGrade[nLoop2, 2]], aColsRet[nItGrade, aColsGrade[nLoop2, 2]])
					EndIf
	
					If aColsGrade[nLoop2, 3] == "N"
						oGrade:aColsGrade[nItGrade][nLinha][nColuna][oGrade:GetFieldGrdPos(aColsGrade[nLoop2, 1])] += aCols[nLoop, aColsGrade[nLoop2, 2]]
					ElseIf	aColsGrade[nLoop2, 3] == "C"
						oGrade:aColsGrade[nItGrade][nLinha][nColuna][oGrade:GetFieldGrdPos(aColsGrade[nLoop2, 1])] := aCols[nLoop, aColsGrade[nLoop2, 2]]
					ElseIf	aColsGrade[nLoop2, 3] == "D"
						oGrade:aColsGrade[nItGrade][nLinha][nColuna][oGrade:GetFieldGrdPos(aColsGrade[nLoop2, 1])] := Max(oGrade:aColsGrade[nItGrade][nLinha][nColuna][oGrade:GetFieldGrdPos(aColsGrade[nLoop2, 1])], aCols[nLoop, aColsGrade[nLoop2, 2]])
					EndIf
				EndIf
			Next
		EndIf
		If aScan(aHeader, {|z| "_REC_WT" $ z[2]}) > 0 .And. Len(aCols[nLoop]) >= Len(aHeader) .And. nColuna <>0 .And. nLinha <> 0
			oGrade:SetRecNo(nItGrade,nLinha,nColuna, aCols[nLoop,Len(aHeader)])
		Endif	
	EndIf 
Next

Return(aClone(aColsRet))

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³aGradeColsºAutor  ³Marcelo Iuspa       º Data ³  12/02/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Monta acols expandido com os itens da grade                º±±
±±º          ³                                                            º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ oGrade     = Objeto grade usado na getdados                ³±±
±±³          ³ aCols      = aCols resultante da edicao via getdados       ³±±
±±³          ³ aHeader    = aHeader para pesquisa de campos lidos no aCols³±±
±±³          ³ cProduto   = Campo com o produto (Ex.: "C1_PRODUTO")       ³±± 
±±³          ³ cItemGrd   = Campo com o item da grade (Ex.: "C1_ITEMGRD") ³±± 
±±³          ³ cQuant     = Campo com a quantidade (Ex.: "C1_QUANT")      ³±± 
±±³          ³                                                            ³±± 
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Retorno   ³ Array retornado a forma usual pronto para uso nas rotinas  ³±± 
±±º          ³ de gravacao sem qualquer alteracao nas mesmas.             º±±
±±³          ³ As informacoes dos itens da grade serao lidas diretamente  º±±
±±º          ³ no objeto grade informado                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Tratamento de aCols editado via GetDados concatenando      º±±
±±³          ³ dados com os itens de grade editados via objeto grade      ³±± 
±±³          ³ informado                                                  ³±± 
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function aGradeCols(oGrade, aCols, aHeader, cProduto, cItemGrd, cQuant, cItem)

Local nLoop       := Nil
Local nLoop2      := Nil
Local nLoop3	  := Nil
Local nItemGrd    := aScan(aHeader,{|z| AllTrim(z[2]) == AllTrim(cItemGrd)})
Local nProduto    := aScan(aHeader,{|z| AllTrim(z[2]) == AllTrim(cProduto)})
Local nPosQuant   := 0
Local nPosItem    := 0
Local aColsRet    := {}
Local nLinha      := Nil
Local nColuna     := Nil
Local nField      := Nil
Local nPosField   := Nil
Local nLenAcols   := Nil
Local lWalkThru   := aScan(aHeader, {|z| "_REC_WT" $ z[2]}) > 0
Local cNewItemGr  := StrZero(1,TamSX3(cItemGrd)[1])
Local lProcessa   := .T.

For nLoop := 1 to Len(aCols)
	If Empty(aCols[nLoop, nItemGrd])
		Aadd(aColsRet, aCols[nLoop])
	Else

		oGrade:cProdRef := GDFieldGet(cProduto,nLoop,,aHeader,aCols)
		oGrade:nPosLinO := nLoop

		For nLinha := 1 to Len(oGrade:aColsGrade[nLoop])
			For nColuna := 2 to Len(oGrade:aHeadGrade[nLoop])
				If ValType(cQuant) == "A"
					For nLoop2 := 1 To Len(cQuant)
						nPosQuant := aScan(oGrade:aCposCtrlGrd,{|x| AllTrim(x[1]) == cQuant[nLoop2]})
						If Empty(oGrade:aColsGrade[nLoop, nLinha, nColuna, nPosQuant])
							lProcessa := .F.
						Else
							lProcessa := .T.
							Exit
						Endif
					Next nLoop2
				Else
					nPosQuant := aScan(oGrade:aCposCtrlGrd,{|x| AllTrim(x[1]) == cQuant})
					If Empty(oGrade:aColsGrade[nLoop, nLinha, nColuna, nPosQuant])
						lProcessa := .F.
					Else
						lProcessa := .T.
					Endif					
				EndIf
				If !lProcessa
					Loop
				EndIf
				Aadd(aColsRet, aClone(aCols[nLoop]))
		   		nLenAcols := Len(aColsRet)				
				For nField := 1 to Len(oGrade:aCposCtrlGrd)
					nPosField := aScan(aHeader, {|z| AllTrim(z[2]) == AllTrim(oGrade:aCposCtrlGrd[nField, 1])})
					If !Empty(nPosField)
						aColsRet[nLenAcols, nPosField] := oGrade:aColsGrade[nLoop, nLinha, nColuna, nField]
					EndIf
				Next
				aColsRet[nLenAcols, nProduto] := oGrade:GetNameProd(AllTrim(aColsRet[nLenAcols, nProduto]),nLinha,nColuna)
				If lWalkThru .And. Len(aCols[nLoop]) >= Len(aHeader)
					aColsRet[nLenAcols, Len(aHeader)] := oGrade:GetRecNo(nLoop,nLinha,nColuna, aCols[nLoop,Len(aHeader)])
				Endif	
			Next
		Next	
		
		//Ajusta ordem e itemgrd
		If !Empty(cItem)
			nPosItem := aScan(aHeader,{|z| AllTrim(z[2]) == AllTrim(cItem)})
			aSort(aColsRet,,,{|x,y | x[nPosItem]+x[nProduto] < y[nPosItem]+y[nProduto] } )
			cNewItemGr := StrZero(1,TamSX3(cItemGrd)[1])
			
			For nLoop3 := 1 to Len(aColsRet)
				If AllTrim(oGrade:cProdRef) $ aColsRet[nLoop3,nProduto] .And. !Empty(aColsRet[nLoop3,nItemGrd])
					aColsRet[nLoop3,nItemGrd] := cNewItemGr
					cNewItemGr := Soma1(cNewItemGr)
				EndIf
			Next nLoop3
		EndIf
	Endif
Next

Return(aClone(aColsRet))

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ VldHead      ³ Autor ³ Ricardo Berti      	³ Data ³ 27/06/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida todos os campos do aCols via validacao do aHeader		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ VldHead(ExpA1,ExpA2,ExpN1,ExpO1)		                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array aCols									          ³±±
±±³          ³ ExpA2 = Array aHeader										  ³±±
±±³          ³ ExpN1 = (Linha do aCols a validar):  Quando informada, valida  ³±±
±±³          ³   somente a linha, quando nao informada, validara' todo o aCols³±±
±±³          ³ ExpO1 = obj da getdados										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. = Validacao OK			                                  ³±±
±±³          ³ .F. = Validacao nao OK.                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VldHead(aCols,aHeader,nLinha,oGetH)

Local cVar
Local cCampo
Local bBlock	:= {}
Local lRet		:= .T.
Local nX
Local nY
Local nLenACols := If(ValType(nLinha)=="N",nLinha,Len(aCols))

DEFAULT nLinha	 := 1
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ O parametro MV_VLDHEAD e' usado para validar ou nao o aCols          ³
//³ (uma linha ou todo), a partir das validacoes do aHeader -> VldHead() ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lVldHead:= If(ValType(lVldHead) == "L",lVldHead, GetNewPar( "MV_VLDHEAD",.T. ) )

Private lGatilha := .F.  // Para nao alterar o conteudo dos campos do aCols, somente valida-lo

If lVldHead .And. ValType(aHeader)=="A" .And.ValType(aCols)=="A"
	For nX := nLinha to nLenACols
		If !GdDeleted(nX,aHeader,aCols)
			n := nX   
			For nY := 1 to Len(aHeader)
				// criar todas variaveis de memoria
				cVar  := "M->"+Upper(AllTrim(aHeader[nY,2]))
				&cVar := aCols[nX,nY]
			Next
			For nY := 1 to Len(aHeader)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao consiste campos visuais ou cujas validacoes modifiquem o aCols ou com validacoes fiscais ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cVar  := Upper(AllTrim(aHeader[nY,2]))
			    If !Empty(aCols[nX][nY]) .And. !Empty(aHeader[nY,6 ]) .And. ;
					!cVar$"C1_PRODUTO,C1_CODGRP,C1_CODITE,C1_UM,C1_QUANT,C1_SEGUM,C1_QTDSEGUM,C1_TAREFA,C1_PROJETO,C1_APROV,"+;
					      "C7_PRODUTO,C7_CODGRP,C7_CODITE,C7_UM,C7_QUANT,C7_SEGUM,C7_QTDSEGUM,C7_FRETE,C7_NUMCOT,C7_GRADE,C7_BASESOL" .And. ;
					!"MAFIS"$Upper(aHeader[nY,6 ])

					cCampo:= aCols[nX,nY]
					If aHeader[nY][8] == "C"
						cCampo := Padr(cCampo,aHeader[nY][4])
					EndIf
					__READVAR := "M->" + cVar
					&(__READVAR) := cCampo

					bBlock := &( "{ || " + AllTrim( aHeader[ny,6 ] ) + " }" )
					If ! Eval( bBlock )
						If ValType(oGetH) == "O"
  							oGetH:nAt:=nX
							oGetH:Refresh()
							oGetH:SetFocus()
						EndIf
						lRet :=.F.
						Exit
					EndIf
				EndIf
			Next
		EndIf
	Next
EndIf
Return(lRet)
  
	
/*/
______________________________________________________________________________
¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦
¦¦+------------------------------------------------------------------------+¦¦
¦¦¦Funcao    ¦  VALSCPRE    ¦ Autor ¦ Bruna Paola       ¦ Data ¦ 20/05/11  ¦¦¦
¦¦+----------+-------------------------------------------------------------¦¦¦
¦¦¦Descricao ¦ Funcao de validacao do campo C1_XTIPOSC.					   ¦¦¦
¦¦+----------+-------------------------------------------------------------¦¦¦
¦¦¦Uso       ¦ Exclusivo TOTVS.								   			   ¦¦¦
¦¦+----------+-------------------------------------------------------------¦¦¦
¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
/*/  
Function VALSCPRE(cTipoSC, lFlag)

Local cChave 	:= "" 
Local cQuery 	:= ""
Local nControle := 0
Local cMsg		:= ""
Local lParam	:= GETMV("MV_SEQESP")
Local cTpAx 	:= GETMV("MV_TPSCAX")

If(lParam == .F.)
	Return (.T.)
EndIf

DbSelectArea("COD")
DbSetOrder(1)  
                   
// Verifica se existe range cadastrado para o tipo de documento escolhido
If !( DbSeek(xFilial("COD")+cTpAx) )   

	MsgAlert(STR0145 ,STR0014) // "O código que está informado no parametro MV_TPSCAX não está cadastrado nos tipos de documento. Favor verificar."##"ATENCAO"
	
	Return (.F.)	
EndIf       


DbSelectArea("COE")
DbSetOrder(2)  //PA1_FILIAL+PA1_DOC
                   
// Verifica se existe range cadastrado para o tipo de documento escolhido
If !( DbSeek(xFilial("COE")+cTipoSC) )   

	MsgAlert(STR0146 ,STR0014) // "O sistema esta configurado para utilizar codificação especifica. O tipo de documento escolhido, nao possui um intervalo cadastrado." ## "ATENCAO"
	
	Return (.F.)	
EndIf       
  
// Procura qual o ultimo numero usado no C1_NUM para esse tipo de documento selecionado
cQuery  := "  SELECT MAX(C1_NUM) AS C1_NUM"
cQuery  += "  FROM " + RetSQLName('SC1') + " SC1 " 
cQuery  += "  WHERE C1_XTIPOSC = " + ValToSQL(cTipoSC) + "AND"
cQuery  += "  D_E_L_E_T_ <> '*' "

cQuery := ChangeQuery(cQuery) 

Conout(cQuery)

DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"TEMP",.T.,.T.)

DbSelectArea("TEMP")  

If lxCont == .T.  .And. lFlag
	DbSelectArea("SC1")    
	SC1->C1_NUM := TEMP->(C1_NUM)
	Return (.T.)
Endif 

// Incrementar 1 no C1_NUM encontrado 
If ( Empty(C1_NUM) ) // Primeiro registro de SC do tipo de documento escolhido
	cNum := COE->COE_INICIO
Else
	cNum := Soma1(C1_NUM)
EndIf

TEMP->( DbCloseArea() )

DbSelectArea("COE")
DbSetOrder(2)  //COE_FILIAL+COE_DOC 
DbSeek(xFilial("COE")+cTipoSC)

cChave := xFilial("COE")+cTipoSC 
	
Do While !( Eof() ) .And. ( xFilial("COE")+COE->COE_DOC == cChave ) // Verifica somente os ranges do tipo de documento escolhido

	If (cNum >= COE->COE_INICIO).And.(cNum <= COE->COE_FINAL) // Verifica se o numero pertence a algum range definido      
       nControle := 1 
       Exit
    ElseIf (cNum < COE->COE_INICIO) // Primeiro num do intervalo cadastrado  
    	cNum := COE->COE_INICIO
    	nControle := 1
    	Exit
	EndIf      

	DbSkip()
EndDo     
	
// Nao existe intervalo cadastrado para o tipo de documento(acabou o range dos cadastrados)
If (nControle == 0)
          
	MsgAlert(STR0147 ,STR0014) // "Um novo intervalo deve ser cadastrado para esse tipo de documento." ## "ATENCAO"
	
	Return (.F.)
EndIf    

If (lFlag == .T.)
	// Atribui ao objeto Num da SC o valor definido pelo tipo de documento.   
	DbSelectArea("SC1")    
	SC1->C1_NUM := cNum  
	lxCont := .T.  
EndIf

Return (.T.) 

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaGeraAE     ³ Autor ³ Andre dos Anjos      	³ Data ³ 18/06/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera as autorizacoes de entrega por contrato para um produto   ³±±
±±³			 ³ e sua necessidade.											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cProduto:codigo do produto									  ³±±
±±³          ³ nNecess: necessidade de compra   							  ³±±
±±³          ³ aCampos: campos especificos a serem gravados por rotinas.	  ³±±
±±³          ³ cRotina: identifica a rotina chamadora da funcao.			  ³±±
±±³          ³ cPV: numero do pedido de venda relacionado (exclusivo MATA650).³±±
±±³          ³ cItemPV: item do pedido de venda relacionado (exclus. MATA650).³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MatGeraAE(cProduto,nNecess,aCampos,cRotina,cPV,cItemPV,aRateio)
Local aAEs			:= {}
Local aEntidades	:= {}
Local aMtGeraAe		:= {}
Local aRefImp       := {}
Local aUser			:= {}
Local aCTBEnt		:= CTBEntArr()
Local aRet			:= {}

Local dDataNec  	:= dDataBase

Local nSaldoFor 	:= 0
Local nPercTot  	:= 0
Local nPosCtr		:= 0
Local nX			:= 0
Local nY			:= 0
Local nZ			:= 0
Local nTotAEs		:= 0
Local nQtdeGera 	:= 0
Local nPosTpOp		:= 0
Local nSaldoGer		:= 0
Local nNecOrig  	:= nNecess

Local cChave    	:= ""
Local cQuery		:= ""
Local cNumAglu  	:= ""
Local cItemAgl		:= ""
Local cItemCH		:= ""
Local cFilTpOp  	:= "F"
Local cNewGrp		:= ""
Local cLogin		:= ""

Local lAlcada		:= .T.
Local lMatrizF  	:= SuperGetMV("MV_MATRIZF",.F.,.F.) //-- Indica se utiliza o conceito de matriz de fornecimento
Local lCPGerSC  	:= SuperGetMV("MV_CPGERSC",.F.,.T.) .Or. SuperGetMV("MV_SCCONTR",.F.,"1") == "1" //-- Indica se gera SC na ausencia de CP
Local lRediSld  	:= SuperGetMV("MV_MFREDIS",.F.,.T.) //-- Indica se redistribui saldos remanescentes de outros fornecedores
Local lMFSaldo		:= SuperGetMV("MV_MFSLDCP",.F.,.T.) //-- Indica se simula matriz com contratos em aberto quando nao tem SDU
Local lAglutAE		:= SuperGetMV("MV_AGLUTAE",.F.,.F.) //-- Indica se aglutina AE's do mesmo contrato em um unico documento
Local lGeraSA       := SuperGetMV("MV_SOLICSA",.F.,.F.) // -- Indica que o Solicitante da SA sera o mesmo na SC.
Local lBiblioteca	:= FwIsInCallStack("COMGERADOC") 
Local lAchou		:= .F.
Local lAprovCP 		:= SuperGetMV("MV_APROVCP",.F.,.F.)
Local cPcAprov 		:= SuperGetMv("MV_PCAPROV",.F.,"" )
Local lAEAprov		:= SuperGetMV("MV_AEAPROV",.F.,.T.)
Local lAlcadOP		:= SuperGetMv("MV_ALCADOP",.F.,.F.)
Local lTPOPDoc		:= SuperGetMV("MV_TPOPDOC",.F.,.F.)		

Local nC7QtDec 		:= TamSX3("C7_QUANT")[2]
Local nTamC7Item	:= TamSX3("C7_ITEM")[1]
Local nC7TotDec		:= TamSX3("C7_TOTAL")[2]

Default aCampos	  := {}
Default aRateio	  := {}
Default cRotina	  := ""

SY1->(dbSetOrder(3))
SB1->(dbSetOrder(1))
SB5->(dbSetOrder(1))
SA5->(dbSetOrder(1))
SB2->(dbSetOrder(1))
SC3->(dbSetOrder(4))
SC7->(dbSetOrder(1))

//-- Posiciona SY1 para tratamento de alcadas
SY1->(dbSeek(xFilial("SY1")+RetCodUsr()))

//-- Posiciona no SB1 para gravar os campos B1_SEGUM/B1_CONTA/B1_CC/B1_DESC/
SB1->(dbSeek(xFilial("SB1")+cProduto))
SB5->(dbSeek(xFilial("SB5")+cProduto))

dDataNec := If(aScan(aCampos,{|x| x[1] == "DATPRF"}) == 0,dDataNec,aCampos[aScan(aCampos,{|x| x[1] == "DATPRF"}),2])

// -- Localiza usuario que gerou SA caso registro gerado pelo MATA106

If lGeraSA .And. cRotina $ "MATA106" .And. !Empty(SCP->CP_SOLICIT) 
	FWSFLoadUser(SCP->CP_SOLICIT,,,1)
	aUser:= FWSFLoadUser(SCP->CP_SOLICIT,,,1)
	If Len (aUser) > 0 
		cLogin := aUser[2]
	EndIf
EndIf

If Existblock("MTGERAAE")
	aMtGeraAe := ExecBlock("MTGERAAE",.F.,.F.,{cProduto,nNecess})
	//[n,1] := nro contrato
	//[n,2] := item
	//[n,3] := quantidade
	SC3->(dbSetOrder(1))
	For nX:=1 To Len(aMtGeraAe)
		If SC3->(dbSeek(xFilial("SC3")+aMtGeraAe[nX,1]+aMtGeraAe[nX,2])) .And. SC3->C3_PRODUTO == cProduto .And. SC3->C3_ENCER # "E" .And. SC3->C3_RESIDUO # "S" .And. (SC3->C3_QUANT - SC3->C3_QUJE) > 0
			nQtdeGera := Min(aMtGeraAe[nX,3],SC3->C3_QUANT - SC3->C3_QUJE) //-- Quantidade da AE
			If (nPosCtr := aScan(aAEs,{|x| x[1] == aMtGeraAe[nX,1]})) == 0
				aAdd(aAEs, {aMtGeraAe[nX,1], SC3->C3_FORNECE, SC3->C3_LOJA, nQtdeGera} )
			Else
				aAEs[nPosCtr,4] += nQtdeGera
			EndIf
			//-- Atualiza saldo do contrato
			RecLock("SC3",.F.)
			SC3->C3_QUJE += nQtdeGera
			SC3->(MsUnLock())
			nNecess := Max( 0, nQtdeGera - nNecess )
		Else
			Loop
		EndIf
	Next
	SC3->(dbSetOrder(4))
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica a quais impostos devem ser gravados.                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aRefImp := MaFisRelImp('MT100',{"SC7"})

Begin Transaction

If lMatrizF
	//-- Geracao com conceito de matriz por produto
	While cRotina # "MATA173" .And. nNecess > 0
		SDU->(dbSetOrder(1))
		lMatrizF := SDU->(dbSeek(xFilial("SDU")+cProduto))
		
		If !lMatrizF .Or. (nNecess # nNecOrig .And. !lRediSld) //-- Caso configurado para nao redistribuir saldos, sai
			Exit
		EndIf
	
		cQuery := "SELECT SDU.DU_FORNECE, SDU.DU_LOJA, SDU.DU_PERCENT, SC3.C3_NUM, SC3.C3_ITEM, "
		cQuery += "SC3.C3_QUANT, SC3.C3_QUJE "
		cQuery += "FROM " +RetSQLName("SDU") +" SDU "
		cQuery += "INNER JOIN " +RetSQLName("SC3") +" SC3 ON SC3.D_E_L_E_T_ <> '*' AND "
		cQuery += "SC3.C3_FILIAL = '" +xFilial("SC3") +"' AND "
		cQuery += "SC3.C3_PRODUTO = '" +cProduto +"' AND "
		cQuery += "SC3.C3_FORNECE = SDU.DU_FORNECE AND "
		cQuery += "SC3.C3_LOJA = SDU.DU_LOJA AND "
		cQuery += "SC3.C3_ENCER <> 'E' AND "
		cQuery += "SC3.C3_RESIDUO <> 'S' AND "
		cQuery += "SC3.C3_DATPRI <= '" +DToS(dDataBase) +"' AND "
		cQuery += "SC3.C3_DATPRF >= '" +DToS(dDataBase) +"' AND "
		cQuery += "SC3.C3_QUANT - SC3.C3_QUJE > 0 "
		If lAprovCP
			cQuery += "AND SC3.C3_CONAPRO <> 'B' "
		EndIf
		cQuery += "WHERE SDU.D_E_L_E_T_ <> '*' AND "
		cQuery += "SDU.DU_FILIAL = '" +xFilial("SDU") +"' AND "
		cQuery += "SDU.DU_PRODUTO = '" +cProduto +"' AND "
		cQuery += "SDU.DU_DTINI <= '" +DToS(dDataNec) +"' AND "
		cQuery += "SDU.DU_DTFIM >= '" +DToS(dDataNec) +"'"
		cQuery += "ORDER BY SDU.DU_DTINI, SDU.DU_FORNECE, SDU.DU_LOJA, SC3.C3_EMISSAO"
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"TMPSC3",.T.,.F.)
		
		If lRediSld //-- Se MV_MFREDIS ativo, proporcionaliza percentual da matriz conforme fornecedores com saldo no contrato
			nPercTot := 0
			TMPSC3->(dbEval({|| nPercTot += DU_PERCENT}))
			TMPSC3->(dbGoTop())
		Else
			nPercTot := 100
		EndIf
		
		//-- Caso nao haja nenhum contrato com saldo para a matriz
		If TMPSC3->(EOF())
			TMPSC3->(dbCloseArea())
			Exit
		EndIf
	
		//-- Prepara variaveis de controle de processamento
		cChave    := TMPSC3->(DU_FORNECE+DU_LOJA)
		nSaldoFor := Round(((((TMPSC3->DU_PERCENT * 100) / nPercTot) / 100)  * nNecess),nC7QtDec)
		
		Do Case
			Case SB1->B1_TIPODEC == "A"
				nSaldoFor := Round(nSaldoFor,0)
			Case SB1->B1_TIPODEC == "I"
				nSaldoFor := Int(nSaldoFor) +If(((nSaldoFor-Int(nSaldoFor)) > 0),1,0)
			Case SB1->B1_TIPODEC == "T"
				nSaldoFor := Int(nSaldoFor)
		EndCase
		
		//-- Processa contratos disponiveis para a matriz		
		While !TMPSC3->(EOF())	
			 //-- Enquanto houver saldo e contratos
			While !TMPSC3->(EOF())	 .And. nSaldoFor > 0 .And. cChave == TMPSC3->(DU_FORNECE+DU_LOJA)
				nQtdeGera := Min(nSaldoFor,TMPSC3->C3_QUANT - TMPSC3->C3_QUJE) //-- Quantidade da AE
				
				If (nPosCtr := aScan(aAEs,{|x| x[1] == TMPSC3->C3_NUM})) == 0
					TMPSC3->(aAdd(aAEs, {TMPSC3->C3_NUM,TMPSC3->DU_FORNECE,TMPSC3->DU_LOJA,nQtdeGera} ))
				Else
					aAEs[nPosCtr,4] += nQtdeGera
				EndIf

				//-- Atualiza saldo do contrato
				SC3->(dbSeek(xFilial("SC3")+cProduto+TMPSC3->(DU_FORNECE+DU_LOJA+C3_NUM)))
				RecLock("SC3",.F.)
				SC3->C3_QUJE += nQtdeGera
				SC3->(MsUnLock())
				nSaldoFor -= nQtdeGera

				TMPSC3->(dbSkip())
			EndDo
			
			//-- Se zerou o saldo do fornecedor, troca
			While cChave == TMPSC3->(DU_FORNECE+DU_LOJA)
				TMPSC3->(dbSkip())
			End
			
			//-- Prepara dados para o prox. fornecedor
			If !TMPSC3->(EOF())
				cChave    := TMPSC3->(DU_FORNECE+DU_LOJA)
				nSaldoFor := Round(((TMPSC3->DU_PERCENT / 100) * nNecess),nC7QtDec)
				
				Do Case
					Case SB1->B1_TIPODEC == "A"
						nSaldoFor := Round(nSaldoFor,0)
					Case SB1->B1_TIPODEC == "I"
						nSaldoFor := Int(nSaldoFor) +If(((nSaldoFor-Int(nSaldoFor)) > 0),1,0)
					Case SB1->B1_TIPODEC == "T"
						nSaldoFor := Int(nSaldoFor)
				EndCase
			EndIf	
		EndDo
		TMPSC3->(dbCloseArea())
		
		nTotAEs := 0
		aEval(aAEs,{|x| nTotAEs += x[4]})
		nNecess := nNecOrig - nTotAEs
	End
	
	//-- Geracao com conceito de matriz pelos saldos dos contratos: somente quando produto sem matriz valida
	If lMFSaldo .And. cRotina # "MATA173" .And. nNecess == nNecOrig
		cQuery := "SELECT SUM(SC3.C3_QUANT - SC3.C3_QUJE) AS SALDOTOT "
		cQuery += "FROM " +RetSQLName("SC3") +" SC3 WHERE SC3.D_E_L_E_T_ <> '*' AND "
		cQuery += "SC3.C3_FILIAL = '" +xFilial("SC3") +"' AND "
		cQuery += "SC3.C3_PRODUTO = '" +cProduto +"' AND "
		cQuery += "SC3.C3_ENCER <> 'E' AND "
		cQuery += "SC3.C3_RESIDUO <> 'S' AND "
		cQuery += "SC3.C3_DATPRI <= '" +DToS(dDataBase) +"' AND "
		cQuery += "SC3.C3_DATPRF >= '" +DToS(dDataBase) +"' AND "
		cQuery += "(SC3.C3_QUANT - SC3.C3_QUJE) > 0 "
		If lAprovCP
			cQuery += " AND SC3.C3_CONAPRO <> 'B'"
		EndIf
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"TMPSC3",.T.,.F.)
		nPercTot := TMPSC3->SALDOTOT		
		TMPSC3->(dbCloseArea())
		
		cQuery := "SELECT * "
		cQuery += "FROM " +RetSQLName("SC3") +" SC3 WHERE SC3.D_E_L_E_T_ <> '*' AND "
		cQuery += "SC3.C3_FILIAL = '" +xFilial("SC3") +"' AND "
		cQuery += "SC3.C3_PRODUTO = '" +cProduto +"' AND "
		cQuery += "SC3.C3_ENCER <> 'E' AND "
		cQuery += "SC3.C3_RESIDUO <> 'S' AND "
		cQuery += "SC3.C3_DATPRI <= '" +DToS(dDataBase) +"' AND "
		cQuery += "SC3.C3_DATPRF >= '" +DToS(dDataBase) +"' AND "
		cQuery += "SC3.C3_QUANT - SC3.C3_QUJE > 0"
		If lAprovCP
			cQuery += " AND SC3.C3_CONAPRO <> 'B'"
		EndIf
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"TMPSC3",.T.,.F.)
		
		nNecOrig := nNecess
		While !TMPSC3->(EOF())
			nNecess -= (TMPSC3->(C3_QUANT-C3_QUJE) / nPercTot) * Min(nNecOrig,nPercTot)
			TMPSC3->(aAdd(aAEs, {TMPSC3->C3_NUM,TMPSC3->C3_FORNECE,TMPSC3->C3_LOJA,(TMPSC3->(C3_QUANT-C3_QUJE) / nPercTot) * Min(nNecOrig,nPercTot)} ))
			
			//-- Atualiza saldo do contrato
			SC3->(dbSeek(xFilial("SC3")+cProduto+TMPSC3->(C3_FORNECE+C3_LOJA+C3_NUM)))
			RecLock("SC3",.F.)
			SC3->C3_QUJE += (TMPSC3->(C3_QUANT-C3_QUJE) / nPercTot) * Min(nNecOrig,nPercTot)
			SC3->(MsUnLock())
			
			TMPSC3->(dbSkip())
		EndDo
		TMPSC3->(dbCloseArea())
	EndIf
	
	//-- Arredonda para nao gerar SC quebrada
	If nNecess # nNecOrig
		Do Case
			Case SB1->B1_TIPODEC == "A"
				nNecess := Round(nNecess,0)
			Case SB1->B1_TIPODEC == "I"
				nNecess := Int(nNecess) +If(((nNecess-Int(nNecess)) > 0),1,0)
			Case SB1->B1_TIPODEC == "T"
				nNecess := Int(nNecess)
		EndCase
	EndIf
EndIf

//-- Gera sem o conceito de matriz de fornecimento
If !lMatrizF .And. nNecess == nNecOrig .And. MatPesqCtr(.T.,SB1->B1_COD,SB1->B1_PROC,SB1->B1_LOJPROC,@cChave)
	//-- Verifica se possui contrato
	While !SC3->(EOF()) .And. &(cChave)
		//-- Nao considera contratos de parceria encerrados ou fora da data
		If dDataNec < SC3->C3_DATPRI .Or. SC3->C3_DATPRF < dDataNec .Or.;
					 SC3->C3_QUANT <= SC3->C3_QUJE .Or. SC3->C3_ENCER == "E" .Or. SC3->C3_RESIDUO == "S" .Or. SC3->C3_CONAPRO == "B"
			SC3->(dbSkip())
			Loop
		EndIf
		
		//-- Se achou contrato valido, gera AE
		nSaldoGer := Min(nNecess,SC3->(C3_QUANT - C3_QUJE))
		
		aAdd(aAEs, {SC3->C3_NUM,SC3->C3_FORNECE,SC3->C3_LOJA,nSaldoGer} )
				
		//-- Atualiza saldo do contrato
		RecLock("SC3",.F.)
		SC3->C3_QUJE += nSaldoGer
		SC3->(MsUnLock())	
		
		//-- Subtrai saldo que foi gerado
		nNecess -= nSaldoGer		
		
		Exit
	EndDo
EndIf

If Len(aAes) > 1 .And. aScan(aCampos,{|x| x[1] == "NUM"}) > 0
	aDel(aCampos,aScan(aCampos,{|x| x[1] == "NUM"}))
	aSize(aCampos,Len(aCampos)-1)
EndIf

//-- Realiza gravacao das AEs
For nX := 1 To Len(aAEs)
	SC3->(dbSetOrder(4))
	SC3->(dbSeek(xFilial("SC3")+cProduto+aAEs[nX,2]+aAEs[nX,3]+aAEs[nX,1]))
	
	lAchou := .F.
	While SC3->C3_FILENT+SC3->C3_PRODUTO+SC3->C3_FORNECE+SC3->C3_LOJA+SC3->C3_NUM == xFilial("SC3")+cProduto+aAEs[nX,2]+aAEs[nX,3]+aAEs[nX,1]
		If dDataBase < SC3->C3_DATPRI .Or. dDataBase > SC3->C3_DATPRF .Or. SC3->C3_CONAPRO == "B"
			SC3->(dbSkip())
		Else
			lAchou := .T.
			Exit
		EndIf
	End
	
	If !lAchou
		Loop
	EndIf
	
	RecLock("SC7",.T.)
	//-- Inicializa os campos
	For nY := 1 To SC7->(FCount())
		SC7->&(Field(nY)) := CriaVar(SC7->(Field(nY)))
	Next nY
	
	SC7->C7_FILIAL	:= xFilial("SC7")
	SC7->C7_TIPO	:= 2		
	SC7->C7_ITEM    := StrZero(1,nTamC7Item)
	If lGeraSA .And. cRotina $ "MATA106" .And. !Empty(SCP->CP_SOLICIT) 
		SC7->C7_USER     	:= cLogin
	Else
		SC7->C7_USER     	:= RetCodUsr() 
	EndIf
	SC7->C7_FORNECE	:= aAEs[nX,2]
	SC7->C7_LOJA	:= aAes[nX,3]
	SC7->C7_NUMSC	:= SC3->C3_NUM
	SC7->C7_ITEMSC	:= SC3->C3_ITEM
	SC7->C7_COND 	:= SC3->C3_COND
	SC7->C7_CONTATO	:= SC3->C3_CONTATO
	SC7->C7_FILENT	:= SC3->C3_FILENT
	SC7->C7_IPI		:= SC3->C3_IPI
	SC7->C7_REAJUST	:= SC3->C3_REAJUST
	SC7->C7_FRETE  	:= SC3->C3_FRETE
	SC7->C7_MOEDA	:= SC3->C3_MOEDA		
	SC7->C7_TXMOEDA	:= SC3->C3_TXMOEDA
	SC7->C7_MSG	  	:= SC3->C3_MSG
	SC7->C7_TPFRETE	:= SC3->C3_TPFRETE
	SC7->C7_OBS    	:= SC3->C3_OBS
	SC7->C7_PRODUTO	:= SC3->C3_PRODUTO
	SC7->C7_LOCAL  	:= SC3->C3_LOCAL
	SC7->C7_PRECO  	:= SC3->C3_PRECO
	SC7->C7_QUANT  	:= Round(aAEs[nX,4],nC7QtDec)
	SC7->C7_QTDSOL	:= SC7->C7_QUANT
	SC7->C7_TOTAL  	:= Round(SC7->C7_QUANT * SC7->C7_PRECO,nC7TotDec)
	SC7->C7_DESCRI 	:= SB1->B1_DESC
	SC7->C7_UM		:= SB1->B1_UM
	SC7->C7_SEGUM  	:= SB1->B1_SEGUM
	SC7->C7_QTSEGUM	:= ConvUm(SB1->B1_COD,SC7->C7_QUANT,0,2)
	SC7->C7_CONTA  	:= SB1->B1_CONTA
	SC7->C7_ITEMCTA := SB1->B1_ITEMCC
	SC7->C7_CLVL	:= SB1->B1_CLVL
	SC7->C7_CC 		:= SB1->B1_CC	
	SC7->C7_TES		:= SB1->B1_TE	
	For nY := 1 To Len(aCTBEnt)
		SC7->&("C7_EC"+aCTBEnt[nY]+"CR") := SB1->&("B1_EC"+aCTBEnt[nY]+"CR")
		SC7->&("C7_EC"+aCTBEnt[nY]+"DB") := SB1->&("B1_EC"+aCTBEnt[nY]+"DB")
	Next nY
	
	If ExistBlock("MT106APV")
		cNewGrp := ExecBlock("MT106APV",.F.,.F.)
		If ValType(cNewGrp) == "C" .And. !Empty(cNewGrp)
			SC7->C7_GRUPCOM	:= cNewGrp
		Else
			SC7->C7_GRUPCOM	:= SY1->Y1_GRUPCOM
		Endif
	Else
		SC7->C7_GRUPCOM	:= SY1->Y1_GRUPCOM	
	Endif
	
	SC7->C7_APROV   := If(!Empty(SY1->Y1_GRAPROV),SY1->Y1_GRAPROV,cPcAprov)
	
	SC7->C7_REVISAO := Posicione("SB5",1,xFilial("SB5")+cProduto,"B5_VERSAO")
	
	//-- Grava campos especificos da rotina que chamou
	For nY := 1 To Len(aCampos)
		SC7->&("C7_" +aCampos[nY,1]) := aCampos[nY,2]
	Next nY
	
	SA5->(dbSeek(xFilial("SA5")+aAEs[nX,2]+aAEs[nX,3]+cProduto))
	SC7->C7_DINICQ  := SC7->C7_DATPRF - If(Empty(SB5->B5_FPRZCQ),SB5->B5_PRZCQ,Formula(SB5->B5_FPRZCQ))
	SC7->C7_DINITRA := SC7->C7_DINICQ - SA5->A5_TEMPTRA
	SC7->C7_DINICOM := SC7->C7_DINITRA - CalcPrazo(cProduto,SC7->C7_QUANT,aAEs[nX,2],aAEs[nX,3])
	
	//-- Executa avaliação do tipo de Compra
	SC7->C7_TIPCOM := MRetTipCom(,.T.,"PC")
	
	SC7->(MsUnLock())

	// Tratamento para gravacao dos impostos na Autorizacao de Entrega
	MaFisIni(aAEs[nX,2],aAEs[nX,3],"F","N","R",aRefImp)
	MaFisIniLoad(1)
	For nZ := 1 To Len(aRefImp)
		MaFisLoad(aRefImp[nZ][3],FieldGet(FieldPos(aRefImp[nZ][2])),1)
	Next nZ
	MaFisRecal("",1)
	MaFisEndLoad(1)
	MaFisWrite(1,"SC7",1)
	MaFisWrite(2,"SC7",1,.F.)
	MaFisEnd()

	cItemCH:= "01"
	//-- Grava dados dos rateios
	For nY := 1 To Len(aRateio)
	    aEntidades:= StrTokArr ( aRateio[nY,2], "|" )
		cItemCH := Soma1(cItemCH)	
		RecLock("SCH",.T.)
		SCH->CH_FILIAL	:= xFilial("SCH")
		SCH->CH_PEDIDO  := SC7->C7_NUM
		SCH->CH_FORNECE := SC7->C7_FORNECE
		SCH->CH_LOJA 	:= SC7->C7_LOJA
		SCH->CH_ITEMPD 	:= SC7->C7_ITEM
		SCH->CH_ITEM 	:= cItemCH
		SCH->CH_CC 		:= aEntidades[1]
		SCH->CH_CONTA 	:= aEntidades[2]
		SCH->CH_ITEMCTA	:= aEntidades[3]
		SCH->CH_CLVL	:= aEntidades[4]
		SCH->CH_PERC 	:= aRateio[nY,1]
		
		//-- Grava entidades contabeis
		For nZ := 1 To Len(aCTBEnt)
			SCH->&("CH_EC"+aCTBEnt[nZ]+"CR") := aEntidades[nZ+4]
			SCH->&("CH_EC"+aCTBEnt[nZ]+"DB") := aEntidades[nZ+5]
		Next nZ
		SCH->(MsUnlock())
	Next nY
	//-- Gera arquivo de controle de alcadas SCR para a AE se o MV_AEAPROV estiver ativo
	If lAEAprov .And. (cRotina # "MATA650" .Or. lAlcadOP) .And. SC7->C7_TPOP == "F"
		SCR->(DbClearFilter()) //-- Limpa o Filtro do SCR caso ele exista

		lAlcada := MaAlcDoc({SC7->C7_NUM,"AE",SC7->C7_TOTAL,,,SC7->C7_APROV,,SC7->C7_MOEDA,RecMoeda(dDataBase,SC7->C7_MOEDA),dDataBase},,1)

		//-- Efetua a gravacao do campo de controle de aprovacao C7_CONAPRO
		cChave := xFilial("SC7")+SC7->C7_NUM
		SC7->(dbSeek(cChave))
		While !SC7->(EOF()) .And. SC7->(C7_FILIAL+C7_NUM) == cChave
			RecLock("SC7",.F.)
			SC7->C7_CONAPRO := If(lAlcada,"L","B")
			SC7->(MsUnlock())
			SC7->(dbSkip())
		End
		SC7->(dbSkip(-1)) //-- Volta para processar atualizacao de saldo SB2
	EndIf
	
	//-- Se aglutina AE, procura AE do mesmo contrato com condicoes iguais
	//-- (firme/previsto, liberacao de alcada etc) em aberto para incluir item

	If lAglutAE
	
		cAlias := Alias()
		If !Empty(aCampos) .And. (nPosTpOp := aScan(aCampos,{|x| AllTrim(x[1]) == "TPOP"})) > 0
			cFilTpOp := aCampos[nPosTpOp,2]
		EndIf
		
		cQuery := "SELECT MAX(C7_NUM) AS NUMERO FROM " +RetSQLName("SC7") +" WHERE "
		cQuery += "C7_FORNECE = '" +aAEs[nX,2] +"' AND C7_LOJA = '" +aAEs[nX,3] +"' AND "
		cQuery += "C7_NUMSC = '" +SC3->C3_NUM +"' AND C7_QUJE < C7_QUANT AND C7_RESIDUO <> 'S' AND "
		If lTPOPDoc
			cQuery += "CASE C7_TPOP WHEN ' ' THEN 'F' ELSE C7_TPOP END = '" +cFilTpOp +"' AND "
			cQuery += "C7_TPCOLAB <> 'PEF' AND "
		EndIf
		cQuery += "CASE C7_CONAPRO WHEN ' ' THEN 'L' ELSE C7_CONAPRO END = '" +If(lAlcada,"L","B") +"' AND "
		cQuery += "D_E_L_E_T_ <> '*' AND C7_FILIAL = '" +xFilial("SC7") +"' AND C7_TIPO = 2  AND C7_NUM <> '" +SC7->C7_NUM +"'"
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SC7NUM",.T.,.F.)

		If !Empty(SC7NUM->NUMERO)
			cQuery := "SELECT MAX(C7_ITEM) AS ITEM FROM " +RetSQLName("SC7") +" WHERE "
			cQuery += "D_E_L_E_T_ <> '*' AND C7_FILIAL = '" +xFilial("SC7") +"' AND "
			cQuery += "C7_TIPO = 2 AND C7_NUM = '" +SC7NUM->NUMERO +"'"
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SC7ITEM",.T.,.F.)
			
			cNumAglu := SC7NUM->NUMERO
			cItemAgl := Soma1(SC7ITEM->ITEM)
			
			SC7ITEM->(dbCloseArea())
		EndIf
		SC7NUM->(dbCloseArea())
		dbSelectArea(cAlias)
		
		//-- Troca numero para aglutinar no mesmo documento
		If !Empty(cNumAglu)
			//-- Atualiza numero do documento na SC7
			SCR->(dbSetOrder(1))
			While SCR->(dbSeek(xFilial("SCR")+"AE"+SC7->C7_NUM))
				RecLock("SCR",.F.)
				SCR->CR_NUM:= cNumAglu
				SCR->(MsUnLock())
			End
			
			//-- Troca numero do pedido
			RecLock("SC7",.F.)
			SC7->C7_NUM  := cNumAglu
			SC7->C7_ITEM := cItemAgl
			SC7->(MsUnLock())
			
			//-- Volta numeracao sequencial
			RollBackSX8()
		EndIf
	EndIf
	
	//-- Tratamento especifico do TOTVS Colaboracao (o envio esta dentro da MaAlcDoc)
	//-- Se nao passou pela MaAlcDoc, forca envio
	If !(lAEAprov .And. (cRotina # "MATA650" .Or. lAlcadOP)) .And.;
		(lTPOPDoc) .And. FWLSEnable(TOTVS_COLAB_ONDEMAND) .And.;	
		SC7->C7_TPCOLAB <> "PEF" .And. SC7->C7_TPOP == "F"
		If Empty(SC7->C7_TPCOLAB)
			ExpXML_PC(SC7->C7_NUM)
		Else
			ExpXML_PE(SC7->C7_NUM)
		EndIf
	EndIf
		
	//-- Pontos de entrada 
	If cRotina == "MATA650" .And. ExistBlock("MT650C7")
		ExecBlock("MT650C7",.F.,.F.)
	ElseIf (cRotina == "MATA710" .Or. cRotina == "MATA712" .Or. cRotina == "PCPA107") .And. ExistBlock("M711SC7")
		MatM711SC7()
	EndIf

	//-- Atualizacao do saldo SB2
	If SB2->(dbSeek(xFilial("SB2")+SC7->(C7_PRODUTO+C7_LOCAL)))
		SB2->(GravaB2Pre("+",SC7->(C7_QUANT-C7_QUJE),SC7->C7_TPOP,(SC7->(C7_QUANT-C7_QUJE))*SC7->(C7_QTSEGUM/C7_QUANT)))
	EndIf

	// Verifica se a função foi chamada pelo MRP para atualização do objeto TREE
	If cRotina == "MATA710"
		A711CriSH5(SC7->C7_DATPRF,SC7->C7_PRODUTO,Space(80),Space(3),"SC7",SC7->(Recno()),SC7->C7_NUM,SC7->C7_ITEM,SC7->C7_OP,SC7->C7_QUANT,"2",.T.,,,.T.,,,,,,,)
	ElseIf cRotina == "MATA712"
		A712CriCZI(SC7->C7_DATPRF,SC7->C7_PRODUTO,Space(80),Space(3),"SC7",SC7->(Recno()),SC7->C7_NUM,SC7->C7_ITEM,SC7->C7_OP,SC7->C7_QUANT,"2",.T.,/*13*/,/*14*/,.F.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
	ElseIf cRotina == "PCPA107"
		A107CriSOQ(SC7->C7_DATPRF,SC7->C7_PRODUTO,Space(80),Space(3),"SC7",SC7->(Recno()),SC7->C7_NUM,SC7->C7_ITEM,SC7->C7_OP,SC7->C7_QUANT,"2",.T.,/*13*/,/*14*/,.F.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
	EndIf
		
	cNumAglu := ""
	cItemAgl := ""
	
	//---------------------
	// Atualiza retorno
	// [1]- Quant
	// [2]- Documento
	//---------------------
	aAdd(aRet,{SC7->C7_QUANT,SC7->C7_NUM})
Next nX

//-- Se nao atendeu tudo atraves de contrato, gera SC
If (SB1->B1_CONTRAT == "A" .Or. lCPGerSC) .And. nNecess > 0 .And. !lBiblioteca
	//-- MATA650 tem tratamento para aglutinar SC (tratado no else)
	//-- Por isso se MATA650 com aglutinacao ou MATA710 pelo MAT650 com aglutinacao
	If (cRotina == "MATA650" .And. aSav650[06] # 1) .Or.;
	  ((cRotina == "MATA710" .Or. cRotina == "MATA712" .Or. cRotina == "PCPA107") .And. Type("aSav650") == "A" .And. aSav650[06] == 2)
		If aSav650[06] == 2 // Aglutina por OP
			nX := aScan(aOpC1,{|x| x[1] == cProduto .And. x[3] == aCampos[aScan(aCampos,{|x| x[1] == "OP"}),2] .And.;
						 x[8] == .T. .And. x[9] == .F. .And. x[11] == aCampos[aScan(aCampos,{|x| x[1] == "TPOP"}),2]})

			If nX == 0
				aAdd(aOpC1,{cProduto,nNecess,aCampos[aScan(aCampos,{|x| x[1] == "OP"}),2],aCampos[aScan(aCampos,{|x| x[1] == "DATPRF"}),2],,2,nNecess,.T.,.F.,SB1->B1_LOCPAD,aCampos[aScan(aCampos,{|x| x[1] == "TPOP"}),2],.T.,{}})
				aAdd(aOpC1[Len(aOpC1)][13],)								
			Else
				If aOpC1[nX,2] < aOpC1[nX,7] + nNecess
					aOpC1[nX,2] += nNecess
				EndIf
				aOpC1[nX,7] += nNecess
				aAdd(aOpC1[nX,13],{cPV,cItemPV})													
			EndIf
		Else // Aglutina por Data de Necessidade
			nX := aScan(aDataOpC1,{|x| x[1] == cProduto .And. x[4] == aCampos[aScan(aCampos,{|x| x[1] == "DATPRF"}),2] .And.;
						 x[8] == .T. .And. x[9] == .F. .And. x[11] == aCampos[aScan(aCampos,{|x| x[1] == "TPOP"}),2]})

			If nX == 0
				aAdd(aDataOpC1,{cProduto,nNecess,aCampos[aScan(aCampos,{|x| x[1] == "OP"}),2],aCampos[aScan(aCampos,{|x| x[1] == "DATPRF"}),2],,2,nNecess,.T.,.F.,SB1->B1_LOCPAD,aCampos[aScan(aCampos,{|x| x[1] == "TPOP"}),2],.T.,{}})
				aAdd(aDataOpC1[Len(aDataOpC1)][13], {cPV,cItemPV})								
			Else
				If aDataOpC1[nX,2] < aDataOpC1[nX,7] + nNecess
					aDataOpC1[nX,2] += nNecess
				EndIf
				aDataOpC1[nX,7] += nNecess
				If aDataOpC1[nX,3] # aCampos[aScan(aCampos,{|x| x[1] == "OP"}),2]
					aDataOpC1[nX,3] := CriaVar("C1_OP")
				EndIf
				aAdd(aDataOpC1[nX,13],{cPV,cItemPV})								
			EndIf
		EndIf	
	Else
		RecLock("SC1",.T.)
	
		//-- Inicializa os campos
		For nY := 1 To SC1->(FCount())
			SC1->&(Field(nY)) := CriaVar(SC1->(Field(nY)))
		Next nY
		
		SC1->C1_FILIAL	:= xFilial("SC1")
		SC1->C1_PRODUTO	:= cProduto
		SC1->C1_ITEM	:= StrZero(1,TamSX3("C1_ITEM")[1])
		SC1->C1_QUANT	:= nNecess
		SC1->C1_UM		:= SB1->B1_UM
		SC1->C1_LOCAL	:= SB1->B1_LOCPAD
		SC1->C1_DESCRI	:= SB1->B1_DESC
		SC1->C1_SEGUM	:= SB1->B1_SEGUM
		SC1->C1_QTSEGUM	:= ConvUm(cProduto,SC1->C1_QUANT,0,2)
		SC1->C1_IMPORT  := SB1->B1_IMPORT
		SC1->C1_COTACAO	:= If(SB1->B1_IMPORT=="S","IMPORT","")
		If lGeraSA .And. cRotina $ "MATA106" .And. !Empty(SCP->CP_SOLICIT) 
			SC1->C1_GRUPCOM	:= MaRetComSC(SB1->B1_COD,UsrRetGrp(SCP->CP_SOLICIT),cLogin)
		Else 
			SC1->C1_GRUPCOM	:= MaRetComSC(SB1->B1_COD,UsrRetGrp(),RetCodUsr())
		EndIf
		If lGeraSA .And. cRotina $ "MATA106" .And. !Empty(SCP->CP_SOLICIT) 
			SC1->C1_USER	:= cLogin
		Else
			SC1->C1_USER	:= RetCodUsr()
		EndIf
		SC1->C1_GRUPCOM	:= MaRetComSC(SB1->B1_COD,UsrRetGrp(),RetCodUsr())
		SC1->C1_FORNECE	:= SB1->B1_PROC
		SC1->C1_LOJA	:= SB1->B1_LOJPROC
		If lGeraSA .And. cRotina $ "MATA106"
			SC1->C1_SOLICIT:= SCP->CP_SOLICIT
		Else 
			SC1->C1_SOLICIT	:= UsrRetName(RetCodUsr())
		EndIf 
		SC1->C1_CC		:= SB1->B1_CC
		SC1->C1_CONTA	:= SB1->B1_CONTA
		SC1->C1_ITEMCTA	:= SB1->B1_ITEMCC
		SC1->C1_CLVL	:= SB1->B1_CLVL
		For nY := 1 To Len(aCTBEnt)
			SC1->&("C1_EC"+aCTBEnt[nY]+"CR") := SB1->&("B1_EC"+aCTBEnt[nY]+"CR")
			SC1->&("C1_EC"+aCTBEnt[nY]+"DB") := SB1->&("B1_EC"+aCTBEnt[nY]+"DB")
		Next nY
		SC1->C1_QTDORIG	:= SC1->C1_QUANT
		SC1->C1_FILENT	:= xFilEnt(If(Empty(SC1->C1_FILENT),SC1->C1_FILIAL,SC1->C1_FILENT))
		SC1->C1_OBS		:= STR0104 //-- Produto sem contrato válido
		SC1->C1_REVISAO := Posicione("SB5",1,xFilial("SB5")+cProduto,"B5_VERSAO")
			
		//-- Grava campos especificos da rotina que chamou
		For nY := 1 To Len(aCampos)
			If aCampos[nY,1] # "NUM"
				SC1->&("C1_" +aCampos[nY,1]) := aCampos[nY,2]
			EndIf
		Next nY
		
		//-- Executa avaliação do tipo de Compra
		SC1->C1_TIPCOM := MRetTipCom(,.T.,"SC")
		
		SC1->(MsUnlock())
	
		MaAvalSC("SC1",1)
		
		// Verifica se a função foi chamada pelo MRP para atualização do objeto TREE
		If cRotina == "MATA710"
			A711CriSH5(SC1->C1_DATPRF,SC1->C1_PRODUTO,Space(80),Space(3),"SC1",SC1->(Recno()),SC1->C1_NUM,SC1->C1_ITEM,SC1->C1_OP,SC1->C1_QUANT,"2",.T.,,,.T.,,,,,,,)
		ElseIf cRotina == "MATA712"
			A712CriCZI(SC1->C1_DATPRF,SC1->C1_PRODUTO,Space(80),Space(3),"SC1",SC1->(Recno()),SC1->C1_NUM,SC1->C1_ITEM,SC1->C1_OP,SC1->C1_QUANT,"2",.T.,/*13*/,/*14*/,.F.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
		ElseIf cRotina == "PCPA107"
			A107CriSOQ(SC1->C1_DATPRF,SC1->C1_PRODUTO,Space(80),Space(3),"SC1",SC1->(Recno()),SC1->C1_NUM,SC1->C1_ITEM,SC1->C1_OP,SC1->C1_QUANT,"2",.T.,/*13*/,/*14*/,.F.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
		EndIf
			
	EndIf
EndIf 

End Transaction

Return aRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MAAtuField   ³ Autor ³ Andrews Egas      	³ Data ³ 07/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica a ordem na SX3 dos campos passados como parametro     ³±±
±±³			 ³ e retorna .T. se o campo secundario (que pode ser              ³±±
±±³			 ³ automaticamente preenchido de acordo com o primario) devera    ³±±
±±³			 ³ ser automaticamente preenchido . 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCamPri: Campo primario.     								  ³±±
±±³          ³ cCamSec: Campo secundario (pode ser automaticamente preenchido ³±±
±±³          ³ 	 de acordo com o primario)									  ³±±
±±³          ³ cContSec: Conteudo do campo secundario.						  ³±±
±±³          ³ cTab: Tabela corrente de acordo com os campos Param1 e Param2. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MAAtuField(cCamPri,cCamSec, cContSec, cTab)
Local aArea	:= {}
Local nOrdPri	:= 0 //Armazena a ordem do campo Primario
Local nOrdSec	:= 0 //Armazena a ordem do campo Secundario  
Local lRet 		:= .F.
aArea := GetArea()
dbSelectArea("SX3")
dbSetOrder(1)
MsSeek(cTab)
While !Eof()
	do Case
		Case (Trim(SX3->X3_CAMPO) == cCamPri) 
			nOrdPri :=	VAL(Trim(SX3->X3_ORDEM))				
		Case (Trim(SX3->X3_CAMPO) == cCamSec)
			nOrdSec := VAL(Trim(SX3->X3_ORDEM)) 	
	EndCase
	
	If(nOrdPri > 0 .And. nOrdSec > 0)
		Exit
	Endif
	
	dbSelectArea("SX3")
	dbSkip()
EndDo
RestArea(aArea)   

If nOrdSec < nOrdPri
	if Trim(cContSec) == "" .And. GetMv("MV_ATUBRA",,.F.)
		lRet :=.T.
	Endif
Else
	lRet := .T.
Endif	

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MatM711SC7ºAutor  ³ Andre Anjos        º Data ³  27/11/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao de compatibilizacao do ponto de entrada M711SC7     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ COMXFUN                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MatM711SC7()
Local aRetPE	 := {}
Local aCampos 	 := {}
Local lValid     := .T.
Local nX	  	 := 0
Local nRecnoC7	 := SC7->(Recno())
Local aCamposMRP := {	"C7_PRODUTO","C7_QUANT","C7_QTDSOL","C7_UM","C7_QTSEGUM","C7_PRECO","C7_TOTAL","C7_NUMSC",;
						"C7_ITEMSC","C7_IPI","C7_REAJUST","C7_FRETE","C7_DATPRF","C7_LOCAL","C7_MSG","C7_TPFRETE",;
						"C7_OBS","C7_CONTA","C7_CC","C7_DESCRI","C7_SEQMRP","C7_TPOP","C7_DINICOM","C7_DINITRA",;
						"C7_DINICQ","C7_REVISAO"	}

For nX := 1 To SC7->(FCount())
	If aScan(aCamposMRP,{|x| SC7->(FieldName(nX))}) > 0
		aAdd(aCampos,{SC7->(FieldName(nX)),SC7->(FieldGet(nX)),NIL})
	EndIf
Next nX

aCampos := ExecBlock("M711SC7",.F.,.F.,aClone(aCampos))

If ValType(aRetPE) == "A"
	aEval(aCampos,{|x| lValid := lValid .And. CheckSX3(x[1],x[2])})
	If lValid
		SC7->(msGoTo(nRecnoC7))
		RecLock("SC7",.F.)
		For nX := 1 To Len(aCampos)
			SC7->(FieldPut(nX,aCampos[nX,2]))
		Next nX
		SC7->(MsUnLock())
	EndIf
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MAComCent ºAutor  ³Andre Anjos		 º Data ³  07/01/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao para realizacao da transferencia de solicitacoes de º±±
±±º     	 ³ compra entre filiais para processo de compra compartilhada.º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA110, MATA130 e GCPA002                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MAComCent()
Local aAreaSM0	:= SM0->(GetArea())
Local aAreaSC1	:= SC1->(GetArea())
Local lRet		:= .T.
Local oDlg 	 	:= NIL
Local oCombo 	:= NIL
Local oBrowse	:= NIL
Local oFWFilter := NIL
Local oOk		:= LoadBitmap(GetResources(),"LBOK")
Local oNo		:= LoadBitmap(GetResources(),"LBNO")
Local cCombo 	:= ""
Local cFiltro	:= ""
Local cProg		:= AllTrim(FunName())
Local cFiltSC1  := SC1->(dbFilter())
Local aFilCent 	:= {}
Local aDados    := {}
Local aColunas  := {}
Local aColAdic 	:= {} //Colunas adicionais passadas atraves do ponto de entrada MT110COMC
Local nX			:= 0
Local nY			:= 0

//Ponto de entrada utilizado para adicionar colunas a tela de compras centralizadas
If ExistBlock("MT110COMC")
	aColAdic := ExecBlock("MT110COMC",.f.,.f.)
Endif

SM0->(dbSetOrder(1))
SM0->(dbSeek(cEmpAnt))
While SM0->(!EOF()) .And. SM0->M0_CODIGO == cEmpAnt
	If cProg # "MATA110" .And. FWCodFil() == cFilAnt
		aAdd(aFilCent,FWCodFil() +" - " +AllTrim(SM0->M0_FILIAL))
		Exit
	ElseIf cProg == "MATA110" .And. PadR(FWCodFil(),Len(AllTrim(SC1->C1_FILIAL))) <> AllTrim(SC1->C1_FILIAL)
		aAdd(aFilCent,FWCodFil() +" - " +AllTrim(SM0->M0_FILIAL))
	EndIf
	SM0->(dbSkip())
End
SM0->(RestArea(aAreaSM0))

//-- Adiciona itens que se pode transferir
If cProg == "MATA110"
	cFiltro := SC1->(C1_FILIAL+C1_NUM)
	SC1->(dbSetOrder(1))
	SC1->(dbSeek(cFiltro))
	nX := 1
	While !SC1->(EOF()) .And. SC1->(C1_FILIAL+C1_NUM) == cFiltro
		If MaCanCenSC("SC1",.T.)
			SC1->(aAdd(aDados,{.F.,C1_FILIAL,C1_NUM,C1_SOLICIT,C1_EMISSAO,C1_ITEM,C1_PRODUTO,Transform(C1_QUANT,PesqPict("SC1","C1_QUANT")),C1_DATPRF}))
			If !Empty(aColAdic) //Colunas adicionais passadas atraves do PE MT110COMC
				For nY := 1 To Len(aColAdic)
					SC1->(aAdd(aDados[nX], &(aColAdic[nY])))
				Next nY
				nX++
			EndIf
		EndIf
		SC1->(dbSkip())
	End
	aSort(aDados,,,{|x,y| x[2]+x[3]+x[6]+x[7] < y[2]+y[3]+y[6]+y[7]})
Else
	//-- Limpa o filtro do Browse para transferencia de filiais
	SC1->(dbClearFilter())

	//-- Campos que irao para o filtro
	SX3->(dbSetOrder(1))
	SX3->(dbSeek("SC1"))
	While !SX3->(EOF()) .And. SX3->X3_ARQUIVO == "SC1"
		If (X3Uso(SX3->X3_USADO) .And. cNivel >= SX3->X3_NIVEL) .Or. AllTrim(SX3->X3_CAMPO) == "C1_FILIAL"
			aAdd(aColunas,{ AllTrim(SX3->X3_CAMPO),AllTrim(X3Titulo()),SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL,;
							SX3->X3_PICTURE,Str2Arr(SX3->X3_CBOX,";"),SX3->X3_F3})
		EndIf                                
		SX3->(dbSkip())
	End
	
	oFWFilter := FWFilter():New(GetWndDefault())
	oFWFilter:SetSQLFilter()
	oFWFilter:DisableValid()
	oFWFilter:SetField(aColunas)
	oFWFilter:SetProfileID("MAComCent")
	oFWFilter:LoadFilter()
	oFWFilter:SaveFilter()
	If (lRet := oFWFilter:FilterBar())		
		cFiltro := "%AND "
		cFiltro += AllTrim(oFWFilter:GetExprSQL())
		If !(cFiltro == "%AND ")
			cFiltro += " AND "
		EndIf

		//Na análise de mercado traz tanto as SCs normais quanto de Licitaçãi - C1_TPSC 
		If cProg != "GCPA100" 
			cFiltro += "CASE C1_TPSC WHEN ' ' THEN '1' ELSE C1_TPSC END = '" +If(cProg == "GCPA002" .Or. cProg == "GCPA200" ,"2","1") +"'"
		EndIf
		cFiltro += "%" 

		If cFiltro == "%AND %"
			cFiltro := "%%"
		EndIf	

	  	BeginSQL Alias "TMP"		
			SELECT SC1.*
			FROM %Table:SC1% SC1
			JOIN %Table:SB1% SB1 ON
				SB1.%NotDel% AND
				SB1.B1_FILIAL = %xFilial:SB1% AND
				SB1.B1_COD = SC1.C1_PRODUTO					
			WHERE SC1.C1_FILIAL <> %xFilial:SC1% AND 
				SC1.%NotDel% AND SC1.C1_QUJE < SC1.C1_QUANT AND
				SC1.C1_TPOP <> 'P' AND SC1.C1_APROV IN (' ','L') AND SC1.C1_RESIDUO = ' ' AND 
				SC1.C1_COTACAO = ' ' AND SC1.C1_ORIGEM <> 'TRM' AND SC1.C1_IMPORT <> 'S' AND
				SC1.C1_SCORI = ' '
				%Exp:cFiltro%
			ORDER BY SC1.C1_FILIAL, SC1.C1_NUM, SC1.C1_ITEM, SC1.C1_PRODUTO
		EndSQL
				    
		nX := 1		    
		While TMP->(!EOF())	
			TMP->(aAdd(aDados,{.F.,C1_FILIAL,C1_NUM,C1_SOLICIT,SToD(C1_EMISSAO),C1_ITEM,C1_PRODUTO,Transform(C1_QUANT,PesqPict("SC1","C1_QUANT")),SToD(C1_DATPRF)}))
			If !Empty(aColAdic) //Colunas adicionais passadas atraves do PE MT110COMC
				For nY := 1 To Len(aColAdic)
					TMP->(aAdd(aDados[nX], &(aColAdic[nY])))
				Next nY
				nX++
			EndIf
			TMP->(dbSkip())
		End
		TMP->(dbCloseArea())
		dbSelectArea("SC1")
	EndIf
EndIf

If lRet
	If !Empty(aDados) .And. !Empty(aFilCent)
		lRet := .F.
		DEFINE MSDIALOG oDlg FROM 0,0 TO 540,720 TITLE STR0107 PIXEL	//-- Compra Centralizada
		TSay():Create(oDlg,{|| STR0108},05,05,,,,,,.T.) //-- Empresa centralizadora:
		cCombo := aFilCent[1]
		oCombo := TComboBox():Create(oDlg,{|u|if(PCount()>0,cCombo:=u,cCombo)},15,05,aFilCent,350,20,,{||},,,,.T.,,,,{|| cProg == "MATA110"},,,,,'cCombo')
		
		aColunas := {"",RetTitle("C1_FILIAL"),RetTitle("C1_NUM"),RetTitle("C1_SOLICIT"),RetTitle("C1_EMISSAO"),RetTitle("C1_ITEM"),;
		 				RetTitle("C1_PRODUTO"),RetTitle("C1_QUANT"),RetTitle("C1_DATPRF")} 
		 								
		If !Empty(aColAdic) //Colunas adicionais passadas atraves do PE MT110COMC
		 	For nY := 1 To Len(aColAdic)
				aAdd(aColunas, RetTitle(aColAdic[nY]))
			Next nY
		EndIf
		
		TSay():Create(oDlg,{|| STR0109},30,05,,,,,,.T.) //-- Selecione os itens que serão comprados pela empresa centralizadora:
		oBrowse := TWBrowse():New(40,05,350,200,,aColunas,,oDlg,,,,,{|| ComCentMar(@oBrowse,cCombo,cProg=="MATA110",.F.)},,,,,,,,,.T.)
		oBrowse:SetArray(aDados)
		oBrowse:bLine := {|| ACCLine(oBrowse:nAt, aDados)}
		oBrowse:bHeaderClick := {|x,y| If(y == 1,ComCentMar(@oBrowse,cCombo,cProg=="MATA110",.T.),Nil)}	
		
		TButton():Create(oDlg,250,250,STR0087,{|| If(MsgYesNo(STR0111 +cCombo +STR0112),(lRet := .T., oDlg:End()),NIL)},50,10,,,,.T.)	//-- Confirmar // //-- Após esta ação, os itens selecionados serão transferidos para a empresa ##. Confirma esta operação?
		TButton():Create(oDlg,250,300,STR0110,{|| oDlg:End()},50,10,,,,.T.)	//-- Cancelar
		ACTIVATE MSDIALOG oDlg CENTERED
		
		//-- Processa transferecia das solicitacoes e elima scs origem
		If lRet
			Processa({|| MAPComCent(PadR(cCombo,FWSizeFilial()),aDados)})
		EndIf
	Else
		Help(" ",1,"RECNO")
	EndIf
EndIf

dbSelectArea("SC1")
Set Filter To &(cFiltSC1)

RestArea(aAreaSC1)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ ACCLine  ºAutor  ³ Jose Delmondes  	º Data ³  02/09/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Atualizacao do bLine da funcao MaConCent                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ACCLine(nAt, aDados)
Local oOk		:= LoadBitmap(GetResources(),"LBOK")
Local oNo		:= LoadBitmap(GetResources(),"LBNO")
Local aLine	:= {}
Local nX		:= 0

aLine := {If(aDados[nAt,1],oOk,oNo)}
		   			
For nX := 2 To Len(aDados[nAt])
	aAdd(aLine, aDados[nAt,nX])
Next nX

Return aLine
  

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MAPComCentºAutor  ³ Andre Anjos 		 º Data ³  07/01/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao de processamento da transferencia para compra cent. º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cFilCen: codigo da empresa centralizadora.				  º±±
±±º			 ³ aDados: array com os itens de SC selecionados para transf. º±±
±±ºÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº±±
±±ºUso       ³ MATA110                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MAPComCent(cFilCen,aDados,aSCComCe)
Local cFilBkp	:= cFilAnt
Local cFiltro	:= ""
Local cQuebra   := ""
Local cNumSC	:= ""
Local cNewGrp	:= ""
Local nX		:= 0
Local nPos		:= 0
Local nStack    := GetSX8Len()
Local aCamposMR := {}
Local aAreaSM0	:= SM0->(GetArea())
Local lPrjCni 	:= ValidaCNI()
Local lMaSCCent	:= ExistBlock("MASCCENT")
Local nTamC1Item	:= TamSX3("C1_ITEM")[1]
Local aRateio    := {}
DEFAULT aSCComCe   := {} //Contém solicitações geradas pelo compra centralizada

//-- Processa somente se marcou algo
If aScan(aDados,{|x| x[1]}) > 0
	cFiltro := "%"
	For nX := 1 To Len(aDados)
		If aDados[nX,1]
			cFiltro += "'" +aDados[nX,2]+aDados[nX,3]+aDados[nX,6]+aDados[nX,7] +"',"
		EndIf
	Next nX
	cFiltro := PadR(cFiltro,Len(cFiltro)-1) +"%"

	BeginSQL Alias "SC1TMP"
		SELECT *
		FROM %Table:SC1%
		WHERE %NotDel% AND
			C1_FILIAL||C1_NUM||C1_ITEM||C1_PRODUTO IN (%Exp:cFiltro%)
		ORDER BY C1_FILENT, C1_USER, C1_NUM, C1_ITEM, C1_PRODUTO
	EndSQL
	
	//-- Conta registros para ProcRegua
	nX := 0
	SC1TMP->(dbEval({|| nX++}))
	ProcRegua(nX)
	
	SX3->(dbSetOrder(2))
	For nX := 1 To SC1->(FCount())
		SX3->(dbSeek(SC1->(FieldName(nX))))
		If SX3->X3_TIPO == "M" .And. SX3->X3_CONTEXT == "R"
			aAdd(aCamposMR,{SC1->(FieldName(nX)),NIL})
		EndIf
		TCSetField("SC1TMP",SC1->(FieldName(nX)),ValType(SC1->&(FieldName(nX))),TamSX3(SC1->(FieldName(nX)))[1],TamSX3(SC1->(FieldName(nX)))[2])
    Next nX

	Begin Transaction
	
	SC1TMP->(dbGoTop())
	While !SC1TMP->(EOF())
		cQuebra := SC1TMP->(C1_FILENT+C1_USER)
		cNumSC  := ""
		cNewGrp := ""
		cItem	:= StrZero(1,nTamC1Item)

		While !SC1TMP->(EOF()) .And. cQuebra == SC1TMP->(C1_FILENT+C1_USER)
			IncProc()			
			SC1->(msGoTo(SC1TMP->R_E_C_N_O_))
			
			//-- Guarda conteudo de campos memos reais, pois nao vem na query
			aEval(@aCamposMR,{|x| x[2] := SC1->&(x[1])})

			 //-- Verifica novamente para evitar que a SC tenha sido manipulada
			 //-- enquanto a tela estava aberta
			If MaCanCenSC("SC1",.F.)
				//-- Elimina residuo da SC origem
				MaAvalSC("SC1",2)
				RecLock("SC1",.F.)
				SC1->C1_QTDORIG := C1_QUANT
				SC1->C1_QUANT   := C1_QUJE
				SC1->C1_RESIDUO := "S"
				SC1->C1_COMPRAC := "1"
				SC1->(MsUnlock())
	            LancaPCO("SC7",'000056','01','MATA235')
	            
	            //-- Gera nova SC na empresa centralizadora
	            SM0->(dbSetOrder(1))
	            SM0->(dbSeek(cEmpAnt+AllTrim(cFilCen)))
	            cFilAnt := FWCodFil()
	            
	            If Empty(cNumSC)
	            	cNumSC  := CriaVar("C1_NUM",.T.)
				EndIf
	            //-- Verifica se o usuario solicitante tem grupo de compras responsavel na empresa destino
				If Empty(cNewGrp := MaRetComSC(SC1->C1_PRODUTO,UsrRetGrp(SC1->C1_USER),SC1->C1_USER))
					//-- Caso nao tenha, ve se o usuario que esta transferindo eh comprador tem algum grupo de compras
					aGrupos := UsrGrComp(RetCodUsr())
					If !Empty(aGrupos)
						cNewGrp := aGrupos[1]
					EndIf
				EndIf
	            RecLock("SC1",.T.)
	            For nX := 1 To SC1->(FCount())
	            	If Empty((nPos := aScan(aCamposMR,{|x| x[1] == SC1->(FieldName(nX))})))
	            		SC1->&(FieldName(nX)) := SC1TMP->&(SC1->(FieldName(nX)))
	            	Else
	            		SC1->&(FieldName(nX)) := aCamposMR[nPos,2]
	            	EndIf
	            Next nX
	            SC1->C1_FILIAL	:= xFilial("SC1",cFilCen)
	            SC1->C1_NUM		:= cNumSC
	            SC1->C1_ITEM	:= cItem
	            SC1->C1_FISCORI	:= SC1TMP->C1_FILIAL
	            SC1->C1_SCORI	:= SC1TMP->C1_NUM
	            SC1->C1_ITSCORI	:= SC1TMP->C1_ITEM
	            SC1->C1_GRUPCOM	:= cNewGrp
	            //-- Executa avaliação do tipo de Compra
				 SC1->C1_TIPCOM := MRetTipCom(,.T.,"SC")
	            SC1->(MsUnLock())
	            MaAvalSC("SC1",1)

				//Copia Rateio para Filial Centralizadora         
				SCX->(DbSetOrder(1))
				If SCX->(MsSeek(SC1TMP->(C1_FILENT+C1_NUM+C1_ITEM))) //Existe Rateio
					//COPIA OS DADOS ORIGINAIS
					While !SCX->(EOF()) .AND. SCX->(CX_FILIAL+CX_SOLICIT+CX_ITEMSOL) == SC1TMP->(C1_FILENT+C1_NUM+C1_ITEM)
						aAdd(aRateio,{SCX->CX_ITEM,SCX->CX_PERC,SCX->CX_CC,SCX->CX_CONTA,SCX->CX_ITEMCTA,SCX->CX_CLVL})
						SCX->(DbSkip())
					EndDo						
					
					//GGRAVA NA NOVA FILIAL
					If !Empty(aRateio)
						For nX := 1 To Len(aRateio)
							RecLock("SCX",.T.)	
							SCX->CX_FILIAL 	:= xFilial("SC1",cFilCen)
							SCX->CX_SOLICIT 	:= cNumSC
							SCX->CX_ITEMSOL 	:= cItem
							SCX->CX_ITEM    	:= aRateio[nX][1]
							SCX->CX_PERC		:= aRateio[nX][2]
							SCX->CX_CC			:= aRateio[nX][3]
							SCX->CX_CONTA		:= aRateio[nX][4]
							SCX->CX_ITEMCTA	:= aRateio[nX][5]
							SCX->CX_CLVL		:= aRateio[nX][6]
							SCX->(MsUnLock())
						Next nX
					Endif
				EndIf            
	           aAdd( aSCComCe , { cNumSC , cItem , SC1->C1_FISCORI , SC1->C1_SCORI , SC1->C1_ITSCORI } )
	           cItem := Soma1(cItem)

       			//-- Confirma os inicializadores padroes com GetSxeNum
				While GetSX8Len() > nStack 
					RollBackSX8()
				EndDo
				
				//Rodrigo Guerato - FSW - Inclusão dos logs de SC
				If lPrjCni
					//-- Log de Inclusão na Filia de Destino
					COMA080(SC1->C1_NUM,SC1->C1_ITEM,"COI",{},"COI_DTHSOL","COI_USOL",/*lEstorno*/,/*cUser*/,"COI_DOCSC",SC1->C1_NUM)

					SM0->(dbSeek(cEmpAnt+AllTrim(SC1TMP->C1_FILIAL)))
					cFilAnt := FWCodFil()
				
					//-- Log de transferencia na filial de Origem
					COMA080(SC1TMP->C1_NUM,SC1TMP->C1_ITEM,"COI",{},"COI_DTHTRA","COI_UTRA",/*lEstorno*/,/*cUser*/,"COI_DOCTRA",cNumSC,SC1->C1_ITEM,cFilCen)
				EndIf

				SM0->(RestArea(aAreaSM0))
				cFilAnt := cFilBkp
			EndIf
			SC1TMP->(dbSkip())
		End

		// Ponto de entrada para visualizar a SC gerada
		If lMaSCCent
			ExecBlock("MASCCENT",.F.,.F.,{xFilial("SC1",cFilCen),cNumSC})
		EndIf 

	End
	
	End Transaction	
	
	SC1TMP->(dbCloseArea())
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ LancaPCO ºAutor  ³ Andre Anjos		 º Data ³  07/01/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Encapsulamento da PCODetLan para tratar o novo parametro   º±±
±±º          ³ MV_CFILPCO.                                                º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LancaPCO(cAlias,cProcesso,cItem,cPrograma,lDeleta)
Local aArea		:= GetArea()
Local aAreaSM0  := SM0->(GetArea())
Local lPCOFilen := SuperGetMV("MV_CFILPCO",.F.,.F.)
Local cFilBkp	:= cFilAnt
Local cFilEnt	:= AllTrim((cAlias)->&(Substr(cAlias,2,2)+"_FILENT"))

Default lDeleta := .F.

If lPCOFilen
	SM0->(dbSetOrder(1))
	SM0->(dbSeek(cEmpAnt+cFilEnt))
	cFilAnt := FWCodFil()
EndIf

PcoDetLan(cProcesso,cItem,cPrograma,lDeleta)

SM0->(RestArea(aAreaSM0))
cFilAnt := cFilBkp
RestArea(aArea)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ LancaCTB ºAutor  ³ Andre Anjos		 º Data ³  07/01/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Encapsulamento da DetProva pra tratar novo conceito de     º±±
±±º          ³ compra centralizada.                                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LancaCTB(bCtbOnLine,nEvento)
Local aArea    := GetArea()
Local aAreaSM0 := SM0->(GetArea())
Local cFilBkp  := cFilAnt

//-- Verifica se e originado de compra centralizada,
//-- Se sim troca empresa para execucao do lancamento
SC1->(dbSetOrder(6))
If SC1->(dbSeek(xFilial("SC1")+SC7->(C7_NUM+C7_ITEM+C7_PRODUTO))) .And. !Empty(SC1->C1_SCORI)
	SM0->(dbSetOrder(1))
	SM0->(dbSeek(cEmpAnt+AllTrim(SC1->C1_FILENT)))
	cFilAnt := FWCodFil()
EndIf

Eval(bCtbOnLine,nEvento)

SM0->(RestArea(aAreaSM0))
cFilAnt := cFilBkp
RestArea(aArea)
Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MaCanCenSC³ Autor ³ Andre Anjos			³ Data ³08/01/2013 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Esta rotina tem como objetivo verificar se a solicitacao de ³±±
±±³          ³ compra pode ser centralizada sem maiores problemas para a   ³±±
±±³          ³ integridade do sistema                                      ³±±
±±³          ³ IMPORTANTE: Ao atualizar esta funcao, compatibilizar filtros³±±
±±³          ³ na funcao MAComCent.										   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := MaCanCenSC(ExpC1,ExpN1)							   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1: Alias da tabela da solicitacao de compra             ³±±
±±³          ³ ExpL2: Indica se deve validar o cadastor de solicitantes.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1: .T. - Se a solicitacao pode ser centralizada         ³±±
±±³          ³        .F. - Se a solicitacao NAO pode ser centralizada     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaCanCenSC(cAliasSC1,lVerPerm)
Local lRetorno := .T.

If (SubStr((cAliasSC1)->C1_TX,1,1) == "R" .And. SubStr((cAliasSC1)->C1_TX,2,1) <> " ") .Or.; //-- Transmitida
	(cAliasSC1)->C1_QUJE >= (cAliasSC1)->C1_QUANT .Or.;									//-- Encerrada (recebida ou residuo)
	!Empty((cAliasSC1)->C1_COTACAO) .Or.;													//-- Em cotacao
	(cAliasSC1)->C1_TPOP == "P" .Or.;														//-- Prevista
	(cAliasSC1)->C1_IMPORT == "S" .Or.;													//-- Item importado (SI)
	!((cAliasSC1)->C1_APROV $ " ,L") .Or.;													//-- Nao aprovada
	AllTrim((cAliasSC1)->C1_ORIGEM) == "TRM" .Or.;											//-- Originada por TRM
	!Empty((cAliasSC1)->C1_SCORI)															//-- Solicitacao gerada por centralizacao

	lRetorno := .F.
EndIf

If lRetorno .And. lVerPerm .And. SuperGetMv("MV_RESTSOL") == "S" //-- Avalia se o usuario tem permissao de solicitante
	SB1->(dbSetOrder(1))
	If SB1->(dbSeek(xFilial("SB1")+SC1->C1_PRODUTO)) .And. SB1->B1_SOLICIT =="S" .And.;
			!A110Restr((cAliasSC1)->C1_PRODUTO,UsrRetGrp(),RetCodUsr(),.F./*lHelp*/)
		lRetorno := .F.
	EndIf
EndIf

Return(lRetorno)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ComCentMarºAutor  ³ Andre Anjos        º Data ³  15/01/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao de marcacao de registros da tela de compra centrali º±±
±±º          ³ zada (para validar quando produto nao existente na empresa º±±
±±º          ³ centralizadora).											  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MAComCent                                                  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ComCentMar(oBrowse,cCombo,lVldProd,lTodos)
Local nX       := 0
Local nPRODUTO := aScan(oBrowse:aHeaders,{|x| x == RetTitle("C1_PRODUTO")})
Local aAreaSB1 := SB1->(GetArea())
Local cFilSB1  := xFilial("SB1",PadR(cCombo,FWSizeFilial()))

SB1->(dbSetOrder(1))

If lTodos
	For nX := 1 To Len(oBrowse:aArray)
		If !lVldProd .Or. oBrowse:aArray[nX,1] .Or. SB1->(dbSeek(cFilSB1+oBrowse:aArray[oBrowse:nAt,nPRODUTO]))
			oBrowse:aArray[nX,1] := !oBrowse:aArray[nX,1]
		EndIf
	Next nX
Else
	If oBrowse:aArray[oBrowse:nAt,1] .Or. SB1->(dbSeek(cFilSB1+oBrowse:aArray[oBrowse:nAt,nPRODUTO]))
		oBrowse:aArray[oBrowse:nAt,1] := !oBrowse:aArray[oBrowse:nAt,1]
	Else
		Aviso(STR0014,STR0113 +AllTrim(cCombo) +STR0114,{STR0118}) //-- Este item não poderá ser comprado pela empresa ### pois não faz parte de seu cadastro de produtos. ##"Ok"
	EndIf
EndIf

oBrowse:Refresh()

SB1->(RestArea(aAreaSB1))
Return
                  
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CotGeraSCHºAutor  ³ Cleber Maldonado	 º Data ³  15/01/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao de marcacao de registros da tela de compra centrali º±±
±±º          ³ zada (para validar quando produto nao existente na empresa º±±
±±º          ³ centralizadora).											  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cFilOri: codigo da filial de origem do processo de compra. º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     	 ³ MaAvalCot                                                  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CotGeraSCH(cFilOri)
Local nX		:= 0
Local nY		:= 0
Local nTotSCH	:= 0
Local aSCs		:= {}
Local cItemCH	:= StrZero(0,TamSX3("CH_ITEM")[1])
Local cFilSC1 := ""
Local aCTBEnt	:= CTBEntArr()
Local lCotRatP  := SuperGetMv("MV_COTRATP",.F.,.F.)
Local lHasSCX	:= .F.
Local nTamCHPerc := TamSX3("CH_PERC")[1]

SC1->(dbSetOrder(5))
SC1->(dbSeek(xFilial("SC1",cFilOri)+SC8->(C8_NUM+C8_PRODUTO+C8_IDENT)))
cFilSC1 := IIF(Empty(SC1->C1_FILIAL),SC1->C1_FILENT,SC1->C1_FILIAL)
While !SC1->(EOF()) .And. cFilSC1 == xFilial("SC8",cFilOri) .And. SC1->(C1_COTACAO+C1_PRODUTO+C1_IDENT) == SC8->(C8_NUM+C8_PRODUTO+C8_IDENT)
	SCX->(dbSetOrder(1))
	lHasSCX := SCX->(dbSeek(xFilial("SCX",cFilOri)+SC1->(C1_NUM+C1_ITEM)))
	While SCX->(!EOF()) .And. SCX->(CX_FILIAL+CX_SOLICIT+CX_ITEMSOL) == xFilial("SCX",cFilOri)+SC1->(C1_NUM+C1_ITEM)			
		If (nX := aScan(aSCs,{|x| ChaveSCH(1,aCTBEnt,x,"SCX")})) == 0
			ChaveSCH(2,aCTBEnt,aSCs,"SCX")
			nX := Len(aSCs)
		Else
			aTail(aSCs[nX]) += NoRound(Round((((SC1->C1_QUANT*100)/SC7->C7_QUANT)*SCX->CX_PERC)/100,2) * ProRatC1C8(SC1->C1_COTACAO,SC1->C1_NUM,SC1->C1_PRODUTO,SC8->C8_FORNECE,SC8->C8_LOJA, SC8->C8_NUMPRO,SC1->C1_FILIAL,SC8->C8_FILIAL),2)
		Endif

		SCX->(dbSkip())
	End

	//-- Caso nao tenha SCX, gera rateio com os dados da SC1
	If !lHasSCX .And. lCotRatP
		If (nX := aScan(aSCs,{|x| ChaveSCH(1,aCTBEnt,x,"SC1")})) == 0
			ChaveSCH(2,aCTBEnt,aSCs,"SC1")
			nX := Len(aSCs)
		Else
			aTail(aSCs[nX]) += Round((SC1->C1_QUANT / SC8->C8_QUANT) * 100,nTamCHPerc)
		Endif
	EndIf
	
	SC1->(dbSkip())
End

//-- Totaliza rateio da SCH
For nX := 1 to Len(aSCs)
	nTotSCH += NoRound(aTail(aSCs[nX]),2)
Next nX

//-- So gera rateio quando ha mais de uma quebra contabil
If Len(aSCs) >= 1
	//-- Caso o arredondamento tenha dado diferenca (ate 0,05), ajusta no ultimo item
	If (Abs(nTotSCH - 100) > 0 .And. (nTotSCH - 100) < 0.05) .Or.;
		(Abs(nTotSCH - 100) < 0 .And. (nTotSCH - 100) > 0.05)
		aTail(aTail(aSCs)) -= nTotSCH - 100
		nTotSCH -= nTotSCH - 100
	EndIf
	
	//-- Grava dados dos rateios
	For nX := 1 To Len(aSCs)     
		cItemCH := Soma1(cItemCH)	
		RecLock("SCH",.T.)
		SCH->CH_FILIAL	:= xFilial("SCH")
		SCH->CH_PEDIDO  := SC7->C7_NUM
		SCH->CH_FORNECE := SC7->C7_FORNECE
		SCH->CH_LOJA 	:= SC7->C7_LOJA
		SCH->CH_ITEMPD 	:= SC7->C7_ITEM
		SCH->CH_ITEM 	:= cItemCH
		SCH->CH_CC 		:= aSCs[nX,1]
		SCH->CH_CONTA 	:= aSCs[nX,2]
		SCH->CH_ITEMCTA	:= aSCs[nX,3]
		SCH->CH_CLVL	:= aSCs[nX,4]
		SCH->CH_PERC 	:= aTail(aSCs[nX])
		//-- Grava entidades contabeis
		For nY := 1 To Len(aCTBEnt)
			SCH->&("CH_EC"+aCTBEnt[nY]+"CR") := aSCs[nX,nY+6]
			SCH->&("CH_EC"+aCTBEnt[nY]+"DB") := aSCs[nX,nY+7]
		Next nY
		SCH->(MsUnlock())
		SCX->(MsGoto(aSCs[nX,5]))
		SC1->(MsGoto(aSCs[nX,6]))
		LancaPCO("SC1","000051","03")
	Next nX
	
	//-- Gera linha de rateio em branco para a sobra
	If nTotSCH <> 100
		cItemCH := Soma1(cItemCH)
		RecLock("SCH",.T.)
		SCH->CH_FILIAL	:= xFilial("SCH")
		SCH->CH_PEDIDO  := SC7->C7_NUM
		SCH->CH_FORNECE := SC7->C7_FORNECE
		SCH->CH_LOJA 	:= SC7->C7_LOJA
		SCH->CH_ITEMPD 	:= SC7->C7_ITEM
		SCH->CH_ITEM 	:= cItemCH
		SCH->CH_PERC 	:= 100 - nTotSCH
		SCH->(MsUnlock())
		LancaPCO("SC1","000051","03")
	EndIf
	
	//-- Limpa campos da SC7, ja que ha rateio
	SC7->C7_RATEIO 	:= '1'
	SC7->C7_CC		:= CriaVar("C7_CC",.F.)
	SC7->C7_CONTA	:= CriaVar("C7_CONTA",.F.)
	SC7->C7_ITEMCTA	:= CriaVar("C7_ITEMCTA",.F.)
	SC7->C7_CLVL	:= CriaVar("C7_CLVL",.F.)
	For nX := 1 To Len(aCTBEnt)
		SC7->&("C7_EC"+aCTBEnt[nX]+"CR") := CriaVar("C7_EC"+aCTBEnt[nX]+"CR",.F.)
		SC7->&("C7_EC"+aCTBEnt[nX]+"DB") := CriaVar("C7_EC"+aCTBEnt[nX]+"DB",.F.)
	Next nX
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ChaveSCH  ºAutor  ³ Andre Anjos		 º Data ³  15/03/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Faz busca ou inclui item no array de SCs.                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ CotGeraSCH                                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ChaveSCH(nEvento,aCTBEnt,aSC,cAlias)
Local lRet 	  := .F.
Local nX   	  := 0
Local cPrefix := Substr(cAlias,2,2)+"_"

//-- Buscao no array aSCs (aScan)
If nEvento == 1
	If (lRet := aSC[1]+aSC[2]+aSC[3]+aSC[4] == (cAlias)->&(cPrefix+"CC+"+cPrefix+"CONTA+"+cPrefix+"ITEMCTA+"+cPrefix+"CLVL"))
		For nX := 1 To Len(aCTBEnt)
			If !(lRet := aSC[nX+6]+aSC[nX+7] == (cAlias)->&(cPrefix+"EC"+aCTBEnt[nX]+"CR")+(cAlias)->&(cPrefix+"EC"+aCTBEnt[nX]+"DB"))
				Exit
			EndIf
		Next nX
	EndIf
//-- Inclui no array aSCs (aAdd)
ElseIf nEvento == 2
	aAdd(aSC,Array(6 + (Len(aCTBEnt) * 2) + 1))
	aTail(aSC)[1] := (cAlias)->&(cPrefix+"CC")
	aTail(aSC)[2] := (cAlias)->&(cPrefix+"CONTA")
	aTail(aSC)[3] := (cAlias)->&(cPrefix+"ITEMCTA")
	aTail(aSC)[4] := (cAlias)->&(cPrefix+"CLVL")
	aTail(aSC)[5] := SCX->(Recno())
	aTail(aSC)[6] := SC1->(Recno())
	For nX := 1 To Len(aCTBEnt)
		aTail(aSC)[nX+6] := (cAlias)->&(cPrefix+"EC"+aCTBEnt[nX]+"CR")
		aTail(aSC)[nX+7] := (cAlias)->&(cPrefix+"EC"+aCTBEnt[nX]+"DB")
	Next nX
	If cAlias == "SC1"
		aTail(aTail(aSC)) := Round((SC1->C1_QUANT / SC8->C8_QUANT) * 100,TamSX3("CH_PERC")[1])
	ElseIf cAlias == "SCX"
		aTail(aTail(aSC)) := NoRound(Round((((SC1->C1_QUANT*100)/SC7->C7_QUANT)*SCX->CX_PERC)/100,2) * ProRatC1C8(SC1->C1_COTACAO,SC1->C1_NUM,SC1->C1_PRODUTO,SC8->C8_FORNECE,SC8->C8_LOJA, SC8->C8_NUMPRO,SC1->C1_FILIAL,SC8->C8_FILIAL),2)
	EndIf
EndIf

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ProRatC1C8³ Autor³ Brunno de Medeiros da Costa ³Data ³05/10/17 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna Proporção de Correspondência Rateio SC1 referente SC8  ³±±
±±³			 ³ Utilizado quando C8_QUANT permite alteração                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCotacao: numero da cotacao relacionada						  ³±±
±±³          ³ cNumSC: numero da solicitacao de compras relacionada			  ³±±
±±³          ³ cProduto: codigo do produto                              	  ³±±
±±³          ³ 																  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ChaveSCH                                                  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function ProRatC1C8(cCotacao,cNumSC,cProduto,cFornece,cLoja,cProposta,cFilSC1,cFilSC8)
Local aArea 	 	:= GetArea()
Local cAliasTOP 	:= GetNextAlias()
Local nFator		:= 1
Local nRecSX3 		:= SX3->(RecNo())
Local lAlterav 		:= AllTrim(Upper(GetSx3Cache("C8_QUANT","X3_VISUAL"))) == "A"

SX3->(dbGoto(nRecSX3))

if lAlterav //Prossegue com validação se o X3_VISUAL do C8_QUANT foi alterado para permitir Alteração 
	
	BeginSql Alias cAliasTOP
	
		
		SELECT C8_NUM,
	          C8_PRODUTO,
	          SUM(SC1_TOTAL.C1_QUANT) AS C1_QTDTOTAL,
	          C8_QUANT,
	          C8_ITEM,
	          (C8_QUANT * 100) / SUM(C1_QUANT) AS FATOR
	   FROM %table:SC1% SC1_TOTAL
	   INNER JOIN %table:SC8% SC8 
	   		ON SC1_TOTAL.C1_COTACAO		= SC8.C8_NUM
	   		AND SC1_TOTAL.C1_IDENT 		= SC8.C8_ITEM
	   		AND SC1_TOTAL.C1_PRODUTO	= SC8.C8_PRODUTO
	   WHERE SC1_TOTAL.C1_COTACAO 	= %Exp:cCotacao% 
	     AND SC1_TOTAL.C1_PRODUTO 	= %Exp:cProduto%
	     AND SC1_TOTAL.C1_CC 		= ' '
	     AND SC1_TOTAL.C1_FILIAL 	= %Exp:cFilSC1% 
	     AND SC8.C8_FILIAL 			= %Exp:cFilSC8% 
	     AND SC8.C8_FORNECE 		= %Exp:cFornece%
	     AND SC8.C8_LOJA 			= %Exp:cLoja%
	     AND SC8.C8_NUMPRO 			= %Exp:cProposta%
	     AND SC1_TOTAL.D_E_L_E_T_= ' '
	     AND SC8.D_E_L_E_T_= ' '
	   GROUP BY C8_NUM,
	            C8_PRODUTO,
	            C8_QUANT,
	            C8_ITEM
	   HAVING SUM(SC1_TOTAL.C1_QUANT) <> C8_QUANT
		
	EndSQL
	
	dbSelectArea(cAliasTop)
	(cAliasTOP)->(dbGoTop())
	
	If !(cAliasTOP)->(Eof()) .AND. (cAliasTOP)->FATOR > 0 
			
		nFator := (cAliasTOP)->FATOR / 100
		
	EndIf
	
	(cAliasTOP)->(DbCloseArea())
	
EndIf

RestArea(aArea)

Return nFator


/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³SAGeraSGX   | Autor ³Carlos Capeli			   ³ Data ³ 14/06/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Funcao utilizada para buscar os rateios da solicitacao ao armazem ³±±
±±³          ³ e passar na rotina automatica de solicitacao de compra.			 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cChaveRat = Chave da tabela SCX									 ³±±
±±³			 ³ aHeadSCX  = aHeader da tabela SCX								 ³±±
±±³			 ³ aColsSCX  = aCols da tabela SCX									 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA110                                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SAGeraSGX(cChaveRat,aColsSCX)
Local aAreaSGS	:= SGS->(GetArea())
Local cItemSCX	:= ""
Local cItemSA	:= ""
Local nItemSCX	:= 1
Local aItemRat	:= {}
DEFAULT aColsSCX := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Montagem do aCols SCX  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aColsSCX := {}
SGS->(dbSetOrder(1))
SGS->(dbSeek(xFilial("SGS")+cChaveRat))
While SGS->(!Eof()) .And. SGS->(GS_FILIAL+GS_SOLICIT+GS_ITEMSOL) == xFilial("SGS")+cChaveRat
	aAdd(aItemRat,{"CX_ITEM",StrZero(Val(SGS->GS_ITEM),Len(SCX->CX_ITEM)),NIL})
	aAdd(aItemRat,{"CX_PERC",SGS->GS_PERC,NIL})
	aAdd(aItemRat,{"CX_CC",SGS->GS_CC,NIL})
	aAdd(aItemRat,{"CX_CONTA",SGS->GS_CONTA,NIL})
	aAdd(aItemRat,{"CX_ITEMCTA",SGS->GS_ITEMCTA,NIL})
	aAdd(aItemRat,{"CX_CLVL",SGS->GS_CLVL,NIL})
	If cItemSA <> StrZero(Val(SGS->GS_ITEMSOL),Len(SC1->C1_ITEM))
		cItemSA  := StrZero(Val(SGS->GS_ITEMSOL),Len(SC1->C1_ITEM))
		cItemSCX := StrZero(nItemSCX,Len(SC1->C1_ITEM))
		aAdd(aColsSCX,{cItemSCX,{}})
		nItemSCX++
	EndIf
	aAdd(aColsSCX[Val(cItemSCX)][2],aItemRat)
	aItemRat := {}

	SGS->(dbSkip())
EndDo

RestArea(aAreaSGS)
Return()

/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³AtuSC5   | Autor ³Marcia A. R. Torres			   ³ Data ³ 04/11/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Funcao utilizada para liberar os pedidos de venda 					³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nNumPed = Numero do Pedido de Venda									³±±
±±³																							³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ COMXFUN                                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

Static Function AtuSC5(nNumPed)

Local lLiberOk := .F.
local aArea    := {}
Local aAreaSC5 := {}
Local aAreaSC6 := {}

Default nNumPed := 0

aArea   :=  getarea()
aAreaSC5:=  SC5->(getarea())
aAreaSC6:=  SC6->(getarea())

dbSelectArea("SC6")
dbSetOrder(1)  //Filial + Ped. Venda

If dbSeek(xFilial("SC6")+nNumPed)

	While !( SC6->(Eof()) ) .And. (SC6->C6_FILIAL+SC6->C6_NUM == xFilial("SC6")+nNumPed)
		If  (SC6->C6_QTDLIB + SC6->C6_QTDEMP) == SC6->C6_QTDVEN
			lLiberOk := .T.
		Else
			lLiberOk := .F.
			Exit
		EndIf
		SC6->( dbSkip() )
	EndDo
		
	If lLiberOk
		dbSelectArea("SC5")
		dbSetOrder(1)   //Filial + Ped. Venda
		If DbSeek(xFilial("SC5")+nNumPed)	
			RecLock("SC5",.F.)
			REPLACE C5_LIBEROK WITH "S"
			MsUnlock()
		EndIf
	EndIf
	
Endif

restarea(aAreaSC6)
restarea(aAreaSC5)
restarea(aArea)

Return NIL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MTGetVProd ³ Autor ³ Cleber Maldonado      ³ Data ³27.08.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o valor do produto respeitando a seguinte ordem:   ³±±
±±³          ³ 1- Ultimo Preço de Compra 2- Custo Standard 3- Custo Médio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ MTGetVProd(cProd)   					                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Código do Produto                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MTGetVProd(cProd)
Local nRet := 0

dbSelectArea("SB1")
dbSetOrder(1)

If MsSeek(xFilial("SB1")+cProd)
	If !Empty(SB1->B1_UPRC)
		nRet := SB1->B1_UPRC
	ElseIf !Empty(SB1->B1_CUSTD)
		nRet := SB1->B1_CUSTD
	Endif
	If nRet == 0
		dbSelectArea("SB2")
		dbSetOrder(1)
		If MsSeek(xFilial("SB2")+cProd+SB1->B1_LOCPAD)
			nRet := SB2->B2_CM1
		Endif
	Endif
Endif
Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MTGETFEC()
Função para criar array dos campos das entidades contabeis criadas adicionamelnte as padroes. 

@author alexandre.gimenez
@since 26/08/2013
@version 1.0
@param cTab Alias da tabela.
@param cPrefix Prefixo da tabela.
@param aCampos campos ja existentes no array.
@return aCampos 
/*/
//-------------------------------------------------------------------
Function MTGETFEC(cTab,cPrefix,aCampos)
Local aEntidades := {}
Local aArea      := GetArea()
local cCpo       := ""
local nEnt       := 0
local nDeb       := 0

Default cTab     := "   "
Default cPrefix  := "  "
Default aCampos  := {}

aEntidades := IIf(Type("aCTBEnt") == "A",aCTBEnt, CtbEntArr())

If Empty(aCampos)
	aCampos	:= {cPrefix+"_CC",cPrefix+"_CONTA", IIF(cPrefix == "B1",substr(cPrefix+"_ITEMCC",1,10),substr(cPrefix+"_ITEMCTA",1,10)), cPrefix+"_CLVL"}
EndIf

dbSelectArea(cTab) // Sim ou não eis a questao;.
For nEnt := 1 to Len(aEntidades)
	For nDeb := 1 to 2
		cCpo := cPrefix + "_EC"+aEntidades[nEnt]
		
		If nDeb == 1
			cCpo += "DB"
		Else
			cCpo += "CR"
		EndIf
		
		aadd(aCampos,cCpo)
		cCpo := ""
					
	Next nDeb
Next nEnt	

RestArea(aArea)
Return aCampos

//-------------------------------------------------------------------
/*/{Protheus.doc} MTFindMVC(oModel,aCampos,nLineExc,nLineIni,lDelet)
Função para verificar se existe um valor no modelo mvc

@author alexandre.gimenez
@return lRet
@since 23/10/2013
@version 1.0
/*/
//------------------------------------------------------------------
Function MTFindMVC(oModel,aCampos,nLineExc,nLineIni,lDelet)
Local aSaveLines 	:= FWSaveRows()
Local nX			:= 0
Local nA			:= 0
Local nRet			:= 0
Local lAchou		:= .F.

Default nLineExc	:= 0
Default nLineIni	:= 1
Default lDelet	:= .F.

For nX := nLineIni to oModel:Length()
	oModel:GoLine(nX)
	If (!oModel:IsDeleted() .Or. lDelet) .And. nLineExc <> nX
		For nA := 1 to len(aCampos)
			If RTrim( cValToChar( oModel:GetValue(aCampos[nA,1]))) == RTrim(cValToChar(aCampos[nA,2]))
				lAchou := .T.
			Else
				lAchou := .F.
				Exit
			EndIf
		Next nA
		If lAchou
			nRet := nX
			Exit
		EndIf
	EndIf
Next nX

FWRestRows(aSaveLines)
Return nRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaGeraGCT     ³ Autor ³ Cleber Maldonado   	³ Data ³ 20/11/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera as medição e efetua o encerramento da mesma 			  ³±±
±±³			 ³                   											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cProduto:codigo do produto									  ³±±
±±³          ³ nNecess: necessidade de compra   							  ³±±
±±³          ³ aCampos: campos especificos a serem gravados por rotinas.	  ³±±
±±³          ³ cRotina: identifica a rotina chamadora da funcao.			  ³±±
±±³          ³                                                                ³±±
±±³          ³                                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MatGeraGCT(cProduto,nNecess,aMedicoes,nDiasCob,cRotina)
Local aCabCN120	:= {}
Local aItCN120 	:= {}
Local aRetorno	:= {}
Local aArea 	 	:= GetArea()
Local cAliasTOP 	:= GetNextAlias()
Local dDataQry	:= If(!Empty(nDiasCob),(ddatabase + nDiasCob),DBJ->DBJ_DTATE)
Local cFilCompNa	:= cFilAnt
Local cNumMed		:= ""


BeginSql Alias cAliasTOP

	SELECT CN9.CN9_NUMERO,CN9.CN9_REVISA,CNF.CNF_COMPET,CNA.CNA_NUMERO,CNF.CNF_PARCEL,CNF.CNF_PRUMED,
	      CASE  WHEN CNF.CNF_SALDO IS NULL THEN CNB.CNB_SLDMED
    	              WHEN CNS.CNS_SLDQTD IS NULL THEN ( CASE  WHEN CNA.CNA_SALDO > 0 THEN (CNF.CNF_SALDO/CNA.CNA_SALDO) * CNB.CNB_SLDMED
    	              										ELSE 0 END )
        	          ELSE CNS_SLDQTD END QTDMED 
	FROM %table:CNB% CNB 
	JOIN %table:CN9% CN9 ON
	      CN9.%NotDel% AND
	      CN9.CN9_FILIAL = %Exp:xFilial("CN9",cFilCompNa)% AND
	      CN9.CN9_NUMERO = CNB.CNB_CONTRA AND
	      CN9.CN9_REVISA = CNB.CNB_REVISA AND
	      CN9.CN9_REVISA = CN9.CN9_REVATU AND
	      CN9.CN9_SITUAC = '05' 
	JOIN %table:CN1% CN1 ON
	      CN1.%NotDel% AND
	      CN1.CN1_FILIAL = %Exp:xFilial("CN1",cFilCompNa)% AND
	      CN1.CN1_CODIGO = CN9.CN9_TPCTO AND
	      CN1.CN1_ESPCTR = '1' AND
	      CN1.CN1_MEDAUT = '1'
	JOIN %table:CNA% CNA ON
	      CNA.%NotDel% AND
	      CNA.CNA_FILIAL = %Exp:xFilial("CNA",cFilCompNa)% AND
	      CNA.CNA_CONTRA = CNB.CNB_CONTRA AND
	      CNA.CNA_REVISA = CNB.CNB_REVISA AND
	      CNA.CNA_NUMERO = CNB.CNB_NUMERO
	LEFT JOIN %table:CNF% CNF ON
	      CNF.%NotDel% AND
	      CNF.CNF_FILIAL = %Exp:xFilial("CNF",cFilCompNa)% AND
	      CNF.CNF_CONTRA = CNB.CNB_CONTRA AND
	      CNF.CNF_REVISA = CNB.CNB_REVISA AND
	      CNF.CNF_NUMERO = CNA.CNA_CRONOG
	LEFT JOIN %table:CNS% CNS ON
	      CNS.%NotDel% AND
	      CNS.CNS_FILIAL = %Exp:xFilial("CNS",cFilCompNa)% AND
	      CNS.CNS_CONTRA = CNB.CNB_CONTA AND
	      CNS.CNS_REVISA = CNB.CNB_REVISA AND
	      CNS.CNS_PLANI  = CNB.CNB_NUMERO AND
	      CNS.CNS_ITEM   = CNB.CNB_ITEM AND
	      CNS.CNS_CRONOG = CNF.CNF_NUMERO AND
	      CNS.CNS_PARCEL = CNF.CNF_PARCEL 
	WHERE CNB.%NotDel% AND
	      CNB.CNB_FILIAL = %Exp:xFilial("CNB",cFilCompNa)% AND
	      CNB.CNB_PRODUT = %Exp:cProduto% AND
	      CNB.CNB_SLDMED > 0 AND
	      CNB.CNB_PEDTIT <> '2' AND
	      CNF.CNF_PRUMED BETWEEN %Exp:dDatabase% AND %Exp:dDataQry% 
EndSQL

If Type("lMsErroAuto") # "L"
	PRIVATE lMsErroAuto := .F.
Else
	lMsErroAuto := .F.
EndIf

dbSelectArea(cAliasTop)
While (cAliasTop)->(!Eof()) .And. nNecess > 0
	If (cAliasTop)->QTDMED > 0 
		cNumMed := CriaVar("CND_NUMMED")
		aAdd(aCabCN120,{"CND_CONTRA",(cAliasTOP)->CN9_NUMERO,NIL})
		aAdd(aCabCN120,{"CND_REVISA",(cAliasTOP)->CN9_REVISA,NIL})
		aAdd(aCabCN120,{"CND_COMPET",(cAliasTOP)->CNF_COMPET,NIL})
		aAdd(aCabCN120,{"CND_NUMERO",(cAliasTOP)->CNA_NUMERO,NIL})
		aAdd(aCabCN120,{"CND_NUMMED",cNumMed,NIL})
		aAdd(aCabCN120,{"CND_PARCEL",(cAliasTOP)->CNF_PARCEL,NIL})
	
		//-- Gera a medicao
		MsExecAuto({|a,b,c|,CNTA120(a,b,c)},aCabCN120,aItCN120,3)		
	
		//-- Encerra a medicao
		If !lMsErroAuto
			MsExecAuto({|a,b,c|,CNTA120(a,b,c)},aCabCN120,aItCN120,6)
		EndIf
	
		If lMsErroAuto
			MostraErro()
			Aviso("SIGAGCT",STR0144,{STR0118}) //A medição automática de contrato não foi realizada. ## "Ok"
			Exit
		Else
		    nNecess -= (cAliasTop)->QTDMED
		    aAdd(aRetorno,{(cAliasTop)->QTDMED,cNumMed})
		EndIf
		
		cNumMed := CND->CND_NUMMED
		dbSelectArea("CNE")
		dbSetOrder(4)
		CNE->(dbSeek(xFilial("CNE")+cNumMed))
		While CNE->(!EOF()) .And. cNumMed == CNE->CNE_NUMMED
			If CNE->CNE_PRODUT <> cProduto
				aAdd(aMedicoes,{CNE->CNE_PRODUT,cFilCompNa,CNE->CNE_QUANT,cNumMed})
			EndIf
			CNE->(dbSkip())
		End
	EndIf

	(cAliasTop)->(dbSkip())
	aCabCN120 := {}
End

(cAliasTop)->(dbCloseArea())
RestArea(aArea)

Return aRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} COMAJQJEPC
Reabre Pedido de Compras emitidos nos últimos três meses
com base nas notas de devolução.
@author jose.delmondes
@since 03/04/2014
@version 12
@return NIL
/*/
//-------------------------------------------------------------------
Function COMAJQJEPC()
Local lAjustQUJE	:= SuperGetMv("MV_AJQJEPC",.F.,.T.) //QUJE já ajustada de acordo com notas de devolução
Local dDataIni	 	:= dDataBase - 90
Local nSobraNF		:= 0
Local nQuantPed	:= 0
Local nPosSobra	:= 0
Local aSobra		:= {}
	

If  !lAjustQUJE .And. LockByName("COMAJQJEPC"+cEmpAnt+cFilAnt,.T.,.T.,.T.)
	
	//Retorna pedidos com nota de devolução associada
	BeginSql Alias "SC7TMP"
		SELECT SC7.C7_NUM NUM, SC7.C7_ITEM ITEM, SC7.C7_PRODUTO PRODUTO, SC7.C7_LOCAL ARMAZEM,  SD1.D1_QUANT QUANTD1, SD2.D2_QUANT QUANTD2, SC7.C7_TPOP TPOP
		FROM %table:SC7% SC7
		JOIN %table:SD1% SD1 ON
			SD1.%NotDel% AND
	      	SD1.D1_FILIAL = %xFilial:SD1% AND
	      	SD1.D1_PEDIDO = SC7.C7_NUM AND
	      	SD1.D1_ITEMPC = SC7.C7_ITEM
		JOIN %table:SD2% SD2 ON
			SD2.%NotDel% AND
	      	SD2.D2_FILIAL = %xFilial:SD2% AND
			SD2.D2_NFORI = SD1.D1_DOC AND
			SD2.D2_SERIORI = SD1.D1_SERIE AND
			SD2.D2_COD = SD1.D1_COD
		JOIN %table:SF2% SF2 ON
			SF2.%NotDel% AND
	      	SF2.F2_FILIAL = %xFilial:SF2% AND
			SF2.F2_DOC = SD2.D2_DOC AND
			SF2.F2_SERIE = SD2.D2_SERIE AND
			SF2.F2_TIPO = 'D' 
		WHERE SC7.%NotDel% AND
			SC7.C7_FILIAL = %xFilial:SC7% AND
	      	SC7.C7_TIPO = 1 AND
	      	SC7.C7_EMISSAO BETWEEN %Exp:dDataIni% AND %Exp:dDataBase%
	EndSQL
	
	SC7TMP->(dbGoTop())
	While SC7TMP->(!Eof())
		
		//Retorna soma das quantidades em nota do item
		BeginSql Alias "SD1TMP"
			SELECT SUM(D1_QUANT) TOTAL
			FROM %table:SD1% SD1
			WHERE SD1.%NotDel% AND
			SD1.D1_FILIAL = %xFilial:SD1% AND
			SD1.D1_PEDIDO = %Exp:SC7TMP->NUM% AND
			SD1.D1_ITEMPC = %Exp:SC7TMP->ITEM%
		EndSQL	
		
		dbSelectArea("SC7")
		dbSetOrder(1)
		If msSeek(xFilial("SC7")+SC7TMP->NUM+SC7TMP->ITEM)
			
			If !Empty(aSobra)
				nPosSobra := aScan(aSobra,{|x| x[1] == SC7TMP->NUM .And. x[2] == SC7TMP->ITEM .And. x[3] > 0})
				If nPosSobra > 0
					nSobraNF := SD1TMP->TOTAL - SC7->C7_QUANT - aSobra[nPosSobra][3]
					aSobra[nPosSobra][3] += nSobraNF
				Else
					nSobraNF := SD1TMP->TOTAL - SC7->C7_QUANT
					If nSobraNF >0
						AAdd(aSobra, {SC7TMP->NUM, SC7TMP->ITEM, nSobraNF})
					Else
						nSobraNF := 0
					EndIf
				EndIf
			Else
				nSobraNF := SD1TMP->TOTAL - SC7->C7_QUANT
				If nSobraNF >0
					AAdd(aSobra, {SC7TMP->NUM, SC7TMP->ITEM, nSobraNF})
				Else
					nSobraNF := 0
				EndIf
			EndIf
			
			nQuantPed := SC7TMP->QUANTD2 - nSobraNF
			
			//Ajusta quantidade já entregue e saldo previsto
			If nQuantPed > 0
				RecLock("SC7",.F.)
					Replace C7_QUJE With (C7_QUJE - nQuantPed)
					Replace C7_ENCER with IIF(C7_QUANT-C7_QUJE>0," ","E")
				MsUnlock()
				dbSelectArea("SB2")
				dbSetOrder(1)
				If msSeek(xFilial("SB2")+SC7TMP->PRODUTO+SC7TMP->ARMAZEM)
					GravaB2Pre("+",nQuantPed,SC7TMP->TPOP)
				EndIf
			EndIf	
		EndIf
		
		SD1TMP->(dbCloseArea())
		SC7TMP->(dbSkip())
	End
	SC7TMP->(dbCloseArea())
	UnLockByName("COMAJQJEPC"+cEmpAnt+cFilAnt,.T.,.T.,.T.)
	PUTMV("MV_AJQJEPC", .T.)
EndIf

Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} COMGetFor
Função para gatilhar o nome e a loja do fornecedor 

@author taniel.silva
@param cCodFor = Código do Fornecedor
@param cLoja = Loja
@param cTipo = Loja ou Nome
@since 28/08/2014
@version P11.80
@return cRet
/*/
//-------------------------------------------------------------------
Function COMGetFor(cCodFor, cLoja, cTipo)
Local cRet := ""
Default cLoja := ""

SA2->(dbSetOrder(1))
If cTipo == 1
	If SA2->(dbSeek(xFilial("SA2")+cCodFor)) 
		cRet := SA2->A2_LOJA
	EndIf
Else
	If SA2->(dbSeek(xFilial("SA2")+cCodFor+AllTrim(cLoja)))
		cRet := SA2->A2_NOME
	EndIf	
EndIf

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MTGetForRl
Busca de fornecedores relacionados

@author guilherme.pimentel

@param cFor Codigo do Fornecedor
@param cLoja Loja do Fornecedor
@return aRet
@since 29/08/2014
@version 1.0
/*/
//------------------------------------------------------------------
Function MTGetForRl(cFor,cLoja)
Local aRet := {}

SA2->(DbSetOrder(1))

CPX->(DbSetOrder(2))
CPX->(DbSeek(xFilial('CPX')+cFor+cLoja))

SA2->(DbSeek(xFilial('SA2')+cFor+cLoja))
aAdd(aRet,AllTrim(Transform(SA2->A2_CGC,IIf(SA2->A2_TIPO == 'F',Substr(PICPES(SA2->A2_TIPO),1,17),Substr(PICPES(SA2->A2_TIPO),1,21))))+' | '+AllTrim(cFor)+'/'+AllTrim(cLoja)+' - '+AllTrim(SA2->A2_NOME))

While cFor == CPX->CPX_CODFOR .And. cLoja == CPX->CPX_LOJFOR
	If SA2->(DbSeek(xFilial('SA2')+CPX->CPX_CODIGO+CPX->CPX_LOJA))
		aAdd(aRet,AllTrim(Transform(SA2->A2_CGC,IIf(SA2->A2_TIPO == 'F',Substr(PICPES(SA2->A2_TIPO),1,17),Substr(PICPES(SA2->A2_TIPO),1,21))))+' | '+AllTrim(CPX->CPX_CODIGO)+'/'+AllTrim(CPX->CPX_LOJA)+' - '+AllTrim(SA2->A2_NOME))
	EndIf
	CPX->(DbSkip())
EndDo

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} COMGerC7Ch
Gera aHead e aCols das tabelas SC7 e SCH.
@author Israel.Escorizza
@param cNumPed 	Numero do Pedido
@since 06/01/2015
@version 1.0
/*/
//------------------------------------------------------------------

Function COMGerC7Ch(cNumPed,aFilSCH)
Local nX		:= 0
Local aArea	:= GetArea()
Local cSeek
Local bWhile
Local bFor	 	:= {|| .T.}
//Necessario colocar CH_ITEMPD como primeiro item do aHeadSCH para compatibilização com a função MaEntCtb
Local aYesSCH := {'CH_ITEMPD','CH_ITEM','CH_PERC','CH_CC','CH_CONTA','CH_ITEMCTA','CHCLVL'}

Default aFilSCH	:= {}

//Posiciona tabela de pedidos para gerar aHeader e aCols.
cSeek 	:= xFilial("SC7")+cNumPed 
bWhile := {|| SC7->(C7_FILIAL+C7_NUM)}
FillGetDados(2,'SC7',1,cSeek,bWhile,bFor, , , , , , ,aHeadSC7,aColsSC7, , ,)

//Posiciona tabela de rateios para gerar aHeader e aCols.		
For nX := 1 To Len(aColsSC7)
	cSeek 	:= xFilial("SCH")+cNumPed +aColsSC7[nX][1] 
	bWhile := {|| SCH->(CH_FILIAL+CH_PEDIDO+CH_ITEMPD)}
	FillGetDados(2,'SCH',2,cSeek,bWhile,bFor,{"CH_FILIAL"} , , , , , ,aHeadSCH,aColsSCH, , , , , , , aYesSCH)
	aAdd(aFilSCH,{aColsSC7[nX][1],aColsSCH})		  	
  	If nX < Len(aColsSC7)
  		aHeadSCH := {}
  	EndIf 		  	
	aColsSCH := {}				
Next nX
	
RestArea(aArea)

Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} COMGerC1Cx
Gera aHead e aCols das tabelas SC1 e SCX.
@author Leonardo Quintania
@param cNumPed 	Numero da solicitação
@since 20/03/2015
@version 1.0
/*/
//------------------------------------------------------------------

Function COMGerC1Cx(cNumSC,aHeadSC1,aColsSC1,aHeadSCX,aColsSCX)
Local aYesSCX := {'CX_ITEMSOL','CX_ITEM','CX_PERC','CX_CC','CX_CONTA','CX_ITEMCTA','CX_CLVL'} //Compatibilização com a função MaEntCtb
Local aHeadTMP:= {}
Local aColsTMP:= {}
Local aArea	:= GetArea()
Local bWhile
Local bFor	 	:= {|| .T.}
Local cSeek
Local nX		:= 0

aHeadSC1:= {}
aColsSC1:= {}
aHeadSCX:= {}
aColsSCX:= {}

//Posiciona tabela de pedidos para gerar aHeader e aCols.
cSeek 	:= xFilial("SC1")+cNumSC 
bWhile := {|| SC1->(C1_FILIAL+C1_NUM)}
FillGetDados(1,'SC1',1,cSeek,bWhile,bFor, , , , , , ,aHeadSC1,aColsSC1, , ,)

//Posiciona tabela de rateios para gerar aHeader e aCols.		
For nX := 1 To Len(aColsSC1)
	aColsTMP := {}	
	aHeadTMP := {}
	cSeek 	:= xFilial("SCX")+cNumSC +aColsSC1[nX][1] 
	bWhile := {|| SCX->(CX_FILIAL+CX_SOLICIT+CX_ITEMSOL)}
	FillGetDados(1,'SCX',1,cSeek,bWhile,bFor,{"CX_FILIAL"} , , , , , ,aHeadTMP,aColsTMP, , , , , , , aYesSCX)
	aAdd(aColsSCX,{aColsSC1[nX][1],aColsTMP})			
Next nX

aHeadSCX := aClone(aHeadTMP)

RestArea(aArea)

Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} MtSendMail()
Envia e-mail para endereço(s) informado(s)
@author israel.escorizza
@param aMailPara 	- E-mail do destinatário
@Param cMailAssun	- Assunto do e-mail
@param cMailTexto - Texto do corpo do e-mail.

@since 23/02/2015
@version P12
@return lRet
/*/
//-------------------------------------------------------------------
Function MTSendMail(aMailPara,cMailAssun,cMailTexto)

// - Variaveis para conexão ao servidor de e-mail.
Local cMailServer	:= AllTrim(SuperGetMv("MV_RELSERV"))
Local cMailConta 	:= AllTrim(SuperGetMv("MV_RELACNT"))
Local cMailSenha 	:= AllTrim(SuperGetMv("MV_RELPSW"))
Local lAuth		:= SuperGetMv("MV_RELAUTH",,.F.)

//PARA ATENTICAR NO SERVIDOR DE EMAIL
Local cUsrAutent  	:= SuperGetMv("MV_RELAUSR")
Local cPswAutent  	:= SuperGetMv("MV_RELAPSW")

// - Variaveis para log de Erros relacionados ao envio.
Local lMsgError	:= SuperGetMv("MV_QMSGERM", .T., .T.)
Local cError		:= ""

// - Variaveis para controle de fluxo.
Local nI := 0
Local lRet	:= .T.
Local cEnvia := ""

If Len(aMailPara) == 0
	lRet := .F.
EndIf

If lRet .And. !Empty(cMailServer) .And. !Empty(cMailConta) .And. !Empty(cMailSenha)
	//- Realiza validações para envio de e-mail
	For nI := 1 To Len(aMailPara)
    	If !Empty(aMailPara[nI])
    		cEnvia += aMailPara[nI]+"; "
    	EndIf
    Next
    cEnvia := SubStr(cEnvia,1,Len(cEnvia)-2)

    //- Conexão com o servidor SMTP
	CONNECT SMTP SERVER cMailServer ACCOUNT cMailConta PASSWORD cMailSenha RESULT lRet

	If lRet .And. lAuth
	//- Autenticacao da conta de e-mail
		lRet := MailAuth(cUsrAutent,cPswAutent)
		If !lRet
			If lMsgError
				GET MAIL ERROR cError
				MsgInfo(cError,OemToAnsi(STR0119)) // "Erro de Autenticação do usuario no servidor de E-Mail"
			Endif
			lRet := .F.
		Endif
	Else
		If !lRet
			If lMsgError
				GET MAIL ERROR cError
				MsgInfo(cError,OemToAnsi(STR0120))	//"Erro de Conexão com servidor de E-Mail"
			Endif
			lRet := .F.
		Endif
	EndIf

	If lRet
	//- Processa envio de e-mail
		SEND MAIL FROM cMailConta TO cEnvia SUBJECT cMailAssun BODY cMailTexto RESULT lRet
		If !lRet
			If lMsgError
				GET MAIL ERROR cError
				MsgInfo(cError,OemToAnsi(STR0121))	//"Erro ao enviar E-Mail"
			Endif
		EndIf
	EndIf
	DISCONNECT SMTP SERVER
Else
	MsgInfo(OemToAnsi(STR0122))
EndIf
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MtHTML2Str()
Retorna conversão de arquivo HTML para string.
@param cFileHTML - Nome do Arquivo HTML que será convertido.
@author israel.escorizza
@since 25/02/2015
@version P12
/*/
//-------------------------------------------------------------------

Function MtHTML2Str(cFileHTML)
Local cBuffer := ""
Local cMsg 	:= ""

If FT_FUSE(cFileHTML) # -1
      FT_FGOTOP()
      While !FT_FEOF()
         cBuffer := FT_FREADLN()
         cMsg += cBuffer
         FT_FSKIP()
      EndDo
EndIf
FT_FUSE()

Return(cMsg)

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetDataPD3³ Autor ³ Isaias Florencio      ³ Data ³ 20/03/15 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Abre interface para digitacao do range de datas para       ³±±
±±³          ³ pesquisa na funcao F4PODER3. Depende da ativacao do        ³±±
±±³          ³ MV_DATAPD3                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ RetDataPD3()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ F4PODER3 - COMXFUN                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RetDataPD3(dPrimData,dSegData,lDataRetr)

Local oDlgEsp  := Nil
Local nOpcao   := 0
Local aSize    := MsAdvSize(.F.)
Local lOk      := .F.

While !lOk
	DEFINE MSDIALOG oDlgEsp From aSize[7],0 To 120,400 OF oMainWnd PIXEL TITLE STR0128 // "F4PODER3"
	
	@ 06,005 SAY STR0129 PIXEL // "Informe as datas para pesquisa das notas com controle de poder de terceiros:"
	
	@ 19,005 SAY STR0130 PIXEL  // "Data de: "
	@ 18,040 MSGET dPrimData PICTURE "@D" SIZE 60, 10 OF oDlgEsp PIXEL
	
	@ 38,005 SAY STR0131 PIXEL // "Data ate: "
	@ 37,040 MSGET dSegData PICTURE "@D" SIZE 60, 10 OF oDlgEsp PIXEL
	
	DEFINE SBUTTON FROM 18,160 TYPE 1 OF oDlgEsp ENABLE PIXEL ACTION ;
	{|| If(dPrimData <= dSegData,nOpcao := 1,nOpcao := 2),oDlgEsp:End() }
	
	DEFINE SBUTTON FROM 37,160 TYPE 2 OF oDlgEsp ENABLE PIXEL ACTION (nOpcao := 0,oDlgEsp:End())
		
	ACTIVATE MSDIALOG oDlgEsp CENTERED
	
	If nOpcao == 1
		lOk := .T.
	ElseIf nOpcao == 2
		Aviso(STR0132,STR0133,{STR0118}) // "AVISO"## "Inconsistencia na ordem das datas" ## "Ok"
	ElseIf nOpcao == 0
		// "AVISO" ## "Será ignorada a pesquisa das notas no intervalo das datas. Serao exibidas todas as notas em aberto ate a data atual do sistema." # Confirma # "Retorna"
		If Aviso(STR0132,STR0135,{STR0087,STR0134}) == 1
	       dSegData    := dDataBase
	       lDataRetr   := .F.
		   lOk         := .T.
		EndIf
	EndIf
End

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} GetDescCmb(cCampo,cOpcao)
Retorna a descrição da opção de um determinado campo (caracter de 1)
@param cCampo - Campo
@param cOpcao - Opção
@author Matheus Lando Raimundo
@since 29/04/2015
@version P12
/*/
//-------------------------------------------------------------------
Function GetDescCmb(cCampo,cOpcao)
Local cOpcs := ""
Local nComeco := ""
Local nFim := ""
Local cResultado := ""

SX3->(DbSetOrder(2))
SX3->(DbSeek(cCampo))

cOpcs := SX3->X3_CBOX

nComeco := At(cOpcao,cOpcs)+2
nFim 	 := At(";",(Substr(cOpcs,nComeco,Len(cOpcs))))-1

If nFim < 1 
	nFim := Len(cOpcs)
EndIf

cResultado := Alltrim(Substr(cOpcs,nComeco,nFim))

Return cResultado

//-------------------------------------------------------------------
/*/{Protheus.doc} COMGERADOC(aPequena,lAvalGCT,lInverte,lLteEmb,lImport,nCobertura,cRotina  )
Realiza avaliação de saldo no SIGAGCT, Contrato de parceria para realizar geração de documentos de compra.
@param aPequena	  - Array com o detalhamento dos produtos a serem utilizados
@param lAvalGCT	  - Determina se será consultados os contratos na base do cliente.
@param lInverte	  - Determina com será feito a avaliação da quantidade a ser comprada se Contratos do GCT e Contratos de Parceria ou Contrato de Parceria e Contratos do GCT.
@param lLteEmb	  - Determina se avalia Lote econômico e quantidade por embalagem.
@param lImport	  - Determina se será avaliado produtos importados
@param nCobertura - Dias de cobertura a serem considerados para pesquisa dos contratos.
@param cRotina	  - Rotina geradora.
@param nAglutDoc  - Sim por documento, Sim Todos, Não
@author Leonardo Quintania
@since 11/05/2015
@version P12
/*/
//-------------------------------------------------------------------
Function ComGeraDoc(aPequena,lAvalGCT,lInverte,lLteEmb,lImport,nCobertura,cRotina,lEnvMail,nAglutDoc,nOperacao )
Local aRetorno 		:= {}
Default nOperacao	:= 3

If nOperacao == 3
	aRetorno:= ComIncDoc(aPequena,lAvalGCT,lInverte,lLteEmb,lImport,nCobertura,cRotina,lEnvMail,nAglutDoc )
Else
	ComExcDoc(aPequena)
EndIf

Return aRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} ComExcDoc(aPequena,lAvalGCT,lInverte,lLteEmb,lImport,nCobertura,cRotina  )
Realiza avaliação de saldo no SIGAGCT, Contrato de parceria para realizar geração de documentos de compra.
@param aPequena	  - Array com o detalhamento dos produtos a serem utilizados
@author Leonardo Quintania
@since 11/05/2015
@version P12
/*/
//-------------------------------------------------------------------
Function ComExcDoc(aPequena)
Local aCabCN120		:= {}
Local aItCN120		:= {}
Local aCab			:= {}
Local aLinha		:= {}
Local aItens		:= {}

Local cFilOri		:= ""
Local cDocOri		:= ""
Local cItOri		:= ""
Local cFilDes		:= ""
Local cDocDes		:= ""
Local cChave		:= ""
Local cAliasDHN 	:= GetNextAlias()
Local cAliasMED		:= GetNextAlias()
Local cUndRequi		:= SuperGetMv("MV_CCUNREQ")
Local cFilBkp		:= ""

Local nQtd			:= 0
Local nX			:= 0
Local nPosPed		:= 0
Local nCnt			:= 0
Local aMV_PAR		:={}

Private lMsErroAuto	:= .F.

For nX := 1 To Len(aPequena)
	
	cFilOri:= aPequena[nX,3]
	cDocOri:= aPequena[nX,11]
	cItOri := aPequena[nX,12]
	
	cChave := "%" + cChaveDes + "%"
	
	BeginSQL Alias cAliasDHN
		SELECT DISTINCT
		  DHN_TIPO,
		  DHN_FILDES,
		  DHN_DOCDES,
		  DHN_ITDES,
		  DHN_QTDATE,
		  R_E_C_N_O_ RecnoDHN
		FROM %Table:DHN% 
		WHERE DHN_FILORI = %Exp:cFilOri%
		AND DHN_DOCORI =  %Exp:cDocOri%
		AND DHN_ITORI =  %Exp:cItOri%
		AND %NotDel%
		%Exp:cChave%
		ORDER BY DHN_TIPO,DHN_FILDES,DHN_DOCDES
	EndSQL
	
	While !(cAliasDHN)->(Eof())
		cFilBkp:= cFilAnt
		A179AltFil((cAliasDHN)->DHN_FILDES)
		aCab	:= {}
		aItens	:= {}
		
		nQtd:= (cAliasDHN)->DHN_QTDATE
			
		// guardo os conteudos da MV_PAR, caso alguma chamada de execauto tenha alterado
		aMV_PAR := {}
		nCnt:=1
		While Type("MV_PAR"+strzero(nCnt,2)) <> "U"
			aAdd( aMV_PAR, &("MV_PAR"+strzero(nCnt,2)))
			nCnt++
		EndDo
		Do Case
			Case (cAliasDHN)->DHN_TIPO == "1" //-- Solicitação de Compras
				If SC1->(DbSeek(xFilial("SC1",(cAliasDHN)->DHN_FILDES) + (cAliasDHN)->DHN_DOCDES + (cAliasDHN)->DHN_ITDES  ) )

					AADD(aCab ,{"C1_NUM"    ,SC1->C1_NUM 		,Nil})
					AADD(aCab ,{"C1_SOLICIT",SC1->C1_SOLICIT	,Nil})
					AADD(aCab ,{"C1_EMISSAO",SC1->C1_EMISSAO 	,Nil})
					AADD(aCab ,{"C1_TPOP"   ,SC1->C1_TPOP 		,Nil})
					AADD(aCab ,{"C1_UNIDREQ",SC1->C1_UNIDREQ 	,Nil})
					AADD(aCab ,{"C1_CODCOMP",SC1->C1_CODCOMP 	,Nil})

					nQtd := SC1->C1_QUANT - nQtd

					If nQtd == 0
                 
 					   AAdd( aItens, { 	{"C1_NUM"		,SC1->C1_NUM		, Nil },;
	                 	             	{"C1_ITEM"		,SC1->C1_ITEM   	, Nil },;
	                              		{"C1_PRODUTO"	,SC1->C1_PRODUTO	, Nil },;
	                              		{"C1_UM"		,SC1->C1_UM			, Nil },;
	                              		{"C1_QUANT"		,nQtd				, Nil },;
	                              		{"AUTDELETA"	,"S"            	, Nil }})
					  
					
	                	MSExecAuto({|x,y,z| MATA110(x,y,z)},aCab,aItens,4)
	                Else
	                   AAdd( aItens, { 	{"C1_NUM"		,SC1->C1_NUM		, Nil },;
	                 	             	{"C1_ITEM"		,SC1->C1_ITEM   	, Nil },;
	                              		{"C1_PRODUTO"	,SC1->C1_PRODUTO	, Nil },;
	                              		{"C1_UM"		,SC1->C1_UM			, Nil },;
	                              		{"C1_QUANT"		,nQtd				, Nil },;
	                              		{"AUTDELETA"	,"N"        		, Nil }})
	                              
	                	MSExecAuto({|x,y,z| MATA110(x,y,z)},aCab,aItens,5)
	                EndIf
	                
				EndIf
				
			Case (cAliasDHN)->DHN_TIPO == "2" //-- Pedido de Compras

				SC7->(DbSeek(xFilial("SC7",(cAliasDHN)->DHN_FILDES) + (cAliasDHN)->DHN_DOCDES))
				
				While !SC7->(Eof()) .And. SC7->(C7_FILIAL+C7_NUM) == xFilial("SC7",(cAliasDHN)->DHN_FILDES) + (cAliasDHN)->DHN_DOCDES
					aLinha := {}
					aadd(aLinha,{"C7_FILIAL"	,SC7->C7_FILIAL	,Nil})
					aadd(aLinha,{"C7_NUM"		,SC7->C7_NUM	,Nil})
					aadd(aLinha,{"C7_ITEM"		,SC7->C7_ITEM 	,Nil})
					aadd(aLinha,{"C7_PRODUTO"	,SC7->C7_PRODUTO,Nil})
					aadd(aLinha,{"C7_UM"		,SC7->C7_UM		,Nil})
					aadd(aLinha,{"C7_QUANT"		,SC7->C7_QUANT	,Nil})
					aadd(aLinha,{"C7_PRECO"		,SC7->C7_PRECO	,Nil})
					aadd(aLinha,{"AUTDELETA"	,"N"			,Nil})			
					aadd(aItens,aLinha)
					SC7->(dbSkip())
				EndDo
				
				nPosPed:= aScan(aItens,{|x| x[1,2]+x[2,2]+x[3,2] == xFilial("SC7",(cAliasDHN)->DHN_FILDES) + (cAliasDHN)->DHN_DOCDES  + (cAliasDHN)->DHN_ITDES })
				
				SC7->(DbSeek(xFilial("SC7",(cAliasDHN)->DHN_FILDES) + (cAliasDHN)->DHN_DOCDES))
				
				//-- Cabeçalho Pedido de Compra
				AADD(aCab ,{"C7_NUM"    	,SC7->C7_NUM 		,Nil})
				AADD(aCab ,{"C7_EMISSAO"	,SC7->C7_EMISSAO 	,Nil})
				AADD(aCab ,{"C7_FORNECE"  	,SC7->C7_FORNECE 	,Nil})
				AADD(aCab ,{"C7_LOJA"		,SC7->C7_LOJA 		,Nil})
				AADD(aCab ,{"C7_COND"		,SC7->C7_COND 		,Nil})
				AADD(aCab ,{"C7_CONTATO"	,SC7->C7_CONTATO 	,Nil})
				AADD(aCab ,{"C7_FILENT"		,SC7->C7_FILENT 	,Nil})
				AADD(aCab ,{"C7_MOEDA"		,SC7->C7_MOEDA	 	,Nil})
				AADD(aCab ,{"C7_TXMOEDA"	,SC7->C7_TXMOEDA 	,Nil})
				
				nQtd := aItens[nPosPed,6,2] - nQtd
								
				If nQtd == 0
            		aItens[nPosPed,8,2]:= "S"
			    EndIf
                MsExecAuto({|v,x,y,z| MATA120(v,x,y,z)},1,aCab,aItens,4)
                
			Case (cAliasDHN)->DHN_TIPO == "3" //-- Autorização de Entregas
				
				SC7->(DbSeek(xFilial("SC7",(cAliasDHN)->DHN_FILDES) + (cAliasDHN)->DHN_DOCDES))
				
				While !SC7->(Eof()) .And. SC7->(C7_FILIAL+C7_NUM) == xFilial("SC7",(cAliasDHN)->DHN_FILDES) + (cAliasDHN)->DHN_DOCDES
					aLinha := {}
					aadd(aLinha,{"C7_FILIAL"	,SC7->C7_FILIAL	,Nil})
					aadd(aLinha,{"C7_NUM"		,SC7->C7_NUM	,Nil})
					aadd(aLinha,{"C7_ITEM"		,SC7->C7_ITEM 	,Nil})
					aadd(aLinha,{"C7_PRODUTO"	,SC7->C7_PRODUTO,Nil})
					aadd(aLinha,{"C7_UM"		,SC7->C7_UM		,Nil})
					aadd(aLinha,{"C7_QUANT"		,SC7->C7_QUANT	,Nil})
					aadd(aLinha,{"C7_PRECO"		,SC7->C7_PRECO	,Nil})
					aadd(aLinha,{"AUTDELETA"	,"N"			,Nil})			
					aadd(aItens,aLinha)
					SC7->(dbSkip())
				EndDo
				
				nPosPed:= aScan(aItens,{|x| x[1,2]+x[2,2]+x[3,2] == xFilial("SC7",(cAliasDHN)->DHN_FILDES) + (cAliasDHN)->DHN_DOCDES  + (cAliasDHN)->DHN_ITDES })
				
				SC7->(DbSeek(xFilial("SC7",(cAliasDHN)->DHN_FILDES) + (cAliasDHN)->DHN_DOCDES))
				
				//-- Cabeçalho Pedido de Compra
				AADD(aCab ,{"C7_NUM"    	,SC7->C7_NUM 		,Nil})
				AADD(aCab ,{"C7_EMISSAO"	,SC7->C7_EMISSAO 	,Nil})
				AADD(aCab ,{"C7_FORNECE"  	,SC7->C7_FORNECE 	,Nil})
				AADD(aCab ,{"C7_LOJA"		,SC7->C7_LOJA 		,Nil})
				AADD(aCab ,{"C7_COND"		,SC7->C7_COND 		,Nil})
				AADD(aCab ,{"C7_CONTATO"	,SC7->C7_CONTATO 	,Nil})
				AADD(aCab ,{"C7_FILENT"		,SC7->C7_FILENT 	,Nil})
				AADD(aCab ,{"C7_MOEDA"		,SC7->C7_MOEDA	 	,Nil})
				AADD(aCab ,{"C7_TXMOEDA"	,SC7->C7_TXMOEDA 	,Nil})
				
				nQtd := aItens[nPosPed,6,2] - nQtd
								
				If nQtd == 0
            		aItens[nPosPed,8,2]:= "S"
			    EndIf
                MsExecAuto({|v,x,y,z| MATA120(v,x,y,z)},2,aCab,aItens,4)
                				
			Case (cAliasDHN)->DHN_TIPO == "5" //-- Medição de Contratos							
												
				cFilDes	:= (cAliasDHN)->DHN_FILDES
				cDocDes := (cAliasDHN)->DHN_DOCDES
							
				cChaveDes += " AND DHN_DOCDES <> '"+ cDocDes  + "'"
				
				cChave	:= "%" + cChaveOri + "%"
				BeginSQL Alias cAliasMED
					SELECT DISTINCT
					  DHN_ROTINA,
					  DHN_FILORI,
					  DHN_DOCORI,
					  DHN_ITORI
					FROM %Table:DHN% 
					WHERE DHN_FILDES = %Exp:cFilDes%
					AND DHN_DOCDES =  %Exp:cDocDes%
					AND DHN_TIPO = '5'
					%Exp:cChave%
					AND %NotDel%					
					ORDER BY DHN_FILORI,DHN_DOCORI					
				EndSQL
				
				While !(cAliasMED)->(Eof())
					If cFilOri+cDocOri+cItOri # AllTrim((cAliasMED)->(DHN_FILORI+DHN_DOCORI+DHN_ITORI)) //-- Verificação para desconsiderar o registro atual.
						Do Case
							Case (cAliasMED)->DHN_ROTINA == "MATA106"
								cChaveOri += " AND DHN_DOCORI <> '"+ cDocOri  + "'"
								If SCP->(dbSeek(AllTrim((cAliasMED)->(DHN_FILORI+DHN_DOCORI+DHN_ITORI))))
									l185Auto:= .T.
									A185Exclui("SCP",SCP->(Recno()),6)
									cChaveDes := ""
									cChaveOri := ""
								EndIf
						EndCase
					EndIf
					(cAliasMED)->(dbSkip())
				EndDo
				
				(cAliasMED)->(dbCloseArea())
				aItens:= {}
				
				aAdd(aCab,{"CND_NUMMED",(cAliasDHN)->DHN_DOCDES,NIL})
				
				MsExecAuto({|a,b,c|,CNTA120(a,b,c)},aCab,aItens,7) //-- Estorna medição

				If !lMsErroAuto
					MsExecAuto({|a,b,c|,CNTA120(a,b,c)},aCab,aItens,5) //-- Encerra Medição
				EndIf		

			Case (cAliasDHN)->DHN_TIPO == "6" //-- Solicitação de Importação
				aAdd(aCab,{})
				aAdd(aItens,{})
				aAdd(ATail(aCab), {'W0_FILIAL', (cAliasDHN)->DHN_FILDES 	,Nil})
				aAdd(ATail(aCab), {'W0__NUM',   (cAliasDHN)->DHN_DOCDES 	,Nil})
				For nX := 1 To Len(aCab)
					MSExecAuto( {|x,y,z| EICSI400(x, y, z) },aCab[nX], aItens[nX], 5)
					If lMsErroAuto
						MostraErro()
						Exit
					EndIf
				Next nX
		EndCase
		// restauro os conteudos da MV_PAR, caso alguma chamada de execauto tenha alterado
		nCnt:=1
		While Len(aMV_PAR)>=nCnt
			&("MV_PAR"+strzero(nCnt,2)) := aMV_PAR[nCnt]
			nCnt++
		EndDo

		A179AltFil(cFilBkp)
		If lMsErroAuto
			MostraErro()
		EndIf
		DHN->(dbGoto((cAliasDHN)->RecnoDHN))
		RecLock("DHN",.F.)
		DHN->(dbDelete())
		DHN->(MsUnlock())
		(cAliasDHN)->(dbSkip())
	EndDo
	(cAliasDHN)->(dbCloseArea())	
Next nX

Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} ComIncDoc(aPequena,lAvalGCT,lInverte,lLteEmb,lImport,nCobertura,cRotina,lEnvMail,nAglutDoc )
Realiza avaliação de saldo no SIGAGCT, Contrato de parceria para realizar geração de documentos de compra.
@param aPequena	  - Array com o detalhamento dos produtos a serem utilizados
@param lAvalGCT	  - Determina se será consultados os contratos na base do cliente.
@param lInverte	  - Determina com será feito a avaliação da quantidade a ser comprada se Contratos do GCT e Contratos de Parceria ou Contrato de Parceria e Contratos do GCT.
@param lLteEmb	  - Determina se avalia Lote econômico e quantidade por embalagem.
@param lImport	  - Determina se será avaliado produtos importados
@param nCobertura - Dias de cobertura a serem considerados para pesquisa dos contratos.
@param cRotina	  - Rotina geradora.
@param lEnvMail	  - Envia Email
@param nAglutDoc  - Sim por documento, Sim Todos, Não
@author Leonardo Quintania
@since 11/05/2015
@version P12
/*/
//-------------------------------------------------------------------
Function ComIncDoc(aPequena,lAvalGCT,lInverte,lLteEmb,lImport,nCobertura,cRotina,lEnvMail,nAglutDoc )
Local aGrande		:= {}
Local aResultado	:= Array(Len(aPequena))
Local aMedicoes		:= {}
Local aDocs			:= {}
Local aQuebraSC		:= {}
Local aQuebraPC		:= {}
Local aQuebraSI		:= {}
Local aCabSolic		:= {}
Local aItemSolic	:= {}
Local aImport		:= {}
Local aFilial		:= {}
Local aNecessCalc	:= {}
Local aRateio		:= {}

Local cUndRequi		:= ""
Local cTipo			:= ""
Local cFilOri		:= ""
Local cDocOri		:= ""
Local cItOri		:= ""
Local cFilDes 		:= "" 
Local cDocDes 		:= ""
Local cItDes 		:= ""
Local cQuery		:= ""
Local cFilBkp		:= cFilAnt

Local nSaldoGrd		:= 0
Local nLE			:= 0
Local nH			:= 0
Local nI			:= 0
Local nJ			:= 0
Local nK			:= 0
Local nV			:= 0
Local nX			:= 0
Local nY			:= 0
Local nZ			:= 0
Local nPosic		:= 0
Local nPosDoc		:= 0
Local nSldPeq		:= 0
Local nQtdRegist	:= 0
Local nPerCalc		:= 0
Local nPosRat		:= 0
Local nQtdAt		:= 0
Local nQtdTot		:= 0
Local nPosDatPrf	:= 0
Local nPosLocal		:= 0
Local nPosDescr	    := 0
Local nPosCC		:= 0

Local lLiberaPC		:= .F.
Local lAvalImp		:= .F.

Local nScTotLib		:= 0
Local aAglut    	:= {}
Local aItens    	:= {}
Local aItensDBM		:= {}
Local aGrpAprov  	:= {}
Local cGrpAprov		:= ""
Local cItAprov		:= ""
Local nForIt		:= 0
Local lEntCtb		:= .T.
Local lGravaB		:= .F.
Local lGravaL		:= .F.
Local dDtDoc
Local nPosMT106S		:= 0

Default lAvalGCT	:= .T. //-- Avaliação Contratos do SIGAGCT
Default lInverte	:= .F. //-- Determina fluxo de geração de documentos sendo .F. - GCT -> AEs ou .T. - AEs -> GCT
Default lLteEmb		:= .T. //-- Determina se será avaliado Lote Economico e Quantidade por embalagens
Default lImport		:= .F. //-- Determina se avalia produto importado
Default lEnvMail	:= .T. //-- Envia email de inclusão de documentos

/*------- Estrutura do aPequena --------*/
//PEQUENA DETALHADA//
//aPequena[x,1 ] : Produto
//aPequena[x,2 ] : Quantidade da necessidade total
//aPequena[x,3 ] : Filial que será gerada o documento 
//aPequena[x,4 ] : Filial que será feita entrega do produto 
//aPequena[x,5 ] : Documento que será gerado sendo 1=Solicitação de Compras e 2=Pedido de Compra
//aPequena[x,6 ] : Fornecedor do produto
//aPequena[x,7 ] : Loja do fornecedor do produto
//aPequena[x,8 ] : Condição de pagamento 
//aPequena[x,9 ] : Preço do Produto
//aPequena[x,10] : Rateio proporcionalizado
//aPequena[x,11] : Codigo do documento
//aPequena[x,12] : Item do documento
//aPequena[x,13] : Campos Adcionais
//aPequena[x,14] : Filial de Origem

/*------- Estrutura do aGrande --------*/
//GRANDE AGLUTINADA//
//aGrande[v,1]	: Array com produtos aglutinados por documento
	//aGrande[x,1,y]	: Array de Item - pequena
		//aGrande[x,1,y,1] : Quantidade da necessidade total
		//aGrande[x,1,y,2] : Documento que será gerado sendo 1=Solicitação de Compras e 2=Pedido de Compra
		//aGrande[x,1,y,3] : Fornecedor do produto
		//aGrande[x,1,y,4] : Loja do fornecedor do produto
		//aGrande[x,1,y,5] : Condição de pagamento 
		//aGrande[x,1,y,6] : Preço do Produtos
		//aGrande[x,1,y,7] : Posição no array pequeno
		//aGrande[x,1,y,8] : Array com documentos gerados
		//aGrande[x,1,y,9] : Item do documento origem
		//aGrande[x,1,y,10]: Campos adicionais
		//aGrande[x,1,y,11]: Filial do documento origem
		//aGrande[x,1,y,12]: Número do documento origem
	//aGrande[x,2]	: Produto
	//aGrande[x,3]	: Quantidade da necessidade total
	//aGrande[x,4]	: Filial que será gerada o documento 
	//aGrande[x,5]	: Filial que será feita entrega do produto 
	//aGrande[x,6]  : Array com rateio proporcionalizados
//aGrande[v,2] : Código do documento
//aGrande[v,3] : Filial do documento

For nX := 1 To Len(aPequena)
	//Verifica se foi enviada a Filial de  Origem, caso não, adiciona a posição 14 ao Array
	If Len(aPequena[nX]) == 13
		aAdd(aPequena[nX],"")
	EndIf
	//-- Realiza pesquisa do código de documento
	If nAglutDoc ==  1 .Or. nAglutDoc == 4 //-- Verifica se a aglutinação é igual 1 ou 4 (aglutinação por documento)
		nPosDoc := aScan(aGrande,{|x| x[2]+x[3] == aPequena[nX,11]+aPequena[nX,14]})
	ElseIf nAglutDoc == 2 .And. Len(aGrande) > 0 //-- Verifica se a aglutinação é igual 2 aglutinando todos os itens iguais, mas verifica se o array não esta vazio
		If cRotina == "MATA106" //se for 2 (todos) e vier da pré-requisição não aglutina por filial
			nPosDoc := aScan(aGrande,{|x| x[3] == aPequena[nX,14]})
		Else
			nPosDoc:= 1 
		Endif 
	Else //-- Efetua a criação de um novo array porque opção escolhida foi para não aglutinar
		//-- Caso contrario realiza a inclusão de uma nova posição do documentos
		aAdd(aGrande,{{},aPequena[nX,11],aPequena[nX,14]}) //Documento
		aAdd(aGrande[Len(aGrande),1],{{},aPequena[nX,1],aPequena[nX,2],aPequena[nX,3],aPequena[nX,4],aPequena[nX,10],aPequena[nX,13]}) //-- Caso contrario realiza a inclusão do item no array
		aAdd(aGrande[Len(aGrande),1,Len(aGrande[Len(aGrande),1]),1],{aPequena[nX,2],aPequena[nX,5],aPequena[nX,6],aPequena[nX,7],aPequena[nX,8],aPequena[nX,9],nX,{},aPequena[nX,12],aPequena[nX,13],aPequena[nX,14],aPequena[nX,11]}) //-- Caso contrario realiza a inclusão do item no array
		Loop
	EndIf
	If nPosDoc  > 0  //-- Verifica se encontrou o documento aglutinado, caso exista inclui nova posição 
		If cRotina == "MATA106"
			nPosDescr  := aScan(aPequena[nX,13],{|x| x[1] == "DESCRI"})
			nPosDatPrf := aScan(aPequena[nX,13],{|x| x[1] == "DATPRF"})
			nPosLocal  := aScan(aPequena[nX,13],{|x| x[1] == "LOCAL"})
			nPosCC	   := aScan(aPequena[nX,13],{|x| x[1] == "CC"})
			nPosMT106S := aScan(aPequena[nX,13],{|x| x[1] == "MT106SCA"}) // Caso o ponto de entrada MT106SCA exista
			
			nPosic:= aScan(aGrande[nPosDoc,1],{|x| x[2]+x[4]+x[5]+x[7][nPosDescr][2]+DtoS(x[7][nPosDatPrf][2])+x[7][nPosLocal][2]+x[7][nPosCC][2]+x[7][nPosMT106S][2][2] == aPequena[nX,1]+aPequena[nX,3]+aPequena[nX,4]+aPequena[nX][13][nPosDescr][2]+DtoS(aPequena[nX][13][nPosDatPrf][2])+aPequena[nX][13][nPosLocal][2]+aPequena[nX][13][nPosCC][2]+aPequena[nX][13][nPosMT106S][2][2]})
		Else
			nPosic:= aScan(aGrande[nPosDoc,1],{|x| x[2]+x[4]+x[5] == aPequena[nX,1]+aPequena[nX,3]+aPequena[nX,4]})
		EndIf
		If nPosic > 0 .And. nAglutDoc != 4 //-- Verifica se encontrou o produto no array de produtos aglutinados
			//-- Efetua calculo do rateio proporcionalizado
			aRateio:= {}
			//-- Avalia os rateios que estão inseridos na grande
			For nY := 1 To Len(aGrande[nPosDoc,1,nPosic,6])
				nPerCalc:= aGrande[nPosDoc,1,nPosic,3] * (aGrande[nPosDoc,1,nPosic,6,nY,1] / 100) //-- QtdGrande * ( Percentual/100 )
				aAdd(aRateio,{ nPerCalc , aGrande[nPosDoc,1,nPosic,6,nY,2] } ) 		
			Next nY
			
			//-- Avalia os rateios novos que iram entrar no array se o conjunto de entidades contabeis forem as mesmas
			For nY := 1 To Len(aPequena[nX,10])
				nPosRat:= aScan(aRateio,{|x| x[2] == aPequena[nX,10,nY,2] })
				nPerCalc:= aPequena[nX,2] * (aPequena[nX,10,nY,1] / 100) //-- QtdPequena * ( Percentual/100 )
				If nPosRat > 0 
					aRateio[nPosRat,1] +=  nPerCalc
				Else
					aAdd(aRateio,{ nPerCalc , aPequena[nX,10,nY,2] } )
				EndIf
			Next nY
			aGrande[nPosDoc,1,nPosic,3]:= aGrande[nPosDoc,1,nPosic,3] + aPequena[nX,2] //-- Caso encontre realiza a aglutinação da necessidade atualizando quantidade
			//-- Efetua alteração de quantidade para percentual
			For nY := 1 To Len(aRateio)
				aRateio[nY,1] := Round((aRateio[nY,1] / aGrande[nPosDoc,1,nPosic,3]) * 100,0) //-- Total = Quantidade Proporcionalizada / Quantidade Total * 100
			Next nY		
			aGrande[nPosDoc,1,nPosic,6] := aClone(aRateio)
			//-- Fim do calculo do rateio
			aAdd(aGrande[nPosDoc,1,nPosic,1],{aPequena[nX,2],aPequena[nX,5],aPequena[nX,6],aPequena[nX,7],aPequena[nX,8],aPequena[nX,9],nX,{},aPequena[nX,12],aPequena[nX,13],aPequena[nX,14],aPequena[nX,11] }) //-- Caso contrario realiza a inclusão do item no array 
		Else
			aAdd(aGrande[nPosDoc,1],{{},aPequena[nX,1],aPequena[nX,2],aPequena[nX,3],aPequena[nX,4],aPequena[nX,10],aPequena[nX,13]}) //-- Caso contrario realiza a inclusão do item no array
			aAdd(aGrande[nPosDoc,1,Len(aGrande[nPosDoc,1]),1],{aPequena[nX,2],aPequena[nX,5],aPequena[nX,6],aPequena[nX,7],aPequena[nX,8],aPequena[nX,9],nX,{},aPequena[nX,12],aPequena[nX,13],aPequena[nX,14],aPequena[nX,11] }) //-- Caso contrario realiza a inclusão do item no array
		EndIf
	Else
		//-- Caso contrario realiza a inclusão de uma nova posição do documentos
		aAdd(aGrande,{{},aPequena[nX,11],aPequena[nX,14]}) //Documento
		aAdd(aGrande[Len(aGrande),1],{{},aPequena[nX,1],aPequena[nX,2],aPequena[nX,3],aPequena[nX,4],aPequena[nX,10],aPequena[nX,13]}) //-- Caso contrario realiza a inclusão do item no array 
		aAdd(aGrande[Len(aGrande),1,Len(aGrande[Len(aGrande),1]),1],{aPequena[nX,2],aPequena[nX,5],aPequena[nX,6],aPequena[nX,7],aPequena[nX,8],aPequena[nX,9],nX,{},aPequena[nX,12],aPequena[nX,13],aPequena[nX,14],aPequena[nX,11] }) //-- Caso contrario realiza a inclusão do item no array 
	EndIf
Next nX

cFilBkp:= cFilAnt //-- Efetua backup filial do sistema logada

Begin Transaction
For nV := 1 To Len(aGrande)
	For nX := 1 To Len(aGrande[nV,1])
		A179AltFil(aGrande[nV,1,nX,4])	//-- Efetua troca para a filial do documento
		nLE := 0
		nSaldoGrd:= aGrande[nV,1,nX,3] 	//-- Pega saldo total
		//--------------------------------------
		// Considera lote economico e embalagem
		//--------------------------------------
		If lLteEmb
			aNecessCalc := CalcLote(aGrande[nV,1,nX,2],nSaldoGrd,"C")
			If Len(aNecessCalc) > 0
				For nZ := 1 to Len(aNecessCalc)
					nLE += aNecessCalc[nZ]
				Next nZ
			EndIf					
		EndIf
		If nLE > 0 
			nLE -= nSaldoGrd
			nSaldoGrd += nLE
		EndIf
	
		SB1->(MsSeek(xFilial("SB1")+aGrande[nV,1,nX,2]))
		nY:= 1
		While nSaldoGrd > 0
			nSldPeq:= aGrande[nV,1,nX,1,nY,1] //-- Guarda valor com saldo da pequena
			lAvalImp:= lImport .And. SB1->B1_IMPORT == "S"
			If !lAvalImp // Caso não avalia produtos importados
				
				If !Empty(aMedicoes) //-- Realiza uma procura no array de medições geradas para verificar se já não foi medido outro produto
					For nI := 1 To Len(aMedicoes)
						If aMedicoes[nI,1]+ aMedicoes[nI,2] == aGrande[nV,1,nX,2]+aGrande[nV,1,nX,4]
							aAdd(aDocs,{aMedicoes[nI,3], aMedicoes[nI,4]} )
							aDel(aMedicoes,nI)
							aSize(aMedicoes,Len(aMedicoes)-1)
						Endif
					Next nI
					For nI := 1 To Len(aDocs)
						nQtdRegist:= aDocs[nI][1]
						While aDocs[nI][1] > 0 .And. nI <= Len(aGrande[nV,1,nX,1])
							aDocs[nI][1] -= (nSldPeq + nLE)	
							If aDocs[nI][1] > 0
								aAdd(aGrande[nV,1,nX,1,nY,8], {xFilial("CND"),aDocs[nI][2],"5",nSldPeq ,nQtdRegist }) //-- Inclui no array numero do documento e tipo de documento 5-Medição de contrato
								nSaldoGrd -= nSldPeq
								nY += 1
								nSldPeq:= aGrande[nV,1,nX,1,nY,1]
							Else
								aAdd(aGrande[nV,1,nX,1,nY,8], {xFilial("CND"),aDocs[nI][2],"5",(aDocs[nI][1] + nSldPeq) ,nQtdRegist }) //-- Inclui no array numero do documento e tipo de documento 5-Medição de contrato
								nSaldoGrd := nSaldoGrd - (aDocs[nI][1] + nSldPeq + nLE)
								nSldPeq:= Abs(aDocs[nI][1])
							EndIf
						EndDo
					Next nI
					aDocs:= {}
				EndIf

				If !lInverte //-- Fluxo padrão avalia contrato do GCT e contrato de parceria
					If lAvalGCT .And. nSldPeq > 0
						aDocs := MatGeraGCT(aGrande[nV,1,nX,2],nSaldoGrd,@aMedicoes,nCobertura,cRotina) //-- Realiza geração de medições conforme contrato vigente
						For nI := 1 To Len(aDocs)
							nQtdRegist:= aDocs[nI][1]
							While aDocs[nI][1] > 0 .And. nY <= Len(aGrande[nV,1,nX,1])
								aDocs[nI][1] -= (nSldPeq + nLE)	
								If aDocs[nI][1] > 0
									aAdd(aGrande[nV,1,nX,1,nY,8], {xFilial("CND"),aDocs[nI][2],"5",nSldPeq ,nQtdRegist }) //-- Inclui no array numero do documento e tipo de documento 5-Medição de contrato
									nSaldoGrd -= nSldPeq
									nY += 1
									nSldPeq:= aGrande[nV,1,nX,1,nY,1]
								Else
									aAdd(aGrande[nV,1,nX,1,nY,8], {xFilial("CND"),aDocs[nI][2],"5",(aDocs[nI][1] + nSldPeq) ,nQtdRegist }) //-- Inclui no array numero do documento e tipo de documento 5-Medição de contrato
									nSaldoGrd := nSaldoGrd - (aDocs[nI][1] + nSldPeq + nLE)
									nSldPeq:= Abs(aDocs[nI][1])
								EndIf
							EndDo
						Next nI
						aDocs:= {}
					EndIf
					
					If nSldPeq > 0 .And. SB1->B1_CONTRAT $ 'SA' //-- Se tiver saldo a ser gerado e B1_CONTRAT igual à Sim ou Ambos
						aDocs := MatGeraAE(aGrande[nV,1,nX,2],nSaldoGrd,aGrande[nV,1,nX,7],cRotina,,,aGrande[nV,1,nX,6]) //-- Consome o contrato de parceria que estiver com saldo disponivel
						For nI := 1 To Len(aDocs)
							nQtdRegist:= aDocs[nI][1]
							While aDocs[nI][1] > 0 .And. nI <= Len(aGrande[nV,1,nX,1])
								aDocs[nI][1] -= (nSldPeq + nLE)
								If aDocs[nI][1] > 0
									aAdd(aGrande[nV,1,nX,1,nY,8], {xFilial("SC7"),aDocs[nI][2],"3",nSldPeq ,nQtdRegist }) //-- Inclui no array numero do documento e tipo de documento 3-Autorização de Entrega
									nSaldoGrd -= nSldPeq
									nY += 1
									nSldPeq:= aGrande[nV,1,nX,1,nY,1]
								Else
									aAdd(aGrande[nV,1,nX,1,nY,8], {xFilial("SC7"),aDocs[nI][2],"3",(aDocs[nI][1] + nSldPeq) ,nQtdRegist }) //-- Inclui no array numero do documento e tipo de documento 3-Autorização de Entrega
									nSaldoGrd := nSaldoGrd - (aDocs[nI][1] + nSldPeq + nLE)
									nSldPeq:= Abs(aDocs[nI][1])
								EndIf
							EndDo
						Next nI
						aDocs:= {}
					EndIf			
				Else //-- Fluxo Invertido avaliando Contrato de Parceria e Contrato GCT
					If nSldPeq > 0 .And. SB1->B1_CONTRAT $ 'SA' //-- Se tiver saldo a ser gerado e B1_CONTRAT igual à Sim ou Ambos
						aDocs := MatGeraAE(aGrande[nV,1,nX,2],nSaldoGrd,aGrande[nV,1,nX,7],cRotina,,,aGrande[nV,1,nX,6]) //-- Consome o contrato de parceria que estiver com saldo disponivel
						For nI := 1 To Len(aDocs)
							nQtdRegist:= aDocs[nI][1]
							While aDocs[nI][1] > 0 .And. nI <= Len(aGrande[nV,1,nX,1])
								aDocs[nI][1] -= (nSldPeq + nLE)
								If aDocs[nI][1] > 0
									aAdd(aGrande[nV,1,nX,1,nY,8], {xFilial("SC7"),aDocs[nI][2],"3",nSldPeq ,nQtdRegist }) //-- Inclui no array numero do documento e tipo de documento 3-Autorização de Entrega
									nSaldoGrd -= nSldPeq
									nY += 1
									nSldPeq:= aGrande[nV,1,nX,1,nY,1]
								Else
									aAdd(aGrande[nV,1,nX,1,nY,8], {xFilial("SC7"),aDocs[nI][2],"3",(aDocs[nI][1] + nSldPeq) ,nQtdRegist }) //-- Inclui no array numero do documento e tipo de documento 3-Autorização de Entrega
									nSaldoGrd := nSaldoGrd - (aDocs[nI][1] + nSldPeq + nLE)
									nSldPeq:= Abs(aDocs[nI][1])
								EndIf
							EndDo
						Next nI
						aDocs:= {}
					EndIf
					If lAvalGCT .And. nSldPeq > 0
						aDocs := MatGeraGCT(aGrande[nV,1,nX,2],nSaldoGrd,@aMedicoes,nCobertura,cRotina) //-- Realiza geração de medições conforme contrato vigente
						For nI := 1 To Len(aDocs)
							nQtdRegist:= aDocs[nI][1]
							While aDocs[nI][1] > 0 .And. nI <= Len(aGrande[nV,1,nX,1])
								aDocs[nI][1] -= (nSldPeq + nLE)
								If aDocs[nI][1] > 0
									aAdd(aGrande[nV,1,nX,1,nY,8], {xFilial("CND"),aDocs[nI][2],"5",nSldPeq ,nQtdRegist }) //-- Inclui no array numero do documento e tipo de documento 5-Medição de contrato
									nSaldoGrd -= nSldPeq
									nY += 1
									nSldPeq:= aGrande[nV,1,nX,1,nY,1]
								Else
									aAdd(aGrande[nV,1,nX,1,nY,8], {xFilial("CND"),aDocs[nI][2],"5",(aDocs[nI][1] + nSldPeq) ,nQtdRegist }) //-- Inclui no array numero do documento e tipo de documento 5-Medição de contrato
									nSaldoGrd := nSaldoGrd - (aDocs[nI][1] + nSldPeq + nLE)
									nSldPeq:= Abs(aDocs[nI][1])
								EndIf
							EndDo
						Next nI
						aDocs:= {}
					EndIf
				EndIf
				If nSaldoGrd < nLE 
					nLE := nSaldoGrd
				EndIf
				COMGRVSCPC(nSaldoGrd,nSldPeq,@aGrande[nV,1],@aQuebraPC,@aQuebraSC,nX,nY,nLE,cRotina,lEnvMail,aGrande[nV,1,nX,6],nAglutDoc,aGrande[nV,2],aGrande[nV,1,nX,7]) //-- Efetua a geração de pedidos de compra ou solicitação de compra
				nSaldoGrd:= 0
			Else
				COMMNTIMP(nSaldoGrd,nSldPeq,@aGrande[nV,1],nX,nY,@aQuebraSI,@aCabSolic,@aItemSolic,@aImport,aFilial,aGrande[nV,1,nX,7])
				nSaldoGrd -= nSldPeq
			EndIf
			nY++
		EndDo
		
	Next nX

	If lImport .And. Len(aCabSolic) > 0 
		COMGRVIMP(aCabSolic,aItemSolic,aFilial)
	EndIf
	
Next nV
	
End Transaction

//-- Atualiza o controle de alcadas e envia a mensagem do pedido de compra para o TOTVS Colaboracao
If Len(aQuebraPC) > 0
	SC7->(dbSetOrder(3))
	For nX := 1 To Len(aQuebraPC)
		SC7->(dbSeek(aQuebraPC[nX][4]))
		//-- Verifico o controle de alcadas
		lLiberaPC := MaAlcDoc({SC7->C7_NUM,"PC",aQuebraPC[nX][5],,,SC7->C7_APROV,,SC7->C7_MOEDA,SC7->C7_TXMOEDA,SC7->C7_EMISSAO},dDataBase,1)
		While !SC7->(Eof()) .And. SC7->(C7_FILIAL+C7_FORNECE+C7_LOJA+C7_NUM) == aQuebraPC[nX][4]
			//-- Verifico o controle de alcadas
			cQuery := "UPDATE "
			cQuery += RetSqlName("SC7")+" "	
			cQuery += "SET C7_CONAPRO = '"+ IIf(!lLiberaPC .Or. GetNewPar("MV_SIGAGSP","0") == "1" , "B" , "L" ) + "' "
			cQuery += "WHERE C7_FILIAL='"+xFilial("SC7")+"' AND C7_NUM='"+SC7->C7_NUM+"' AND D_E_L_E_T_=' '"
			TcSqlExec(cQuery)	
			SC7->(dbSkip())
		EndDo
	Next nX
EndIf

//-- Atualiza o controle de alcadas
If Len(aQuebraSC) > 0
	SC1->(dbSetOrder(1))
	For nX := 1 To Len(aQuebraSC)
		SC1->(dbSeek(SubStr(aQuebraSC[nX][1], 1, TamSX3("C1_FILIAL")[1])+aQuebraSC[nX][2]))
		While !SC1->(Eof()) .And. SC1->(C1_FILIAL+C1_NUM) == SubStr(aQuebraSC[nX][1], 1, TamSX3("C1_FILIAL")[1])+aQuebraSC[nX][2]
			nScTotLib := SC1->C1_QUANT * Iif(SC1->C1_VUNIT > 0,SC1->C1_VUNIT,MTGetVProd(SC1->C1_PRODUTO))
			aAdd(aItens,{SC1->C1_NUM, SC1->C1_ITEM, "", nScTotLib, {SC1->C1_CC, SC1->C1_CONTA, SC1->C1_ITEMCTA, SC1->C1_CLVL}, SC1->C1_TIPCOM})
			dDtDoc := SC1->C1_EMISSAO
			SC1->(dbSkip())
		EndDo	

		//-- Funcao para aglutinar os itens por entidade ctb
		aAglut := MaRetAglEC( aItens , "SC" )

		//-- Gera SCR para cada entidade contabil
		For nForIt := 1 to Len(aAglut)
			//-- Busca grupo de aprovadores
			aGrpAprov		:= MaGrpApEC( aClone(aAglut[nForIt][4]), @lEntCtb, "SC")
			cGrpAprov 		:= Iif( Len(aGrpAprov) >= 1 , aGrpAprov[1] , "")
			cItAprov		:= Iif( Len(aGrpAprov) >= 2 , aGrpAprov[2] , "")

			If !Empty(cGrpAprov)
				//-- Verifico o controle de alcadas
				MaAlcDoc({aAglut[nForIt][1], "SC", aAglut[nForIt][3],,,cGrpAprov,,,,dDtDoc},,1,,,cItAprov,aClone(aAglut[nForIt,2]),,@aItensDBM)
				For nY := 1 To Len(aAglut[nForIt,2])
					If SC1->(dbSeek(xFilial("SC1")+aAglut[nForIt,1]+aAglut[nForIt,2,nY,1]))
						lGravaB := aScan(aItensDBM , {|x| x[1] == PadR(aAglut[nForIt,2,nY,1],Len(DBM->DBM_ITEM))}) > 0
						lGravaL := MtGLastDBM("SC",aAglut[nForIt,1],aAglut[nForIt,2,nY,1])

						RecLock("SC1",.F.)
						SC1->C1_APROV := If(lGravaB,"B",If(lGravaL,"L",	SC1->C1_APROV))
						SC1->(MsUnlock())
					EndIf
				Next nX
			EndIf
		Next nForIt
		aItens := {}
	Next nX
EndIf

//-- Atualiza variavel que registra quantidade registrada(Total do documento)
For nH:= 1 To Len(aGrande)//-- Linhas de documentos
	For nI:= 1 To Len(aGrande[nH,1])//-- Linhas dos Produtos
		For nJ:= 1 To Len(aGrande[nH,1,nI,1]) //-- Itens do produtos
			For nK:= 1 To Len(aGrande[nH,1,nI,1,nJ,8]) //-- Documentos Gerados
				If aGrande[nH,1,nI,1,nJ,2] == "1" .And. aGrande[nH,1,nI,1,nJ,8,nK,3] == "1" //-- Se o documento gerado foi solicitação de compras efetua seek para atualiza valor registrado
					SC1->(dbSetOrder(1))
					SC1->(MsSeek(aGrande[nH,1,nI,1,nJ,8,nK,1]+aGrande[nH,1,nI,1,nJ,8,nK,2]))
					aGrande[nH,1,nI,1,nJ,8,nK,5]:= SC1->C1_QUANT
				ElseIf aGrande[nH,1,nI,1,nJ,2] == "2" .And. aGrande[nH,1,nI,1,nJ,8,nK,3] == "2" //-- Pedido de Compras 
					SC7->(dbSetOrder(1))
					SC7->(MsSeek(aGrande[nH,1,nI,1,nJ,8,nK,1]+aGrande[nH,1,nI,1,nJ,8,nK,2]))
					aGrande[nH,1,nI,1,nJ,8,nK,5]:= SC7->C7_QUANT
				ElseIf aGrande[nH,1,nI,1,nJ,8,nK,3] == "6" //-- Solicitação de Importação 
					SW1->(dbSetOrder(1)) //-- W1_FILIAL+W1_CC+W1_SI_NUM+W1_COD_I
					SW1->(MsSeek(aGrande[nH,1,nI,1,nJ,8,nK,1]+PadR(cUndRequi,Len(SW1->W1_CC))+aGrande[nH,1,nI,1,nJ,8,nK,2]))
					aGrande[nH,1,nI,1,nJ,8,nK,5]:= SW1->W1_QTDE
				EndIf
				cTipo	:= PADR(aGrande[nH,1,nI,1,nJ,8,nK,3],TamSX3("DHN_TIPO")[1]) 	// Tipo do Documento
				cFilOri	:= If(Empty(aGrande[nH,1,nI,1,nJ,11]),SPACE(TAMSX3("DHN_FILORI")[1]),aGrande[nH,1,nI,1,nJ,11]) //Filial Origem
				cDocOri	:= If(Empty(aGrande[nH,1,nI,1,nJ,12]),SPACE(TamSX3("DHN_DOCORI")[1]),SUBSTR(aGrande[nH,1,nI,1,nJ,12],1,TamSX3("DHN_DOCORI")[1])) //-- Código origem do documento
				cItOri	:= If(Empty(aGrande[nH,1,nI,1,nJ,9]),SPACE(TamSX3("DHN_ITORI")[1]),PADR(aGrande[nH,1,nI,1,nJ,9],TamSX3("DHN_ITORI")[1])) // Item origem do documento
				cFilDes := PADR(aGrande[nH,1,nI,1,nJ,8,nK,1],TamSX3("DHN_FILDES")[1]) 	// Filial destino 
				cDocDes := PADR(SubStr(aGrande[nH,1,nI,1,nJ,8,nK,2],1,6),TamSX3("DHN_DOCDES")[1]) 	// Documento destino
				cItDes 	:= PADR(SubStr(aGrande[nH,1,nI,1,nJ,8,nK,2],7,4),TamSX3("DHN_ITDES")[1]) 	// Item do documento destino
				nQtdAt	:= aGrande[nH,1,nI,1,nJ,8,nK,4]	// Quantidade Atendida
				nQtdTot	:= aGrande[nH,1,nI,1,nJ,8,nK,5] // Quantidade Total
				//DHN_FILIAL+DHN_TIPO+DHN_ROTINA+DHN_FILORI+DHN_DOCORI+DHN_ITORI+DHN_FILDES+DHN_DOCDES+DHN_ITDES                                                                  
				//cSeek := xFilial("DHN")+cTipo+cRotina+cFilOri+cDocOri+cItOri+cFilDes+cDocDes+cItDes
				cSeek := cFilBkp+cTipo+cRotina+cFilOri+cDocOri+cItOri+cFilDes+cDocDes+cItDes
			
				If !(DHN->(dbSeek(cSeek)))
					RecLock("DHN",.T.)
					DHN->DHN_FILIAL	:= xFilial("DHN",cFilBkp)//Filial da DHN é a Logada
					DHN->DHN_TIPO	:= cTipo
					DHN->DHN_ROTINA	:= cRotina
					DHN->DHN_FILORI	:= cFilOri
					DHN->DHN_DOCORI	:= cDocOri
					DHN->DHN_ITORI	:= cItOri
					DHN->DHN_FILDES	:= cFilDes
					DHN->DHN_DOCDES	:= cDocDes
					DHN->DHN_ITDES	:= cItDes
					DHN->DHN_QTDATE	:= nQtdAt
					DHN->DHN_QTDTOT	:= nQtdTot
					DHN->(MsUnlock())
				EndIf
			Next nK
			nPosic:= aGrande[nH,1,nI,1,nJ,7] //-- Posição guardada do array original
			aResultado[nPosic]:= aClone(aGrande[nH,1,nI,1,nJ,8])
		Next nJ
	Next nI
Next nH
A179AltFil(cFilBkp) //Retorna para a filial anterior

//-- Consumo de memoria e performance
Asize( aMedicoes, 0)
aMedicoes := Nil

Asize( aDocs, 0)
aDocs := Nil

Asize( aGrande, 0)
aGrande := Nil

Asize( aPequena, 0)
aPequena := Nil

Return aResultado

//-------------------------------------------------------------------
/*/{Protheus.doc} COMGRVSCPC(nSaldoGrd,nSldPeq,aGrande,@aQuebraPC,@aQuebraSC,nPosGrd,nPosPeq,nLE,cRotina)
Realiza avaliação de saldo no SIGAGCT, Contrato de parceria para realizar geração de documentos de compra.
@param nSaldoGrd - Saldo da query grande
@param nSldPeq	 - Saldo da query pequena
@param aGrande	 - Array total
@param aQuebraPC	 - Pedidos gerados
@param aQuebraSC	 - Solicitações geradas
@param nPosGrd	 - Posição atual do cursor na grande
@param nPosPeq	 - Posição atual do cursor na pequena
@param nLE	 - Quantidade de Lote economico
@param cRotina	 - Rotina

@author Leonardo Quintania
@since 11/05/2015
@version P12
/*/
//-------------------------------------------------------------------

Function COMGRVSCPC(nSaldoGrd,nSldPeq,aGrande,aQuebraPC,aQuebraSC,nPosGrd,nPosPeq,nLE,cRotina,lEnvMail,aRateio,nAglutDoc,cNumDoc,aCampos)
Local aRefImp  	:= {} 
Local aEntSB1	:= MTGETFEC("SB1","B1")
Local aEntSC1	:= MTGETFEC("SC1","C1")
Local aEntSC7	:= MTGETFEC("SC7","C7")
Local aEntidades:= {}
Local aCTBEnt	:= CTBEntArr()

Local cPcAprov	:= SuperGetMv("MV_PCAPROV")
Local cNumSC	:= ""
Local cItemSC 	:= ""
Local cNumPC	:= ""
Local cItemPC	:= ""
Local cFornec	:= ""
Local cLoja		:= ""
Local cCond		:= ""
Local cItemCX	:= ""
Local cItemCH	:= ""
Local lArqSBZ   := AllTrim(SuperGetMV("MV_ARQPROD",.F.,"SB1")) == "SBZ"
Local cLocPad	:= Iif(!lArqSBZ,SB1->B1_LOCPAD,SBZ->BZ_LOCPAD)
Local cEventID	:= ""
Local cProdCam	:= ""
Local cProdSC	:= ""
Local nQtdeSC	:= 0
Local nQtdePC	:= 0
Local nPrcQbr	:= 0
Local nI		:= 0
Local nSaveSX8  := GetSX8Len()
Local nSaveSX8C1:= nSaveSX8
Local nX		:= nPosGrd
Local nY		:= nPosPeq
Local nZ		:= 0
Local nG        := 0
Local nPosSC	:= 0
Local nPosPC	:= 0

Local lMT170FIM := (ExistBlock("MT170FIM"))

Local cFilCompNa:= aGrande[nX,4]
Local cFilEntrNa:= aGrande[nX,5]

Local lFirst	:= .T.
Local lForcaLE	:= nLE > 0 .And. aGrande[nX,1,nY,2] <> "1" 

Default aRateio := {}
Default lEnvMail:= .T.
Default aCampos	:= {}

If (Empty(aCTBEnt))
	aCTBEnt := CTBEntArr()
EndIf

While nSaldoGrd > 0
	
	If aGrande[nX,1,nY,2] == "1" .And. Empty(cNumSC)

		nSaveSX8C1 := GetSX8Len()
		//-- Verifica quebra de documentos
		If nAglutDoc ==  1 .Or. nAglutDoc == 4//-- Verifica se a aglutinação é igual 1 aglutinação por SA
			nPosSC:=  aScan(aQuebraSC,{|x| x[1] == aGrande[nX,4]+aGrande[nX,5]+cNumDoc} )
		ElseIf nAglutDoc == 2 .And. Len(aQuebraSC) > 0 //-- Verifica se a aglutinação é igual 2 aglutinando todos os itens iguais, mas verifica se o array não esta vazio
			nPosSC:= 1 
		Else 
			aAdd(aQuebraSC,{aGrande[nX,4]+aGrande[nX,5],CriaVar("C1_NUM",.T.),StrZero(0,Len(SC1->C1_ITEM)),cNumDoc})
			nPosSC := Len(aQuebraSC)
		Endif
		
		If nPosSC == 0 //-- Filial do documento + Filial de Entrega
			If nAglutDoc ==  1 .Or. nAglutDoc == 4
				aAdd(aQuebraSC,{aGrande[nX,4]+aGrande[nX,5]+cNumDoc,CriaVar("C1_NUM",.T.),StrZero(0,Len(SC1->C1_ITEM)),cNumDoc})
			Else
				aAdd(aQuebraSC,{aGrande[nX,4]+aGrande[nX,5],CriaVar("C1_NUM",.T.),StrZero(0,Len(SC1->C1_ITEM)),cNumDoc})
			EndIf
			nPosSC := Len(aQuebraSC)
		EndIf
		
		While ( GetSX8Len() > nSaveSX8C1 )
			ConfirmSx8()
		EndDo
		
		cNumSC  := aQuebraSC[nPosSC,2]
		cItemSC := Soma1(aQuebraSC[nPosSC,3])
		aQuebraSC[nPosSC,3] := cItemSC
		
		//-- Tratamento para quando estoura qtde de itens
		If cItemSC == Replicate("9",Len(SC1->C1_ITEM))
			aDel(aQuebraSC,nPosSC)
			aSize(aQuebraSC,Len(aQuebraSC)-1)
		EndIf	
	
	ElseIf aGrande[nX,1,nY,2] == "2" .And. (Empty(cNumPC) .Or. !Empty(nPrcQbr))
		//-- Verifica quebra de documentos
		If nAglutDoc ==  1 //-- Verifica se a aglutinação é igual 1 aglutinação por SA
			nPosPC:=  aScan(aQuebraPC,{|x| x[1] == aGrande[nX,4]+; //-- Filial do documento
														 aGrande[nX,5]+; //-- Filial de entrega
														 aGrande[nX,1,nY,3]+;//-- Fornecedor
														 aGrande[nX,1,nY,4]+;//-- Loja do Fornecedor
														 aGrande[nX,1,nY,5]+;//-- Condição de Pagamento
														 cNumDoc;//-- Numero do Documento de quebra
														 })
		ElseIf nAglutDoc == 2 .And. Len(aQuebraPC) > 0 //-- Verifica se a aglutinação é igual 2 aglutinando todos os itens iguais, mas verifica se o array não esta vazio
			nPosPC:= 1
		Else 
			aAdd(aQuebraPC,{aGrande[nX,4]+; //-- Filial do documento
							  aGrande[nX,5]+; //-- Filial de entrega
							  aGrande[nX,1,nY,3]+;//-- Fornecedor
							  aGrande[nX,1,nY,4]+;//-- Loja do Fornecedor
	   						  aGrande[nX,1,nY,5]+;//-- Condição de Pagamento
	   						  cNumDoc;//-- Numero do Documento de quebra
	   						  ,CriaVar("C7_NUM",.T.),StrZero(0,Len(SC7->C7_ITEM)),/*Chave Colaboração*/"",/*Valor Total*/""})
			nPosPC := Len(aQuebraPC)
		Endif
		
		If nPosPC == 0 //-- Filial do documento + Filial de Entrega
			aAdd(aQuebraPC,{aGrande[nX,4]+; //-- Filial do documento
							  aGrande[nX,5]+; //-- Filial de entrega
							  aGrande[nX,1,nY,3]+;//-- Fornecedor
							  aGrande[nX,1,nY,4]+;//-- Loja do Fornecedor
	   						  aGrande[nX,1,nY,5]+;//-- Condição de Pagamento
	   						  cNumDoc;//-- Numero do Documento de quebra
	   						  ,CriaVar("C7_NUM",.T.),StrZero(0,Len(SC7->C7_ITEM)),/*Chave Colaboração*/"",/*Valor Total*/""})
			nPosPC := Len(aQuebraPC)
		EndIf
		
		cNumPC				:= aQuebraPC[nPosPC,2]
		cItemPc				:= Soma1(aQuebraPC[nPosPC,3])
		aQuebraPC[nPosPC,3] := cItemPC	
	EndIf
	//--------------------------------------------
	// Importante: Ordem de Quebra invertida,
	// para forçar while e processar solicitação
	// e pedido em momentos diferentes.
	//---------------------------------------------	
	If lForcaLE
		nQtdeSC := nLE
	Else
		If aGrande[nX,1,nY,2] == "2"
			cFornec := aGrande[nX,1,nY,3] //-- Fornecedor
			cLoja	 := aGrande[nX,1,nY,4] //-- Loja do Fornecedor
			cCond   := aGrande[nX,1,nY,5] //-- Condição de pagamento
			nPrcQbr := aGrande[nX,1,nY,6] //-- Preço
	
			While nSaldoGrd > 0 .And. nPrcQbr == aGrande[nX,1,nY,6]  			
				If lFirst 
					nQtdePC += IIF(nSldPeq == 0,aGrande[nX,1,nY,1],nSldPeq)
					lFirst := .F.
				Else
					nSldPeq:= aGrande[nX,1,nY,1]
					nQtdePC += nSldPeq
					nSaldoGrd -= aGrande[nX,1,nY,1]
				EndIf
				aAdd(aGrande[nX,1,nY,8], {xFilial("SC7"),cNumPc+cItemPc,"2" ,nSldPeq/*Qtd Atendido*/,0/*Qtd Registrado*/}) //-- Inclui no array numero do documento e tipo de documento 2-Pedido de Compra
				nSaldoGrd -= nSldPeq
				nY += 1
			EndDo
			//--Atualiza Quebra Totvs Colaboração
			aQuebraPc[nPosPC][4] := xFilial("SC7")+cFornec+cLoja+cNumPC
			aQuebraPc[nPosPC][5] := NoRound(nQtdePC * nPrcQbr)
		EndIf

		While nSaldoGrd > 0 .And. aGrande[nX,1,nY,2] == '1'
			If lFirst 
				nQtdeSC += IIF(nSldPeq == 0,aGrande[nX,1,nY,1],nSldPeq)
				nSaldoGrd -= nQtdeSC
				nQtdeSC += nLE
				nLE := 0
				lFirst := .F.
			Else
				nSldPeq:= aGrande[nX,1,nY,1]
				nQtdeSC += nSldPeq
				nSaldoGrd -= aGrande[nX,1,nY,1]
			EndIf
			aAdd(aGrande[nX,1,nY,8], {xFilial("SC1"),cNumSC+cItemSC,"1",nSldPeq/*Qtd Atendido*/,0/*Qtd Registrado*/}) //-- Inclui no array numero do documento e tipo de documento 1 - Solicitação de Compras
			nY := nY + 1
			
			//Tratamento para Falhas Estouro aGrande
			If Len(aGrande[nX,1]) < nY
				If nSaldoGrd > 0 
					nSaldoGrd := 0
				EndIf
				Exit
			EndIf	
		EndDo
	EndIf	
	//-- Grava solicitacao compra
	If nQtdeSC > 0 .Or. lForcaLE
		RecLock("SC1",.T.)
		//-- Inicializa os campos Solicitação de Compras
		If ExistBlock("SCGRVINI")
			ExecBlock("SCGRVINI",.F.,.F.)
		Else
			For nI := 1 To SC1->(FCount())
				If SC1->(Field(nI))# "C1_NUM" //Verifica se e o campo de codigo para que nao inicie novamente
					SC1->&(Field(nI)) := CriaVar(SC1->(Field(nI)))
				EndIf
			Next nI
		EndIf
		
		SC1->C1_FILIAL	:= xFilial("SC1",cFilCompNa)
		SC1->C1_NUM		:= cNumSC
		SC1->C1_ITEM	:= cItemSC
		SC1->C1_PRODUTO	:= aGrande[nX,2]
		SC1->C1_DESCRI	:= Posicione("SB1",1,xFilial("SB1",cFilCompNa)+aGrande[nX,2],"B1_DESC")
		SC1->C1_QUANT	:= nQtdeSC
		SC1->C1_UM		:= SB1->B1_UM
		SC1->C1_LOCAL	:= cLocPad
		SC1->C1_DESCRI	:= SB1->B1_DESC
		SC1->C1_SEGUM	:= SB1->B1_SEGUM
		SC1->C1_QTSEGUM	:= ConvUm(aGrande[nX,2],SC1->C1_QUANT,0,2)
		SC1->C1_GRUPCOM	:= MaRetComSC(aGrande[nX,2],UsrRetGrp(),RetCodUsr())
		SC1->C1_USER	:= RetCodUsr()
		SC1->C1_SOLICIT	:= UsrRetName(RetCodUsr())	
		SC1->C1_QTDORIG	:= SC1->C1_QUANT
		SC1->C1_IMPORT	:= "N"
		SC1->C1_FILENT	:= cFilEntrNa
		SC1->C1_REVISAO	:= Posicione("SB5",1,xFilial("SB5",cFilEntrNa)+aGrande[nX,2],"B5_VERSAO")
		SC1->C1_ORIGEM	:= cRotina
		SC1->C1_IMPORT  := IIF(SB1->B1_IMPORT=='S','S','N')
				if IsInCallStack("MATA170")
			SC1->C1_TIPO    := 1   // Inclui sempre solicitação de compras  
		Endif

		dbSelectArea("SCQ")
		SCQ->(dbSetOrder(1)) //CQ_FILIAL+CQ_NUM+CQ_ITEM+CQ_NUMSQ
		If nAglutDoc == 2
			For nG := 1 To Len(aGrande[nX,1])
				If SCQ->(MsSeek(xFilial("SCQ")+aGrande[nX,1,nG,12]+aGrande[nX,1,nG,9]))
					RecLock("SCQ",.F.)
					SCQ->CQ_NUMSC := cNumSC
					SCQ->CQ_ITSC := cItemSC
					SCQ->(MsUnlock())
				EndIf			
			Next nG
		Else
			If SCQ->(MsSeek(xFilial("SCQ")+aGrande[nX,1,1,12]+aGrande[nX,1,1,9]))
				RecLock("SCQ",.F.)
				SCQ->CQ_NUMSC := cNumSC
				SCQ->CQ_ITSC := cItemSC
				SCQ->(MsUnlock())
			EndIf
		EndIf

		//-- Grava Entidades contabeis
		For nI := 1 to len(aEntSB1)
			If aEntSB1[nI] == "B1_ITEMCC"
				SC1->C1_ITEMCTA := SB1->B1_ITEMCC
			ElseIf SC1->(FieldPos("C1" + substr(aEntSB1[nI],3))) > 0							
				SC1->&("C1" + substr(aEntSB1[nI],3)) := SB1->&(aEntSB1[nI])							
			EndIf
		Next nI
		
		//-- Grava campos especificos da rotina que chamou
		For nI := 1 To Len(aCampos)
			If SC1->(FieldPos("C1_" +AllTrim(aCampos[nI,1]))) > 0
				cProdCam := IIf(Len(aCampos[nI]) > 2 .And. aCampos[nI,3] == "PRODUTO",aCampos[nI,4],"")
				cProdSC	:= SC1->C1_PRODUTO
				If !Empty(cProdCam)
					If AllTrim(cProdCam) == AllTrim(cProdSC)
						SC1->&("C1_" +AllTrim(aCampos[nI,1])) := aCampos[nI,2]
					EndIf
				Else
					SC1->&("C1_" +AllTrim(aCampos[nI,1])) := aCampos[nI,2]
				EndIf
			EndIf
		Next nI

		If lForcaLE
			SC1->C1_OBS := STR0153 // "Solicitação automaticamente para atender a necessidade de lote econômico." 
		EndIf
		
		If Len(aRateio) > 1 //-- Se tiver rateio configurado, efetua limpeza dos campos nos itens, pois prevalecerá as entidades contabeis no rateio.
			For nI := 1 to Len(aEntSC1)
				If SC1->(FieldPos(aEntSC1[nI])) > 0
					SC1->&(aEntSC1[nI])	 := ""
				Endif
			Next nI
		EndIf

		//-- Executa avaliação do tipo de Compra
		SC1->C1_TIPCOM := MRetTipCom(,.T.,"SC")
		
		SC1->(MsUnlock())
		
		If lMT170FIM .And. IsInCallStack("MATA170")
			MT170GOPSO(aGrande[nX,2],cNumSC)
		EndIf
		
		cItemCX:= "00"
		//-- Grava dados dos rateios
		For nY := 1 To Len(aRateio)
			If !Empty(StrTran(aRateio[nY,2],"|",""))
			    aEntidades:= StrTokArr ( aRateio[nY,2], "|" )
				cItemCX := Soma1(cItemCX)	
				RecLock("SCX",.T.)
				SCX->CX_FILIAL	:= xFilial("SCX")
				SCX->CX_SOLICIT := SC1->C1_NUM
				SCX->CX_ITEMSOL	:= SC1->C1_ITEM
				SCX->CX_ITEM 	:= cItemCX
				SCX->CX_CC 		:= aEntidades[1]
				SCX->CX_CONTA 	:= aEntidades[2]
				SCX->CX_ITEMCTA	:= aEntidades[3]
				SCX->CX_CLVL	:= aEntidades[4]
				SCX->CX_PERC 	:= aRateio[nY,1]
				
				//-- Grava entidades contabeis
				For nZ := 1 To Len(aCTBEnt)
					SCX->&("CX_EC"+aCTBEnt[nZ]+"CR") := aEntidades[nZ+4]
					SCX->&("CX_EC"+aCTBEnt[nZ]+"DB") := aEntidades[nZ+5]
				Next nZ
				SCX->(MsUnlock())
			EndIf
		Next nY
		MaAvalSC("SC1",1) //-- Atualiza os acumulados da SC
		If lEnvMail
			If !Empty(RetFldProd(SB1->B1_COD,"B1_EMIN"))
				nSaldoSB2 := SB2->B2_QATU + SB2->B2_SALPEDI - SB2->B2_QEMPSA - SB2->B2_QPEDVEN
				If nSaldoSB2 <= RetFldProd(SB1->B1_COD,"B1_EMIN")
					MEnviaMail("001",{SB1->B1_COD,SB1->B1_DESC,SC1->C1_LOCAL,nQtdeSC,RetFldProd(SB1->B1_COD,"B1_EMIN")," - "+STR0138+" "+SC1->C1_NUM})
				EndIf
			EndIf
			
			// Envia e-mail na inclusao de SC's     
			dbSelectarea("SXI")
			SXI->(dbsetorder(2))
			cEventID  := "035"
			If msSeek('002' + '001' + cEventID) 
				cMensagem:=STR0136+" - "+SC1->C1_NUM+" - "+STR0137
				EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID,FW_EV_LEVEL_INFO,""/*cCargo*/,STR0138,cMensagem,.T./*lPublic*/)
				cNumSA := SC1->C1_NUM
			Else
				MEnviaMail(cEventID,{SC1->C1_NUM})
			Endif
		EndIf
		nQtdeSC := 0
		lForcaLE := .F.
	EndIf	
	//-- Grava pedido de compra
	If nQtdePC > 0
		RecLock("SC7",.T.)
		//-- Inicializa os Campos Pedido de Compra
		For nI := 1 To SC7->(FCount())
			If SC7->(Field(nI)) # "C7_NUM" //-- Verifica se e o campo de codigo para que nao inicie novamente
				SC7->&(Field(nI)) := CriaVar(SC7->(Field(nI)))
			EndIf
		Next nI
		SC7->C7_FORNECE	:= cFornec	
		SC7->C7_LOJA   	:= cLoja
		SC7->C7_COND   	:= cCond
		//-- Verifica a quais impostos devem ser gravados
		aRefImp := MaFisRelImp('MT100',{"SC7"})
		MaFisIni(SC7->C7_FORNECE,SC7->C7_LOJA,"F","N",Nil,aRefImp,,.T.)
		MaFisIniLoad(1)
		For nI := 1 To Len(aRefImp)
			MaFisLoad(aRefImp[nI][3],FieldGet(FieldPos(aRefImp[nI][2])),1)
		Next nI
		MaFisEndLoad(1)
		MaFisEnd()
		//-- Grava Pedido de Compra
		SC7->C7_FILIAL	:= xFilial("SC7",cFilCompNa)
		SC7->C7_NUM		:= cNumPc
		SC7->C7_ITEM	:= cItemPC
		SC7->C7_EMISSAO	:= dDataBase
		SC7->C7_FILENT 	:= xFilial("SC7",cFilEntrNa)
		SC7->C7_MOEDA  	:= 1
		SC7->C7_TIPO   	:= 1
		SC7->C7_PRODUTO	:= aGrande[nX,2]
		SC7->C7_DESCRI	:= Posicione("SB1",1,xFilial("SB1",cFilCompNa)+aGrande[nX,2],"B1_DESC")
		SC7->C7_QUANT	:= nQtdePC
		SC7->C7_PRECO	:= nPrcQbr
		SC7->C7_TOTAL	:= NoRound(nQtdePC * nPrcQbr)
		SC7->C7_LOCAL 	:= SB1->B1_LOCPAD
		SC7->C7_DESCRI	:= SB1->B1_DESC
		SC7->C7_UM    	:= SB1->B1_UM
		SC7->C7_SEGUM 	:= SB1->B1_SEGUM
		SC7->C7_TES 	:= SB1->B1_TE
		SC7->C7_QTSEGUM	:= ConvUm(aGrande[nX,2],nQtdePC,0,2)
		SC7->C7_USER	:= RetCodUsr()
		SC7->C7_GRUPCOM	:= SY1->Y1_GRUPCOM
		SC7->C7_APROV   := If(!Empty(SY1->Y1_GRAPROV),SY1->Y1_GRAPROV,cPcAprov)
		SC7->C7_FISCORI := SC7->C7_FILIAL
		SC7->C7_ORIGEM	:= cRotina
		
		//-- Grava entidades contabeis
		For nI := 1 to len(aEntSB1)
			If aEntSB1[nI] == "B1_ITEMCC"
				SC7->C7_ITEMCTA := SB1->B1_ITEMCC
			ElseIf FieldPos("C7" + substr(aEntSB1[nI],3)) > 0
				SC7->&("C7" + substr(aEntSB1[nI],3)) := SB1->&(aEntSB1[nI])							
			EndIf
		Next nI

		//-- Grava campos especificos da rotina que chamou
		For nI := 1 To Len(aCampos)
			If SC7->(FieldPos("C7_" +AllTrim(aCampos[nI,1]))) > 0
				SC7->&("C7_" +aCampos[nI,1]) := aCampos[nI,2]
			EndIf
		Next nI

		If Len(aRateio) > 1 //-- Se tiver rateio configurado, efetua limpeza dos campos nos itens, pois prevalecerá as entidades contabeis no rateio.
			For nI := 1 to Len(aEntSC7)
				If SC7->(FieldPos(aEntSC7[nI])) > 0
					SC7->&(aEntSC7[nI])	 := ""
				EndIf
			Next nI
		EndIf

		//-- Atualizo os acumulados do Pedido de Compra
		CriaSB2(SC7->C7_PRODUTO,SC7->C7_LOCAL,xFilial("SC7",cFilEntrNa))
		SB2->(DbSetOrder(1))
		If SB2->(dbSeek(SC7->(C7_FILENT+C7_PRODUTO+C7_LOCAL)))
			SB2->(GravaB2Pre("+",SC7->C7_QUANT,"F"))
		EndIf
		
		//-- Executa avaliação do tipo de Compra
		SC7->C7_TIPCOM := MRetTipCom(,.T.,"PC")
		
		SC7->(MsUnlock())
		
		cItemCH:= "00"
		//-- Grava dados dos rateios
		For nY := 1 To Len(aRateio)
			If !Empty(StrTran(aRateio[nY,2],"|",""))
			    aEntidades:= StrTokArr ( aRateio[nY,2], "|" )
				cItemCH := Soma1(cItemCH)	
				RecLock("SCH",.T.)
				SCH->CH_FILIAL	:= xFilial("SCH")
				SCH->CH_PEDIDO  := SC7->C7_NUM
				SCH->CH_FORNECE := SC7->C7_FORNECE
				SCH->CH_LOJA 	:= SC7->C7_LOJA
				SCH->CH_ITEMPD 	:= SC7->C7_ITEM
				SCH->CH_ITEM 	:= cItemCH
				SCH->CH_CC 		:= aEntidades[1]
				SCH->CH_CONTA 	:= aEntidades[2]
				SCH->CH_ITEMCTA	:= aEntidades[3]
				SCH->CH_CLVL	:= aEntidades[4]
				SCH->CH_PERC 	:= aRateio[nY,1]
				
				//-- Grava entidades contabeis
				For nZ := 1 To Len(aCTBEnt)
					SCH->&("CH_EC"+aCTBEnt[nZ]+"CR") := aEntidades[nZ+4]
					SCH->&("CH_EC"+aCTBEnt[nZ]+"DB") := aEntidades[nZ+5]
				Next nZ
				SCH->(MsUnlock())
			EndIf
		Next nY
		
		nQtdePC := 0
		If lEnvMail
			SC7->(MsSeek(xFilial("SC7")+cNumPc))
			MEnviaMail("037",{SC7->C7_NUM,SC7->C7_NUMCOT,SC7->C7_APROV,SC7->C7_CONAPRO,Subs(cUsuario,7,15)})
		EndIf		
	EndIf
EndDo

Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} MTAjustExp(cExp)
Ajusta expressão para obter valores do aCols e campos do cabeçalho
ou campos diretamente da tabela

@param cExp - Expressão
@author Flavio Lopes Rasta
@since 27/08/2015
@version 12
/*/
//-------------------------------------------------------------------
Function MTAjustExp(cExp,aAddFields,lRecorded)

Local aCpoCab    := {}
Local nX         := 0
Local nPosCompar := 0
Local nPosExp    := 0
Local nPosNext   := 0
Local cCampoM    := StrTran(ReadVar(),"M->","")
Local cNewExp    := ""
Local cBkpExp    := ""
Local lContinua  := .T.
Local lLast      := .F.

Default cExp       := ""
Default aAddFields := {}
Default lRecorded  := .F.

cExp := StrTran(cExp,"M->","")
cExp := StrTran(cExp,"SC1->","")
cExp := StrTran(cExp,"SC7->","")
If !lRecorded
	For nX := 1 To Len(aAddFields)
		aAdd(aCpoCab,{PadR(aAddFields[nX,1],10),aAddFields[nX,2]})
	Next nX
	
	If (At(" .OR. ",cExp) < At(" .AND. ",cExp) .And. At(" .OR. ",cExp) > 0) .Or. (At(" .OR. ",cExp) > At(" .AND. ",cExp) .And. At(" .AND. ",cExp) = 0)
		nPosExp  := At(" .OR. ",cExp)
		nPosNext := 5
	Else
		nPosExp  := At(" .AND. ",cExp)
		nPosNext := 6
	EndIf
	
	If nPosExp > 0
		cBkpExp := cExp
		cExp := ""
		While lContinua
			If nPosExp > 0 
				cNewExp := SubStr(cBkpExp,1,nPosExp+nPosNext)
			Else
				cNewExp := cBkpExp
			EndIf	
			If At(">",cNewExp) > 0
				nPosCompar := At(">",cNewExp)
			ElseIf At("<",cNewExp) > 0
				nPosCompar := At("<",cNewExp)
			ElseIf At("!",cNewExp) > 0
				nPosCompar := At("!",cNewExp)	
			ElseIf At("=",cNewExp) > 0
				nPosCompar := At("=",cNewExp)
			EndIf
			
			cNewExp := PadR(SubStr(cNewExp,1,nPosCompar-1),11," ") + SubStr(cNewExp,nPosCompar,Len(cNewExp))
			aEval(aHeader,{|x| cNewExp := Strtran(cNewExp,x[2],If(x[2] == cCampoM,ReadVar(),"aCols["+AllTrim(Str(n))+"][GDFieldPos('"+ x[2] +"')]"))})
			cExp += cNewExp
			
			cBkpExp := SubStr(cBkpExp,nPosExp+nPosNext,Len(cBkpExp))
			
			If (At(" .OR. ",cExp) < At(" .AND. ",cExp) .And. At(" .OR. ",cExp) > 0) .Or. (At(" .OR. ",cExp) > At(" .AND. ",cExp) .And. At(" .AND. ",cExp) = 0)
				nPosExp  := At(" .OR. ",cBkpExp)
				nPosNext := 5
			Else
				nPosExp  := At(" .AND. ",cBkpExp)
				nPosNext := 6
			EndIf
			If lLast
				lContinua := .F.
			EndIf
			If nPosExp == 0	
				lLast := .T.
			EndIf
		End
	Else
		If At(">",cExp) > 0
			nPosCompar := At(">",cExp)
		ElseIf At("<",cExp) > 0
			nPosCompar := At("<",cExp)
		ElseIf At("!",cExp) > 0
			nPosCompar := At("!",cExp)	
		ElseIf At("=",cExp) > 0
			nPosCompar := At("=",cExp)
		EndIf
		
		cExp := PadR(SubStr(cExp,1,nPosCompar-1),11," ") + SubStr(cExp,nPosCompar,Len(cExp))
		aEval(aHeader,{|x| cExp := Strtran(cExp,x[2],If(x[2] == cCampoM,ReadVar(),"aCols["+AllTrim(Str(n))+"][GDFieldPos('"+ x[2] +"')]"))})
		
	EndIf
	If !Empty(aCpoCab)
		aEval(aCpoCab,{|x| cExp := IIf(x[1]=="C7_NUM    ",Strtran(Strtran(cExp,x[1],x[2]),"cA120NumIMP","C7_NUMIMP"),Strtran(cExp,x[1],x[2]))})
	EndIf
Else
	cExp := Strtran(cExp,"C1_","SC1->C1_")
	cExp := Strtran(cExp,"C7_","SC7->C7_")
EndIf


Return cExp

//-------------------------------------------------------------------
/*/{Protheus.doc} MTExecExp(cExp)
Executa a expressão e caso ocorra algum erro não gera errorlog.

@param cExp - Expressão
@author Flavio Lopes Rasta
@since 27/08/2015
@version 12
/*/
//-------------------------------------------------------------------
Function MTExecExp(cExp)
Local bRet
Local lRet := .F.
Local bErrBlock := ErrorBlock()

ErrorBlock( {|e| MATExpErro(e) } )
                                                                 
BEGIN SEQUENCE

bRet := __CompStr(cExp)
If ValType(bRet) != "U"
    lRet := __RunCB(bRet)
Else
    MATExpErro()
    Return NIL
EndIf

RECOVER 

lRet := NIL

END SEQUENCE

ErrorBlock( bErrBlock )

Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc} MATExpErro(cExp)
Retorna erro da expressão inválida

@author Flavio Lopes Rasta
@since 27/08/2015
@version 12
/*/
//-------------------------------------------------------------------
Function MATExpErro(oError,lError,cError,cMsg,lExibe)
Local cMsgCom := STR0148 //"Existe um erro na fórmula digitada"
                                    
Default cMsg     := ""
Default lExibe    := .T.

If Valtype(oError) == "O"
	Alert(iif(Empty(cMsg),cMsgCom,cMsg)+iif(lExibe,CHR(13)+CHR(10)+AllTrim(oError:Description),""))   
EndIf

BREAK

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} MTIniLeg()
Função de iniciaização da legenda do tipo de compra

@author Flavio Lopes Rasta
@since 09/03/2015
@version 12
@return cRet 
/*/
//-------------------------------------------------------------------
Function MTIniLeg(cTipCom)
Local cRet:= "BR_BRANCO"

If !Empty(cTipCom)
	DbSelectArea("DHK")
	DHK->(DbSetOrder(1))
	If DHK->(DbSeek(xFilial("DHK")+cTipCom))
		cRet:= x3CboxToArray("DHK_LEGEND")[1][Val(DHK->DHK_LEGEND)]
		cRet := "BR_"+SubStr(cRet,At('-',cRet)+2)
	Endif
Endif

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MTAtuTpCom()
Função que atualiza o campo de tipo de compra das entidades

@author Flavio Lopes Rasta
@since 09/03/2015
@version 12
@return lRet 
/*/
//-------------------------------------------------------------------
Function MTAtuTpCom(cTabela,lGrava)
Local aAreaDHK		:= DHK->(GetArea())
Local cCondTpCom	:= ""
Local cRet			:= ""
Local cExp			:= ""

Default lGrava := .F.

DbSelectArea("DHK")
DHK->(DbSetOrder(2))
If DHK->(DbSeek(xFilial("DHK")))
	While !DHK->(Eof()) .And. DHK->DHK_FILIAL == xFilial("DHK")
		If DHK->DHK_ATIVO == '1' .And. ((cTabela == "SC7" .And. !Empty(DHK->DHK_PEDCOM)) .Or. (cTabela == "SC1" .And. !Empty(DHK->DHK_SOLCOM)))
			cCondTpCom := MTAjustExp(If(cTabela == "SC7",DHK->DHK_PEDCOM,DHK->DHK_SOLCOM),,.T.,cTabela)
			If MTExecExp(cCondTpCom)
				cRet := DHK->DHK_CODIGO 
				Exit
			Else
				cRet := ""
			EndIf
		Endif
		DHK->(DbSkip())
	EndDo
Endif

If lGrava
	If cTabela == "SC1"
		RecLock("SC1",.F.)
		Replace SC1->C1_TIPCOM with cRet
		SC1->(MsUnlock())
	ElseIf cTabela == "SC7"
		RecLock("SC7",.F.)
		Replace SC7->C7_TIPCOM with cRet
		SC7->(MsUnlock())
	Endif
Endif

RestArea( aAreaDHK )

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MTSoliCAT
Geração do processo geral de compras

@author taniel.silva
@param cTipoDoc
@param cNumDoc
@param cAlias

@since 08/04/2014
@version P12
@return Nil
/*/
//-------------------------------------------------------------------

Function MTSoliCAT(cTipoDoc,cNumDoc,cAlias,cCampo,cUserSolic,lGeraNivel)
Local lFluig		:= !Empty(AllTrim(GetNewPar("MV_ECMURL",""))) .And. FWWFFluig()
Local aAreaSCR	:= {}
Local cNivel		:= ""
Local aNextTask	:= {}
Local cSCRFil		:= ""
Local cSolicit	:= ""
Local cUsrApr	:= ""
// VERIFICAR SE É O CODIGO DO SOLICITANTE
Default cUserSolic 	:= RetCodUsr()
Default lGeraNivel	:= .F.

If lFluig

	If lGeraNivel // Gera documento independente do nivel	
		cSolicit := FWWFColleagueId(cUserSolic)
		cUsrApr  := FWWFColleagueId(A097UsuApr(SCR->CR_APROV))
		aNextTask := {2,cSolicit,{cUsrApr}}
		StartProcess(cTipoDoc,cSolicit,{cSolicit},,,,,aNextTask,.T.)
	Else
		If cTipoDoc $ 'IC|CT|IR|RV'
			cSCRFil := CnFilCtr(cNumDoc)
		Else
			cSCRFil := xFilial("SCR")
		EndIf

		SCR->(DbSetOrder(1))
		If SCR->(DbSeek(cSCRFil+cTipoDoc+PadR(cNumDoc,TamSX3("CR_NUM")[1])))
			cNivel := A097FstNiv(SCR->CR_GRUPO,cTipoDoc,cNumDoc)
			While SCR->(!Eof()) .And.  SCR->CR_FILIAL+SCR->CR_NUM == cSCRFil+PadR(cNumDoc,TamSX3("CR_NUM")[1])
				If SCR->CR_NIVEL==cNivel
					cSolicit := FWWFColleagueId(cUserSolic)
					cUsrApr  := FWWFColleagueId(A097UsuApr(SCR->CR_APROV))
					aNextTask := {2,cSolicit,{cUsrApr}}
					StartProcess(cTipoDoc,cSolicit,{cSolicit},,,,,aNextTask,.T.)
				Endif
				SCR->(DbSkip())
			EndDo
		EndIf
	Endif
EndIf

Return nil

//-------------------------------------------------------------------
/*/{Protheus.doc} MTFlgLbDoc
Liberação genérica de processos do Fluig

@author rafael.duram
@param cNum		Numero do Documento a Liberar
@param cUser		Codigo do Usuario Responsavel
@param cAprov		Situacao da aprovacao
@param cTipo		Tipo do Processo
@param cFluig		Codigo do Processo do Fluig
@param cParecer	Parecer informado na aprovacao
@param oModelCT	Modelo do contrato para aprovação de revisões

@since 13/10/2015
@version P12
@return lRet
/*/
//-------------------------------------------------------------------

Function MTFlgLbDoc(cNum,cUser,cAprov,cTipo,cFluig,cParecer,oModelCT)
Local 	lRet 	:= .F.
Local	lLock	:= .F.
Local	cLocKey:=	"WFAPR"+cUser+cFluig
Local	cChave	:=	""
Local  cSCRFil:= ""
Local	nX		:= 0

Private aFluigIR	:= {}
Default oModelCT	:= NIL

cNum := PADR(cNum,TAMSX3('CR_NUM')[1],' ')
cUser := AllTrim(cUser)

If cTipo $ 'IC|CT|IR|RV'
	cSCRFil := CnFilCtr(cNum)
Else
	cSCRFil := xFilial("SCR")
EndIf

While lLock == .F. .And. nX < 3
	If (lLock := LockByName(cLocKey,.F.,.F.))
		DbSelectArea("SCR")
		SCR->(DbSetOrder(2))
		If SCR->(DbSeek(cSCRFil+cTipo+cNum+cUser)) .And. cAprov != '0'
			While !Eof() .And. cSCRFil+cTipo+cNum+cUser == SCR->(CR_FILIAL+CR_TIPO+CR_NUM+CR_USER)
				If AllTrim(SCR->CR_FLUIG) == cFluig .And. (SCR->CR_STATUS == '03' .Or. SCR->CR_STATUS == '06') // Verifica se já foi aprovado e finaliza
					lRet := .T.
					Exit
				ElseIf Alltrim(SCR->CR_FLUIG) == cFluig .And. SCR->CR_STATUS == '02' // Verifica se está em aberto
					Begin Transaction
						If !Empty(cParecer) // Verifica se foi informado parecer na aprovação
							RecLock("SCR",.F.)
							SCR->CR_OBS := cParecer
							SCR->(MsUnlock())
						Endif
						If cAprov == '1' // Aprovado
							// Libera documento
							If cTipo $ "CT|IC|RV|IR|MD|IM"
								If cTipo $ "MD|IM" // Posiciona a medição
									DbSelectArea("CND")
									CND->(DbSetOrder(4))
									CND->(MsSeek(xFilial("CND")+Substr(cNum,1,TamSX3("CND_NUMMED")[1])))
								Endif
								lRet := GCTAlcEnt(oModelCT,MODEL_OPERATION_UPDATE,4,cTipo,cNum)
								If lRet .And. cTipo $ "MD|IM" .AND. MtGLastDBM(cTipo,cNum) .AND. SuperGetMV("MV_CNMDEAT",.F.,.F.)
									CN121Encerr(.T.)
								EndIf
							Else
								A097ProcLib(SCR->(Recno()),2,,,,,dDataBase)
							Endif
							lRet := .T.
						Elseif cAprov == '2' // Rejeitado
							If cTipo $ "CT|IC|RV|IR|MD|IM"
								lRet := CnRejDoc(SCR->CR_TIPO)
							Else
								If cTipo $ "PC|ST"
									Do Case															
										Case SCR->CR_TIPO == "PC"
											cChave := xFilial("SC7")+Substr(SCR->CR_NUM,1,TamSX3("C7_NUM")[1])
																		
										Case SCR->CR_TIPO == "ST"
											cChave := xFilial("NNS")+Substr(SCR->CR_NUM,1,TamSX3("NNS_COD")[1])
									EndCase
								Endif
								MaAlcDoc({SCR->CR_NUM,SCR->CR_TIPO,,SCR->CR_APROV,,SCR->CR_GRUPO,,,,dDataBase,cParecer}, dDataBase ,7,,,,,,,cChave)
								lRet := .T.
							Endif
						Endif
					End Transaction
					Exit
				ElseIf Alltrim(SCR->CR_FLUIG) == cFluig .And. SCR->CR_STATUS <> '02' .And. SCR->CR_STATUS <> '01' // Verifica se já foi movimentado
					lRet := .T.
				Endif
				SCR->(DbSkip())
			EndDo
		EndIf
	Else
		nX++
		If nX >= 3
			lRet := .F.
			Help('',1,'WFAPR',,STR0139+' '+cFluig+' '+STR0140) //'O processo' # 'já está em execução por outra transação, favor aguardar alguns minutos e tentar novamente.'
			Conout(STR0139+' '+cFluig+' '+STR0140)
		Else				
			Sleep(1000)
		Endif
	EndIf
EndDo

If lLock
	UnLockByName(cLocKey,.F.,.F.)
EndIf


Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MRetTipCom
Retorna avaliação do Tipo de Compra para o item posicionado

@author rafael.duram
@param aDlgFields Array com variáveis que possuem valores de campos do cabeçalho da tela Modelo 2

@since 09/08/2016
@version P12
@return cRet
/*/
//-------------------------------------------------------------------

Function MRetTipCom(aDlgFields,lRecorded,cTipo)

Local aAreaAnt 	:= GetArea()
Local aAreaDHK 	:= DHK->(GetArea())
Local cRet		 	:= ""
Local cCondTpCom	:= ""
Default aDlgFields:= {}
Default lRecorded := .F.
Default cTipo		:= "PC"

DbSelectArea("DHK")
DHK->(DbSetOrder(2))
If DHK->(DbSeek(xFilial("DHK")))
	While !DHK->(Eof()) .And. DHK->DHK_FILIAL == xFilial("DHK")
		If cTipo == "PC" .And. DHK->DHK_ATIVO == '1' .And. !Empty(DHK->DHK_PEDCOM)
			cCondTpCom := MTAjustExp(DHK->DHK_PEDCOM,aDlgFields,lRecorded)
			If MTExecExp(cCondTpCom)
				cRet := DHK->DHK_CODIGO
				Exit
			Endif
		ElseIf cTipo == "SC" .And. DHK->DHK_ATIVO == '1' .And. !Empty(DHK->DHK_SOLCOM)
			cCondTpCom := MTAjustExp(DHK->DHK_SOLCOM,aDlgFields,lRecorded)
			If MTExecExp(cCondTpCom)
				cRet := DHK->DHK_CODIGO
				Exit
			Endif
		Endif
		DHK->(DbSkip())
	EndDo
Endif

RestArea(aAreaDHK)
RestArea(aAreaAnt)

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} COMMNTIMP()
Função para montar o array do cabeçalho e itens da solicitação de importação. 
@author Leonardo Quintania
@since 18/03/2016
@version P12
@return Nil
/*/
//-------------------------------------------------------------------
Function COMMNTIMP(nSaldoGrd,nSldPeq,aGrande,nPosGrd,nPosPeq,aQuebraSI,aCabSolic,aItemSolic,aImport,aFilial,aCampos)
Local cItemSI 		:= ""
Local cNumSI		:= ""
Local nX			:= nPosGrd
Local nY			:= nPosPeq
Local cFilCompNa	:= aGrande[nX,4]
Local cFilEntrNa	:= aGrande[nX,5]
Local cUndRequi		:= SuperGetMv("MV_CCUNREQ")
Local cUser			:= Alltrim(RetCodUsr())
Local cCodCompr		:= ""
Local nPosSI		:= 0
Local nPos			:= 0
Local lCria			:= .F.

DEFAULT aGrande 	:= {}
DEFAULT aCampos		:= {}

SY1->(dbSetOrder(3))	
If SY1->(dbSeek(xFilial("SY1")+cUser))
	cCodCompr := SY1->Y1_COD
EndIf

SY1->(dbSetOrder(1))
lCria:= ( nPosSI := aScan(aQuebraSI,{|x| x[1] == (cFilCompNa+cFilEntrNa)} ) ) == 0

If lCria
	cNumSI:= NextNumEIC()
	aAdd(aQuebraSI,{(cFilCompNa+cFilEntrNa),cNumSI,StrZero(0,Len(SW1->W1_POSIT))})
	nPosSI := Len(aQuebraSI)				
	aAdd(aFilial,{cFilCompNa })
	aAdd(aCabSolic,{})
	aAdd(aItemSolic,{})
	aAdd(ATail(aCabSolic), {'W0_FILIAL', xFilial("SW0",cFilCompNa)	,Nil})
	aAdd(ATail(aCabSolic), {'W0__CC',    cUndRequi					,Nil})
	aAdd(ATail(aCabSolic), {'W0__NUM',   cNumSI						,Nil})	
	aAdd(ATail(aCabSolic), {'W0_COMPRA', cCodCompr					,Nil})
	aAdd(ATail(aCabSolic), {'W0__DT', 	  dDataBase					,NIl})
Else
	cNumSI	:=aCabSolic[nPosSI,3,2]					
EndIf			 

If (nPos := aScan(aImport,aGrande[nX,2]+cFilCompNa+cFilEntrNa)) > 0 	
	cItemSI := aItemSolic[1,nPos,1,2]
	aItemSolic[1,nPos,3,2] += nSldPeq
Else						
	cItemSI := Soma1(aQuebraSI[nPosSI,3])
	aQuebraSI[nPosSI,3] := cItemSI
	
	aAdd(aItemSolic[nPosSI],{})					
	aAdd(ATail(aItemSolic[nPosSI]),{'W1_POSIT' , cItemSI		, Nil})
	aAdd(ATail(aItemSolic[nPosSI]),{'W1_COD_I' , aGrande[nX,2]	, Nil})
	aAdd(ATail(aItemSolic[nPosSI]),{'W1_QTDE'  , nSldPeq		, Nil})
	aAdd(ATail(aItemSolic[nPosSI]),{'W1_PRECO' , 0              , Nil})
	aAdd(ATail(aItemSolic[nPosSI]),{'W1_COD_DE', ""             , Nil})			
	aAdd(aImport, aGrande[nX,2]+cFilCompNa+cFilEntrNa)
EndIf

aAdd(aGrande[nX,1,nY,8], {xFilial("SW1"),cNumSI+aGrande[nX,2],"6" ,nSldPeq/*Qtd Atendido*/,0/*Qtd Registrado*/}) //-- Inclui no array numero do documento e tipo de documento 6-Solicitação de Importação

Return NIL 

//-------------------------------------------------------------------
/*/{Protheus.doc} COMGRVIMP()
Função que chama msexecauto para a criação da solicitação de importação. 
@author Leonardo Quintania
@since 18/03/2016
@version P12
@return Nil
/*/
//-------------------------------------------------------------------
Function COMGRVIMP(aCabSolic,aItemSolic,aFilial)
Local cFilAntBkp	:= ""
Local nX 			:= 0
Local nZ 			:= 0

Private lMsErroAuto	:= .F.

cFilAntBkp := cFilAnt

For nX := 1 To Len(aCabSolic)
	A179AltFil(aFilial[nX][1])
	MSExecAuto( {|x,y,z| EICSI400(x, y, z) },aCabSolic[nX], aItemSolic[nX], 3)
	If lMsErroAuto
		MostraErro()
		DisarmTransaction()
		Exit
	EndIf
Next nX

A179AltFil(cFilAntBkp)		
		
Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} COMPESQFOR()
Efetua pesquisa do fornecedor para a biblioteca de compras
@author Leonardo Quintania
@since 18/03/2016
@version P12
@return Nil
/*/
//-------------------------------------------------------------------
Function COMPESQFOR(cProduto)
Local cCodFor	:= ""
Local cLojFor	:= ""
Local cFilialSA5	:= xFilial("SA5")

If SB1->(dbSeek(xFilial("SB1")+cProduto))
	If !Empty(SB1->B1_PROC)
		cCodFor := SB1->B1_PROC
		cLojFor := SB1->B1_LOJPROC
	Else //-- Senão executa query para pesquisa de fornecedores na amarração Produto X Fornecedor (SA5)
		BeginSQL Alias "TMPSA5"
			SELECT SA5.A5_FORNECE,SA5.A5_LOJA,SA5.A5_CODTAB
			FROM %Table:SA5% SA5
			WHERE SA5.A5_FILIAL = %Exp:cFilialSA5% AND
			SA5.A5_PRODUTO = %Exp:cProduto% AND
			SA5.%NotDel%
			ORDER BY SA5.A5_NOTA DESC
		EndSQL
	
		If !TMPSA5->(EOF())
			cCodFor := TMPSA5->A5_FORNECE
			cLojFor := TMPSA5->A5_LOJA
		EndIf
		TMPSA5->(dbCloseArea())
	EndIf
EndIf

Return {cCodFor,cLojFor}

//-------------------------------------------------------------------
/*/{Protheus.doc} COMPESQPRECO()
Efetua pesquisa do preco para utilização na chamada do COMGERADOC
@author Leonardo Quintania
@since 18/03/2016
@version P12
@return Nil
/*/
//-------------------------------------------------------------------
Function COMPESQPRECO(cProduto,cFilForn,cCodFor,cLojFor)
Local cFilialSA5	:= xFilial("SA5")
Local cFilialSB2	:= xFilial("SB2")
Local cFilAntBkp	:= ""
Local nPrecoProd	:= 0

cFilAntBkp  := cFilAnt

If SB1->(dbSeek(xFilial("SB1")+cProduto))
	//-- Posiciona armazém padrão para análise do custo
	SB2->(dbSetOrder(1))
	SB2->(MsSeek(cFilialSB2+SB1->B1_COD+SB1->B1_LOCPAD))
	
	SA5->(dbSetOrder(1))
	If SA5->(MsSeek(cFilialSA5+cCodFor+cLojFor+SB1->B1_COD))
		A179AltFil(cFilForn)
		nPrecoProd := MaTabPrCom(SA5->A5_CODTAB,SB1->B1_COD,0,cCodFor,cLojFor)
		A179AltFil(cFilAntBkp)
	EndIf 
	
	If nPrecoProd == 0 //-- Se tabela vazia
		Do Case
			Case SB1->B1_UPRC > 0 //-- Tenta ultimo preço de compra
				nPrecoProd := SB1->B1_UPRC
			Case SB1->B1_CUSTD > 0 //-- Senão custo standard
				nPrecoProd := SB1->(xMoeda(SB1->B1_CUSTD,Val(SB1->B1_MCUSTD),1,SB1->B1_UCALSTD))
			Case SB2->B2_CM1 > 0 //-- Senão custo médio
				nPrecoProd := SB2->B2_CM1
		EndCase
	EndIf
EndIf

Return nPrecoProd

//-------------------------------------------------------------------
/*/{Protheus.doc} COMDTNECES()
Retorna o menor prazo de necessidade de uma lista em dias, para chamada da COMGERADOC
@author Rafael Duram
@since 09/05/2016
@version P12
@return nDiasNec
/*/
//-------------------------------------------------------------------
Function COMDTNECES(aDatasNec)
Local nMenorNec 	:= 30
Local dNecMenor	:= dDataBase + nMenorNec
Local dDataCalc	:= CTOD(" / / ")
Local nX			:= 0
Local nDiasNec	:= 0
Default aDatasNec	:= {}

For nX:=1 To Len(aDatasNec)
	If aDatasNec[nX] < dNecMenor .And. aDatasNec[nX] >= dDataBase
		dNecMenor := aDatasNec[nX] 
	Endif
Next nX

dDataCalc := dDataBase

While dDataCalc < dNecMenor
	dDataCalc++
	nDiasNec++
EndDo

Return nDiasNec 

/*/{Protheus.doc} COMEXCDHN()
Funcao generica para excluir item da tabela DHN a partir de um codigo e tipo passados. 
@author Adriano Vieira
@since 21/06/2017
@version P12
@return Nil
/*/
//-------------------------------------------------------------------
Function COMEXCDHN(cTipo,cFil,cDoc)
Local cFilialDHN	:= xFilial("DHN")
Local cAliasTMP		:= GetNextAlias()
Local aArea			:= GetArea()
BeginSQL Alias cAliasTMP
    SELECT DHN.DHN_FILIAL,DHN.DHN_TIPO,DHN.DHN_ROTINA,DHN.DHN_FILORI,DHN.DHN_DOCORI,DHN.DHN_ITORI,DHN.DHN_FILDES,DHN.DHN_DOCDES
    FROM %Table:DHN% DHN
    WHERE DHN.DHN_FILIAL = %Exp:cFilialDHN% AND
    DHN.DHN_TIPO = %Exp:cTipo% AND
    DHN.DHN_FILDES = %Exp:cFil% AND
    DHN.DHN_DOCDES = %Exp:cDoc% AND
    DHN.%NotDel%
    ORDER BY DHN.DHN_FILDES,DHN.DHN_DOCDES
EndSQL

While !(cAliasTMP)->(EOF()) .And. (cAliasTMP)->(DHN_TIPO+DHN_FILIAL+DHN_FILDES+DHN_DOCDES) == cTipo+xFilial("DHN")+cFil+cDoc
    If DHN->(dbSeek((cAliasTMP)->(DHN_FILIAL+DHN_TIPO+DHN_ROTINA+DHN_FILORI+DHN_DOCORI+DHN_ITORI+DHN_FILDES+DHN_DOCDES))) //DHN_FILIAL+DHN_TIPO+DHN_ROTINA+DHN_FILORI+DHN_DOCORI+DHN_ITORI+DHN_FILDES+DHN_DOCDES                                                               

    	If IsInCallStack("A110Deleta")
	    	SCQ->(DBSETORDER(2))
	    	If SCQ->(dBSeek(xFilial("SCQ")+DHN->DHN_DOCDES+DHN->DHN_ITDES))
				RecLock("SCQ")
		        SCQ->CQ_NUMSC 	:= Space(Len(SCQ->CQ_NUMSC))
		        SCQ->CQ_ITSC 	:= Space(Len(SCQ->CQ_ITSC))
				MsUnlock()    	    
	    	EndIf
	    EndIf
	    
		RecLock("DHN",.F.,.T.)
        DHN->(dbDelete())
		MsUnlock()
    EndIf
    (cAliasTMP)->(dbSkip())
EndDo

(cAliasTMP)->(dbCloseArea())
RestArea(aArea)
Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} COMPosDHN()
Posiciona tabela de Documentos da Biblioteca, verificando se o índice
já existe no dicionário, caso não exista, utiliza uma query para posicionar
o registro

@param	aParamDHN, array, onde é composto da seguinte forma:
			[1] 	Numero do indice desejado da tabela DHN
			[2, y] 	Array com valores para a montagem da 
					chave do indice informado
@param	lUsaAlias, logico, Se deve mantar o SELECT em aberto ou não

@author José Eulálio
@since  17/08/2017
@version 1.0
@return {lRet,cQryDHN,aRecnoDHN}
/*/
//-------------------------------------------------------------------
Function COMPosDHN(aParamDHN,lUsaAlias)
Local cChave	:= ""
Local cQuery	:= ""
Local cOrder	:= ""
Local cQryDHN	:= ""
Local nIndice 	:= 0
Local nX		:= 0
Local aArea		:= GetArea()
Local aAreaSIX	:= SIX->(GetArea())
Local aRecnoDHN	:= {}
Local lRet 		:= .F.

Default aParamDHN	:= {}
Default lUsaAlias	:= .T.

//Verifica se foram passados os parâmetros
If Len(aParamDHN) > 1

	nIndice := aParamDHN[1]
	//Verifica se o índice existe no dicionário, se não utiliza query
	SIX->(DbSetOrder(1))
	If SIX->(DbSeek("DHN" + str(nIndice)))
		//Monta chave
		For nX := 1 To Len(aParamDHN[2])
			cChave += aParamDHN[2][nX]
		Next nX
		//posiciona
		DHN->(DbSetOrder(nIndice))
		If DHN->(DbSeek(xFilial("DHN") + cChave))
			lRet := .T.
		EndIf
	Else
		//Monta where de acordo com o índice
		If nIndice == 2 // DHN_FILIAL+DHN_FILORI+DHN_DOCORI+DHN_ITORI+DHN_ROTINA+DHN_TIPO+DHN_FILDES+DHN_DOCDES+DHN_ITDES
			For nX := 1  To Len(aParamDHN[2])
				If ValType(aParamDHN[2][nX]) == "C"
					Do Case
						Case nX == 1
							cChave += " DHN_FILORI = '" + aParamDHN[2][nX] + "' "
						Case nX == 2
							cChave += " AND DHN_DOCORI = '" + aParamDHN[2][nX] + "' "
						Case nX == 3
							cChave += " AND DHN_ITORI = '" + aParamDHN[2][nX] + "' "
						Case nX == 4
							cChave += " AND DHN_TIPO = '" + aParamDHN[2][nX] + "' "
						Case nX == 5
							cChave += " AND DHN_ROTINA = '" + aParamDHN[2][nX] + "' "
					EndCase
				EndIf
			Next nX

			//Ordena
			cOrder := " DHN_FILORI,DHN_DOCORI,DHN_ITORI,DHN_ROTINA,DHN_TIPO,DHN_FILDES,DHN_DOCDES,DHN_ITDES "

		ElseIf nIndice == 3 //DHN_FILIAL+DHN_TIPO+DHN_FILDES+DHN_DOCDES+DHN_ITDES+DHN_ROTINA+DHN_FILORI+DHN_DOCORI+DHN_ITORI
			For nX := 1 To Len(aParamDHN[2])
				If ValType(aParamDHN[2][nX]) == "C"
					Do Case
						Case nX == 1
							cChave += " DHN_TIPO = '" + aParamDHN[2][nX] + "' "
						Case nX == 2
							cChave += " AND DHN_FILDES = '" + aParamDHN[2][nX] + "' "
						Case nX == 3
							cChave += " AND DHN_DOCDES = '" + aParamDHN[2][nX] + "' "
						Case nX == 4
							cChave += " AND DHN_ITDES = '" + aParamDHN[2][nX] + "' "
					EndCase
				EndIf
			Next nX

			//ordena
			cOrder := "DHN_FILIAL,DHN_TIPO,DHN_FILDES,DHN_DOCDES,DHN_ITDES,DHN_ROTINA,DHN_FILORI,DHN_DOCORI,DHN_ITORI"

		EndIf
		cChave += " AND D_E_L_E_T_ = ' '"

		//executa query
		cQuery := "SELECT DHN_FILIAL,DHN_TIPO,DHN_FILDES,DHN_DOCDES,DHN_ITDES,DHN_ROTINA,DHN_FILORI,DHN_DOCORI,DHN_ITORI,DHN_QTDATE,DHN_QTDTOT, R_E_C_N_O_ RecnoDHN "
		cQuery += " FROM " + RetSqlName("DHN")
		cQuery += " WHERE " + cChave
		cQuery += " ORDER BY " + cOrder
		cQuery := ChangeQuery(cQuery)

		cQryDHN	:= GetNextAlias()
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cQryDHN,.T.,.T.)

		If Select(cQryDHN)>0
			//posiciona no recno retornado
			If (cQryDHN)->RecnoDHN > 0
				DHN->(DbGoTo((cQryDHN)->RecnoDHN))
				lRet := .T.
				If !lUsaAlias
					While !(cQryDHN)->(EoF())
						Aadd(aRecnoDHN,(cQryDHN)->RecnoDHN)
						(cQryDHN)->(DbSkip())
					EndDo
					(cQryDHN)->(DbCloseArea())
					cQryDHN:=""
				EndIf
			Else
				(cQryDHN)->(DbCloseArea())
				cQryDHN:=""
			EndIf
		Else
			cQryDHN:=""
		EndIf

	EndIf

EndIf

RestArea(aAreaSIX)
RestArea(aArea)

Return {lRet,cQryDHN,aRecnoDHN}

//-------------------------------------------------------------------
/*/{Protheus.doc} NextNumEIC()
Avalia o proximo numero disponivel na tabela SW0
@author Totvs
@since 02/10/2017
@version P12
@return Nil
/*/
//-------------------------------------------------------------------
Static Function NextNumEIC()
Local cNumEIC	:= StrZero(1,TamSX3("W0__NUM")[1])
Local cQuery    := ""
Local cAliasQry := GetNextAlias()
Local cFilialSW0:= xFilial("SW0")
Local cUndRequi	:= SuperGetMv("MV_CCUNREQ")
Local aArea     := GetArea()

cQuery := " SELECT MAX(W0__NUM) W0__NUM"
cQuery += " FROM " + RetSqlName('SW0')
cQuery += " WHERE W0_FILIAL = '" + cFilialSW0 + "'" 
cQuery += " AND W0__CC = '" + cUndRequi + "'" 
cQuery += " AND D_E_L_E_T_ = ' '"

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

If !( cAliasQry )->( Eof() )
	cNumEIC:= Soma1((cAliasQry)->W0__NUM)
EndIf

(cAliasQry)->(dbCloseArea())
RestArea(aArea)

Return cNumEIC

//----------------------------------------------------------------------
/*/{Protheus.doc} ClearGrid()
Limpa a grid, passando o  modelo e nome da grid por parâmetro
@author Leonardo Bratti
@since 21/10/2017
@version 1.0
@return .T.
/*/
//----------------------------------------------------------------------
Function ClearGrid(oModel , cName)
	Local nY         := 0
	Local oModelCL   := oModel:getModel(cName)
	Local aHeader    := oModelCL:aHeader
	Local nTamAnt    := oModelCL:Length()	
		
	nNewLine := oModelCL:AddLine()
	oModelCL:GoLine( nNewLine )			
	oModelCL:LineShift(1,nNewLine)
	oModelCL:GoLine(nNewLine)
	For nY := nTamAnt+1 To 2 Step -1 
		oModelCL:GoLine(nY)
		oModelCL:DeleteLine(.T.,.T.)				
	Next	
	oModelCL:GoLine(1) 
Return .T.

//----------------------------------------------------------------------
/*/{Protheus.doc} COMXCOT() 
Busca pelo numero do cotação
@author Rodrigo M Pontes
@since 21/10/2017
@version 1.0
@return .T.
/*/
//----------------------------------------------------------------------

Static Function COMXCOT(cNumSC, cItemSC) 

Local cRet		:= ""
Local cQry		:= ""
Local aArea		:= GetArea()
Local cAliasTmp	:= GetNextAlias()

DbSelectArea("SC1")
SC1->(DbSetOrder(1))
If SC1->(DbSeek(xFilial("SC1") + cNumSC + cItemSC))
	If !Empty(SC1->C1_COTACAO)
		cRet := SC1->C1_COTACAO
	Else
		//Busca na SC8
		cQry := " SELECT C8_NUM"
		cQry += " FROM " + RetSqlName("SC8")
		cQry += " WHERE D_E_L_E_T_ = ''"
		cQry += " AND C8_NUMSC = '" + cNumSC + "'"
		cQry += " AND C8_ITEMSC = '" + cItemSC + "'"
		
		cQry := ChangeQuery(cQry)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAliasTmp,.T.,.T.)
		
		DbSelectArea(cAliasTmp)
		If (cAliasTmp)->(!EOF())
			cRet := SC8->C8_NUM
		Else
			cRet := Repl("X",Len(SC1->C1_COTACAO))
		Endif
	Endif
Endif

RestArea(aArea)

Return cRet

//----------------------------------------------------------------------
/*/{Protheus.doc} ComAvCot() 
Aviso sobre o numero do pedido de compras gerado na analise de cotacao
@author Romulo Batista
@since 16/04/2019
@version 1.0
@return .T.
/*/
//----------------------------------------------------------------------

Function ComAvCot(aPedidos) 

Local nX	  := 0
Local cTexto  := ""
Local cPedNbr := "" 

Local oDlg
Local oFont
Local oTMultiget1

Default aPedidos := {}

For nX := 1 To Len(aPedidos)
	cPedNbr += Chr(13) + Chr(10) + cValToChar(aPedidos[nX,2]) + Chr(13) 
Next nX

cTexto := STR0159 + Chr(13) + Chr(10) + cPedNbr

DEFINE MSDIALOG oDlg TITLE FunName() FROM 000,000 TO 300,400 PIXEL

oFont := TFont():New('Arial',,-14,.T.)
oTMultiget1 := tMultiget():new( 00, 00, {| u | if( pCount() > 0, cTexto := u, cTexto ) }, ;
oDlg, 300, 400,oFont , , , , ,.T., , , , , ,.T., , , ,.F.,.T.)

ACTIVATE MSDIALOG oDlg CENTERED
 
Return 
